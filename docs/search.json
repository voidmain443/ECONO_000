[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "economics_000",
    "section": "",
    "text": "Preface\n경제학과 신입생을 위한 파이썬 수업에 강사를 맏게 된 박준하입니다.\n여러분은 앞으로 미시경제, 거시경제, 계량경제 등 다양한 경제학 분야를 탐구하며 세상을 이해하는 새로운 시각을 배우게 될 것입니다. 이러한 학문적 여정에서 데이터 분석과 모델링 능력은 점점 더 중요해지고 있으며, 파이썬(Python)은 현대 경제학 연구와 분석에 있어 가장 강력하고 필수적인 도구 중 하나로 자리 잡았습니다.\n과거에는 복잡한 경제 데이터를 분석하거나 경제 모델을 시뮬레이션하기 위해 특정 통계 소프트웨어에 의존하는 경우가 많았습니다. 하지만 파이썬은 뛰어난 범용성과 강력한 데이터 과학 라이브러리 생태계를 바탕으로, 데이터 수집 및 처리, 통계 분석, 시각화, 머신러닝 모델링에 이르기까지 경제 분석의 전 과정을 아우르는 유연하고 효율적인 환경을 제공합니다.\n이 책은 경제학을 처음 접하는, 그리고 프로그래밍이 낯설 수 있는 신입생 여러분을 위해 특별히 설계되었습니다. 파이썬의 가장 기초적인 문법부터 시작하여 변수, 자료형, 조건문, 반복문 등 핵심 개념을 차근차근 익힐 것입니다. 중요한 것은, 이러한 프로그래밍 개념을 단순히 배우는 데 그치지 않고, 여러분에게 익숙한 ’수요와 공급’과 같은 기초 경제학 원리와 예제를 통해 배우고 응용한다는 점입니다.\n각 주차별 학습을 통해 여러분은 다음과 같은 능력을 키울 수 있습니다.\n총 8주간의 여정을 통해 여러분은 파이썬이라는 강력한 도구를 손에 쥐고, 경제학적 사고를 더욱 확장할 수 있는 튼튼한 기초를 다지게 될 것입니다. 프로그래밍이 처음에는 다소 어렵게 느껴질 수도 있습니다. 하지만 이 책에서 제시하는 단계별 설명과 예제를 꾸준히 따라오신다면, 어느새 파이썬으로 경제 데이터를 분석하고 있는 자신을 발견하게 될 것입니다.\n자, 이제 경제학적 통찰력에 컴퓨팅 능력을 더하는 흥미로운 여정을 함께 시작해 봅시다!",
    "crumbs": [
      "Preface"
    ]
  },
  {
    "objectID": "index.html#과정-목표",
    "href": "index.html#과정-목표",
    "title": "economics_000",
    "section": "과정 목표:",
    "text": "과정 목표:\n\n파이썬 기초 프로그래밍 능력 습득\n기초 경제학 개념(수요, 공급, 균형 등)을 파이썬 코드로 구현 및 분석\n데이터 시각화를 통한 경제 현상 이해 증진\n향후 계량경제학, 데이터 분석 등 심화 학습을 위한 기초 마련\n\n주차별 학습 내용:\n\n\n\n\n\n\n\n\n\n주차\n주요 학습 주제\n세부 내용\n경제학 연계 내용/예제\n\n\n\n\n1\n파이썬 소개 및 환경 설정\n파이썬이란? 경제학에서의 파이썬 활용 사례. 아나콘다(Anaconda) 설치 및 주피터 노트북(Jupyter Notebook) 사용법. print() 함수, 주석, 기본 산술 연산.\n간단한 총비용, 총수입 계산. 경제 지표 출력 연습.\n\n\n2\n변수와 기본 자료형\n변수(Variable) 개념 및 명명 규칙. 숫자형(Integer, Float), 문자열(String), 불리언(Boolean) 자료형. input() 함수를 이용한 사용자 입력 받기.\n가격(Price), 수량(Quantity), 상품 이름 등 경제 변수 저장. 예산 제약 하 소비 가능 여부 판단 (Boolean).\n\n\n3\n조건문 (If 문)\nif, elif, else 조건문 문법. 비교 연산자 (==, !=, &lt;, &gt;, &lt;=, &gt;=), 논리 연산자 (and, or, not). 코드 들여쓰기의 중요성.\n가격 변화에 따른 구매 결정. 특정 소득 수준에 따른 세금 구간 적용. 수요의 법칙 예시 (가격 오르면 수요 감소).\n\n\n4\n리스트와 반복문 (For)\n순서가 있는 자료구조: 리스트(List) 생성, 인덱싱, 슬라이싱. for 반복문 기본 구조. range() 함수 활용. 리스트 요소 순회.\n여러 기간 동안의 가격/수량 데이터 리스트 저장. 리스트 내 평균 가격 계산. 특정 조건 상품 필터링.\n\n\n5\n반복문 (While)과 자료구조 심화\nwhile 반복문 기본 구조. 무한 루프 및 break. 딕셔너리(Dictionary) 자료구조 (Key-Value). 리스트와 딕셔너리 활용 연습.\n특정 예산 소진 시까지 상품 구매 시뮬레이션 (while). 상품 이름과 가격 매핑 (딕셔너리).\n\n\n6\n함수와 경제 모델 기초\n함수(Function) 정의(def) 및 호출. 매개변수(Parameter)와 반환값(Return). 함수의 필요성 (코드 재사용). 지역 변수와 전역 변수.\n수요 함수 Qd = f(P), 공급 함수 Qs = g(P)를 파이썬 함수로 정의하기. 특정 가격 입력 시 수요량/공급량 계산 함수 만들기.\n\n\n7\n데이터 시각화 기초 (Matplotlib)\nMatplotlib 라이브러리 소개 및 기본 사용법. 선 그래프(Line plot) 그리기. 축 레이블, 제목, 범례 추가.\n가격 변화에 따른 수요량/공급량 변화를 리스트로 준비. 수요 곡선과 공급 곡선 시각화.\n\n\n8\n균형 분석 및 응용\n수요/공급 함수의 연립을 통한 균형 가격 및 균형 거래량 계산 (간단한 경우). 시각화된 그래프에서 균형점 확인. 수요/공급 변화(shift) 시뮬레이션 및 시각화.\n파이썬 코드로 균형점 계산 함수 만들기. 외부 충격(예: 소득 증가, 기술 발전) 발생 시 새로운 균형점 시각화 및 분석.\n\n\n\n\n본 강의의 내용들은 일부 tts 등을 이용하여 강의 현장의 구어체등이 같이 작성되어 있을 수 있습니다. 버전 2버전 (다음학기) 등에서 이는 수정될 것입니다.",
    "crumbs": [
      "Preface"
    ]
  },
  {
    "objectID": "Introduction.html",
    "href": "Introduction.html",
    "title": "1  week1. Introduction to python",
    "section": "",
    "text": "2 파이썬 소개 (Google Colab 환경)\n강의 개요:\n안녕하세요, 여러분! 경제학 분석 여정의 첫걸음을 떼는 시간입니다. 이번 주에는 왜 우리가 파이썬을 배워야 하는지 알아보고, 코딩 작업 환경인 Google Colab과 친숙해지는 시간을 갖겠습니다. 또한, 파이썬의 가장 기본적인 명령어인 print() 함수, 코드에 설명을 다는 주석, 그리고 파이썬을 계산기처럼 사용하는 방법에 대해 배우고 직접 실습해 볼 것입니다.\n이번 시간 학습 목표:\n준비물:",
    "crumbs": [
      "Curriculum",
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>week1. Introduction to python</span>"
    ]
  },
  {
    "objectID": "Introduction.html#들어가며-왜-경제학도가-파이썬을-배워야-할까요",
    "href": "Introduction.html#들어가며-왜-경제학도가-파이썬을-배워야-할까요",
    "title": "1  week1. Introduction to python",
    "section": "2.1 들어가며: 왜 경제학도가 파이썬을 배워야 할까요?",
    "text": "2.1 들어가며: 왜 경제학도가 파이썬을 배워야 할까요?\n여러분 중 많은 분들이 ‘경제학 공부하기도 바쁜데, 왜 코딩까지 배워야 할까?’ 하는 생각을 하실 수 있습니다. 아주 합리적인 질문이죠.\n전통적으로 경제학 분석에는 엑셀(Excel)과 같은 스프레드시트 프로그램이나 이뷰(EViews), 스테이타(Stata) 같은 통계 패키지가 많이 사용되었습니다. 이 도구들은 여전히 특정 작업에 유용하지만, 현대 경제학이 다루는 데이터의 규모와 복잡성은 점점 커지고 있습니다.\n\n데이터의 규모: 이제는 수백만, 수천만 건을 넘어서는 빅데이터를 다루는 경우가 많아졌습니다. 엑셀은 일정 규모 이상의 데이터를 다루기 어렵습니다.\n분석의 복잡성: 최신 계량경제 모델이나 머신러닝 기법을 적용하려면 기존 통계 패키지만으로는 한계가 있을 수 있습니다.\n자동화와 반복 작업: 웹에서 데이터를 주기적으로 가져오거나(크롤링), 동일한 분석을 여러 데이터셋에 반복 적용하는 등의 작업을 자동화하기 어렵습니다.\n재현성: 다른 연구자가 분석 과정을 똑같이 따라하고 검증하기 어렵게 만드는 ‘클릭 기반’ 작업 방식의 한계가 있습니다.\n\n파이썬은 이러한 문제들을 해결하는 데 강력한 해답을 제시합니다:\n\n다재다능함(Versatility): 파이썬은 데이터 분석뿐만 아니라 웹 개발, 자동화, 인공지능 등 다양한 분야에서 쓰이는 범용 언어입니다. 즉, 한번 배워두면 활용 범위가 매우 넓습니다.\n강력한 생태계(Rich Ecosystem): NumPy(수치 계산), Pandas(데이터 처리), Matplotlib/Seaborn(시각화), Scikit-learn(머신러닝), Statsmodels(통계 분석) 등 경제/데이터 분석에 필수적인 고성능 라이브러리(미리 만들어진 코드 모음)가 풍부합니다. 이 라이브러리 덕분에 복잡한 작업도 비교적 쉽게 수행할 수 있습니다.\n오픈 소스 및 무료: 누구나 무료로 사용할 수 있고, 전 세계 수많은 개발자와 사용자들이 함께 발전시키는 활발한 커뮤니티를 가지고 있어 문제 해결에 도움을 받기 용이합니다.\n코드 기반의 재현성: 모든 분석 과정이 코드로 기록되므로, 분석 결과를 다른 사람이 쉽게 확인하고 재현할 수 있습니다. 이는 과학적 연구의 투명성과 신뢰성을 높이는 데 중요합니다.\n\n결론적으로, 파이썬을 배우는 것은 여러분의 경제학 분석 능력을 한 단계 끌어올리고, 미래의 데이터 기반 사회에서 경쟁력을 갖추는 데 큰 도움이 될 것입니다. 조금 낯설더라도 즐거운 마음으로 함께 시작해 봅시다!",
    "crumbs": [
      "Curriculum",
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>week1. Introduction to python</span>"
    ]
  },
  {
    "objectID": "Introduction.html#우리의-클라우드-작업실-google-colab-시작하기",
    "href": "Introduction.html#우리의-클라우드-작업실-google-colab-시작하기",
    "title": "1  week1. Introduction to python",
    "section": "2.2 우리의 클라우드 작업실: Google Colab 시작하기",
    "text": "2.2 우리의 클라우드 작업실: Google Colab 시작하기\n파이썬 코드를 작성하고 실행하려면 ’개발 환경’이 필요합니다. 우리는 설치가 필요 없고 무료로 사용할 수 있는 Google Colaboratory (Colab) 을 사용할 것입니다.\nColab 접속 및 새 노트 만들기:\n\n웹 브라우저에서 colab.research.google.com 으로 접속합니다.\nGoogle 계정으로 로그인합니다.\n파일 &gt; 새 노트 메뉴를 선택하여 새로운 빈 노트를 만듭니다.\n노트 상단의 UntitledX.ipynb 부분을 클릭하여 파일 이름을 Week1_Practice.ipynb 처럼 바꿔줍니다. (자동으로 구글 드라이브에 저장됩니다.)\n\nColab 기본 인터페이스:\n\n셀(Cell): Colab 노트북은 여러 개의 ’셀’로 구성됩니다. 셀에는 크게 두 종류가 있습니다.\n\n코드 셀: 파이썬 코드를 입력하고 실행하는 곳입니다. 회색 배경이고 왼쪽에 실행(▶) 버튼이 있습니다.\n텍스트 셀: 설명, 제목, 이미지 등을 넣는 곳입니다. 지금 여러분이 읽고 있는 이 내용도 텍스트 셀에 작성된 것입니다. (더블클릭하면 편집 가능하며, Markdown이라는 간단한 서식 문법을 사용합니다.)\n\n셀 실행: 셀을 실행하려면 해당 셀을 클릭하고 Shift + Enter 키를 누르거나 셀 왼쪽의 실행(▶) 버튼을 클릭하면 됩니다. 코드 셀은 코드를 실행하고 결과를 아래에 보여주고, 텍스트 셀은 서식이 적용된 텍스트를 보여줍니다.\n셀 추가/삭제: 화면 상단 메뉴 아래의 + 코드, + 텍스트 버튼으로 셀을 추가할 수 있고, 셀을 선택한 상태에서 오른쪽의 휴지통 아이콘으로 삭제할 수 있습니다.\n\n[실습] Colab 인터페이스 익숙해지기\n\n+ 코드 버튼을 눌러 아래에 새로운 코드 셀을 추가해보세요.\n+ 텍스트 버튼을 눌러 새로운 텍스트 셀을 추가하고, 간단한 메모(예: “Colab 사용 연습 중”)를 작성한 뒤 Shift + Enter를 눌러보세요.\n방금 만든 셀들을 선택하고 휴지통 아이콘을 눌러 삭제해보세요.",
    "crumbs": [
      "Curriculum",
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>week1. Introduction to python</span>"
    ]
  },
  {
    "objectID": "Introduction.html#화면에-글자-출력하기-print-함수",
    "href": "Introduction.html#화면에-글자-출력하기-print-함수",
    "title": "1  week1. Introduction to python",
    "section": "2.3 화면에 글자 출력하기 (print() 함수)",
    "text": "2.3 화면에 글자 출력하기 (print() 함수)\n자, 이제 첫 파이썬 코드를 작성해 봅시다! 파이썬에게 우리가 원하는 내용을 화면에 보여달라고 요청할 때 print() 함수를 사용합니다.\nprint() 함수는 괄호 () 안에 출력하고 싶은 내용을 넣으면 됩니다. 만약 글자(문자열)를 출력하고 싶다면, 내용을 따옴표(\" 또는 ')로 감싸줘야 합니다.\n예제 1: 기본적인 문자열 출력\n\nprint(\"Hello, Economics World!\")\n\nHello, Economics World!\n\n\n\nprint('파이썬 공부를 시작합니다.') # 작은따옴표도 가능합니다.\n\n파이썬 공부를 시작합니다.\n\n\n예제 2: 숫자 출력\n숫자를 출력할 때는 따옴표 없이 그냥 숫자를 넣으면 됩니다.\n\nprint(123)\n\n123\n\n\n\nprint(3.14159)\n\n3.14159\n\n\n예제 3: 계산 결과 출력\n괄호 안에 직접 계산식을 넣으면, 파이썬이 계산을 먼저 수행하고 그 결과를 출력해 줍니다.\n\nprint(100 + 50) # 덧셈 결과 출력\n\n150\n\n\n\nprint(10 * 5) # 곱셈 결과 출력\n\n50\n\n\n예제 4: 여러 내용 함께 출력하기 (쉼표 사용)\nprint() 함수 안에 쉼표(,)를 사용하여 여러 개의 값(문자열, 숫자 등)을 나열하면, 각 값 사이에 공백이 하나씩 들어가면서 함께 출력됩니다.\n\nprint(\"가격:\", 15000, \"원\")\n\n가격: 15000 원\n\n\n\nprint(\"오늘의 판매량:\", 50, \"개,\", \"목표 달성!\")\n\n오늘의 판매량: 50 개, 목표 달성!\n\n\n\n[실습 1] print() 함수 사용 연습\n아래 요구사항에 맞춰 print() 함수를 사용하여 결과를 출력하는 코드를 각각의 코드 셀에 작성해보세요.\n\n본인의 이름 또는 별명을 화면에 출력하세요.\n숫자 2025를 화면에 출력하세요.\n50 * 10 의 계산 결과를 화면에 출력하세요.\n“수업 과목:” 이라는 글자와 “파이썬 수업” 이라는 글자를 쉼표를 이용해 한 줄에 함께 출력하세요. (결과 예: 수업 과목: 파이썬 수업)\n\n\n\n# 실습 1-1: 본인 이름/별명 출력\n# 여기에 코드를 작성하세요.\n\n\n# 실습 1-2: 숫자 2025 출력\n# 여기에 코드를 작성하세요.\n\n\n# 실습 1-3: 50 * 10 계산 결과 출력\n# 여기에 코드를 작성하세요.\n\n\n# 실습 1-4: 여러 내용 함께 출력\n# 여기에 코드를 작성하세요.",
    "crumbs": [
      "Curriculum",
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>week1. Introduction to python</span>"
    ]
  },
  {
    "objectID": "Introduction.html#코드에-메모-남기기-주석-comment",
    "href": "Introduction.html#코드에-메모-남기기-주석-comment",
    "title": "1  week1. Introduction to python",
    "section": "2.4 코드에 메모 남기기: 주석 (Comment)",
    "text": "2.4 코드에 메모 남기기: 주석 (Comment)\n코드를 작성하다 보면, 이 코드가 어떤 기능을 하는지, 왜 이렇게 작성했는지 나중에 다시 보거나 다른 사람에게 설명해야 할 때가 있습니다. 이때 코드에 주석(Comment) 을 달아두면 매우 유용합니다.\n파이썬에서 주석은 # 기호로 시작합니다. # 기호 뒤에 오는 내용은 그 줄 끝까지 파이썬 실행기가 무시합니다. 즉, 프로그램 실행에 아무런 영향을 주지 않고 오직 사람만 볼 수 있는 메모입니다.\n예제 1: 코드 설명 주석\n\n# 아래 코드는 환영 메시지를 출력합니다. (이 줄은 주석입니다)\nprint(\"Welcome to Python for Economics!\")\n\nWelcome to Python for Economics!\n\n\n예제 2: 코드 옆 주석\n코드와 같은 줄에 설명을 짧게 추가할 수도 있습니다.\n\nprint(365 * 24) # 1년은 몇 시간인지 계산\n\n8760\n\n\n예제 3: 코드 실행 잠시 막기 (주석 처리)\n특정 코드 라인을 실행하고 싶지 않을 때, 그 줄 맨 앞에 #을 붙여 주석으로 만들면 해당 코드는 실행되지 않습니다. 디버깅할 때 유용하게 쓰입니다.\n\nprint(\"이 메시지는 보입니다.\")\n# print(\"이 메시지는 주석 처리되어 보이지 않습니다.\")\nprint(\"이 메시지도 보입니다.\")\n\n이 메시지는 보입니다.\n이 메시지도 보입니다.\n\n\n\n[실습 2] 주석 사용 연습\n\n아래 코드 셀에 print(\"오늘 날짜:\", \"2025년 4월 17일\") 코드를 작성하고, 그 코드 윗줄에 #를 이용하여 “오늘 날짜를 출력하는 코드” 라는 주석을 추가하세요.\n새로운 코드 셀에 print(12 * 30) 코드를 작성하고, 같은 줄 코드 뒤에 #를 이용하여 “1년은 약 몇 개월인지 계산” 이라는 주석을 추가하세요.\n\n\n\n# 실습",
    "crumbs": [
      "Curriculum",
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>week1. Introduction to python</span>"
    ]
  },
  {
    "objectID": "Introduction.html#파이썬-계산기-기본-산술-연산",
    "href": "Introduction.html#파이썬-계산기-기본-산술-연산",
    "title": "1  week1. Introduction to python",
    "section": "2.5 파이썬 계산기: 기본 산술 연산",
    "text": "2.5 파이썬 계산기: 기본 산술 연산\n파이썬은 기본적인 사칙연산부터 거듭제곱까지 다양한 수학 계산을 할 수 있습니다. 주요 산술 연산자는 다음과 같습니다.\n\n+ : 덧셈\n- : 뺄셈\n* : 곱셈 (별표 * 사용)\n/ : 나눗셈 (결과는 소수점을 포함하는 실수(float) 형태)\n** : 거듭제곱 (예: 2 ** 3 은 \\(2^3 = 8\\))\n// : 정수 나눗셈 (나눗셈 결과의 몫만 구함)\n% : 나머지 (나눗셈 결과의 나머지만 구함)\n() : 괄호 (연산 순서 지정, 괄호 안을 가장 먼저 계산 - PEMDAS/BODMAS 원칙)\n\n예제 1: 사칙연산\n\nprint(\"10 + 5 =\", 10 + 5)\nprint(\"10 - 5 =\", 10 - 5)\nprint(\"10 * 5 =\", 10 * 5)\nprint(\"10 / 5 =\", 10 / 5)\n\n10 + 5 = 15\n10 - 5 = 5\n10 * 5 = 50\n10 / 5 = 2.0\n\n\n예제 2: 거듭제곱, 정수 나눗셈, 나머지\n\nprint(\"2의 5제곱 =\", 2 ** 5) # 2*2*2*2*2\nprint(\"17 나누기 5의 몫 =\", 17 // 5) # 17 = 5*3 + 2 에서 몫은 3\nprint(\"17 나누기 5의 나머지 =\", 17 % 5) # 17 = 5*3 + 2 에서 나머지는 2\n\n2의 5제곱 = 32\n17 나누기 5의 몫 = 3\n17 나누기 5의 나머지 = 2\n\n\n예제 3: 연산 순서와 괄호\n파이썬은 수학에서와 같이 곱셈/나눗셈을 덧셈/뺄셈보다 먼저 계산합니다. 괄호를 사용하면 연산 순서를 바꿀 수 있습니다.\n\nprint(\"2 + 3 * 4 =\", 2 + 3 * 4) # 곱셈 먼저: 2 + 12 = 14\nprint(\"(2 + 3) * 4 =\", (2 + 3) * 4) # 괄호 먼저: 5 * 4 = 20\n\n2 + 3 * 4 = 14\n(2 + 3) * 4 = 20\n\n\n예제 4: 실수 연산\n소수점이 있는 실수(float)끼리도 당연히 연산이 가능합니다.\n\nprint(\"3.14 * 2 =\", 3.14 * 2)\nprint(\"10.5 / 2.5 =\", 10.5 / 2.5)\n\n3.14 * 2 = 6.28\n10.5 / 2.5 = 4.2\n\n\n주의: 0으로 나누는 것은 수학적으로 정의되지 않으므로, 파이썬에서도 0으로 나누려고 하면 오류(ZeroDivisionError)가 발생합니다.\n\n# print(10 / 0) # 이 코드는 ZeroDivisionError를 발생시킵니다.\n\n\n[실습 3] 산술 연산 연습\n아래 요구사항에 맞춰 계산을 수행하고 결과를 print() 함수로 출력하는 코드를 각각의 코드 셀에 작성해보세요.\n\n숫자 1234와 5678을 더한 결과를 출력하세요.\n숫자 50에서 15를 뺀 결과를 출력하세요.\n숫자 10의 3제곱 (\\(10^3\\))을 계산하여 출력하세요.\n숫자 25를 4로 나누었을 때의 몫과 나머지를 각각 계산하여 출력하세요. (힌트: // 와 % 연산자 사용)\n(100 + 200) / 5 를 계산하여 출력하세요. 괄호의 역할에 주목하세요.\n\n\n\n# 실습 3",
    "crumbs": [
      "Curriculum",
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>week1. Introduction to python</span>"
    ]
  },
  {
    "objectID": "Introduction.html#경제학-맛보기-간단한-경제-계산",
    "href": "Introduction.html#경제학-맛보기-간단한-경제-계산",
    "title": "1  week1. Introduction to python",
    "section": "2.6 경제학 맛보기: 간단한 경제 계산",
    "text": "2.6 경제학 맛보기: 간단한 경제 계산\n이제 오늘 배운 print와 산술 연산을 활용하여 첫 시간에 잠시 언급했던 간단한 경제 계산을 다시 해봅시다.\n시나리오:\n\n티셔츠 가격(Price) = 15,000원\n판매량(Quantity) = 50장\n고정 비용(Fixed Cost) = 500,000원\n단위당 가변 비용(Variable Cost per Unit) = 5,000원\n\n계산 목표:\n\n총수입 (Total Revenue, TR) = 가격 × 판매량\n총가변비용 (Total Variable Cost, TVC) = 단위당 가변 비용 × 판매량\n총비용 (Total Cost, TC) = 고정 비용 + 총가변비용\n이익 (Profit) = 총수입 - 총비용\n\n파이썬 코드로 계산하기:\n계산 과정을 명확히 하기 위해, 각 단계의 결과를 출력해 보겠습니다.\n\n# 1. 총수입(TR) 계산 및 출력\nprint(\"--- 총수입 계산 ---\")\nprint(\"가격:\", 15000)\nprint(\"판매량:\", 50)\nprint(\"총수입(TR):\", 15000 * 50)\n\n# 2. 총가변비용(TVC) 계산 및 출력\nprint(\"\\n--- 총가변비용 계산 ---\") # \\n 은 줄바꿈 문자입니다.\nprint(\"단위당 가변 비용:\", 5000)\nprint(\"판매량:\", 50)\nprint(\"총가변비용(TVC):\", 5000 * 50)\n\n# 3. 총비용(TC) 계산 및 출력\nprint(\"\\n--- 총비용 계산 ---\")\nprint(\"고정 비용:\", 500000)\n# 위에서 계산한 총가변비용 값을 직접 사용 (지금은 숫자를 다시 쓰지만, 다음 주 변수를 배우면 더 편해집니다)\nprint(\"총비용(TC):\", 500000 + (5000 * 50))\n\n# 4. 이익(Profit) 계산 및 출력\nprint(\"\\n--- 이익 계산 ---\")\n# 위에서 계산한 총수입과 총비용 값을 직접 사용\nprint(\"이익(Profit):\", (15000 * 50) - (500000 + (5000 * 50)))\n\nprint(\"\\n--- 최종 요약 ---\")\nprint(\"총수입:\", 15000 * 50)\nprint(\"총비용:\", 500000 + (5000 * 50))\nprint(\"이 익:\", (15000 * 50) - (500000 + (5000 * 50)))\n\n--- 총수입 계산 ---\n가격: 15000\n판매량: 50\n총수입(TR): 750000\n\n--- 총가변비용 계산 ---\n단위당 가변 비용: 5000\n판매량: 50\n총가변비용(TVC): 250000\n\n--- 총비용 계산 ---\n고정 비용: 500000\n총비용(TC): 750000\n\n--- 이익 계산 ---\n이익(Profit): 0\n\n--- 최종 요약 ---\n총수입: 750000\n총비용: 750000\n이 익: 0\n\n\n이번 예제에서는 계산 과정의 명확성을 위해 각 단계의 결과를 출력했습니다. 하지만 여전히 가격(15000)이나 수량(50) 같은 값들이 여러 번 반복해서 사용되고 있죠? 다음 주에 배울 변수를 사용하면 이런 반복을 줄이고 코드를 훨씬 효율적으로 만들 수 있습니다.",
    "crumbs": [
      "Curriculum",
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>week1. Introduction to python</span>"
    ]
  },
  {
    "objectID": "Introduction.html#마무리-및-다음-시간-예고",
    "href": "Introduction.html#마무리-및-다음-시간-예고",
    "title": "1  week1. Introduction to python",
    "section": "2.7 7. 마무리 및 다음 시간 예고",
    "text": "2.7 7. 마무리 및 다음 시간 예고\n오늘 첫 수업, 다들 수고 많으셨습니다! 오늘은 파이썬이 왜 경제학 분석에 유용한 도구인지 알아보고, 우리의 작업 공간이 될 Google Colab 사용법을 익혔습니다. 그리고 파이썬의 가장 기본적인 출력 명령어인 print와 코드 설명을 위한 주석 사용법, 마지막으로 파이썬의 강력한 계산 기능을 직접 실습해 보았습니다.\n다음 시간에는:\n오늘 마지막 예제에서 느꼈던 불편함, 즉 반복되는 값들을 효율적으로 관리하는 방법인 변수(Variables) 에 대해 자세히 배울 것입니다. 또한, 파이썬이 다루는 여러 종류의 데이터(숫자, 문자열 등)인 자료형(Data Types) 과 사용자로부터 직접 입력을 받는 input() 함수에 대해서도 알아볼 예정입니다.",
    "crumbs": [
      "Curriculum",
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>week1. Introduction to python</span>"
    ]
  },
  {
    "objectID": "Introduction.html#첫-주차-과제",
    "href": "Introduction.html#첫-주차-과제",
    "title": "1  week1. Introduction to python",
    "section": "2.8 첫 주차 과제",
    "text": "2.8 첫 주차 과제\n오늘 배운 내용을 복습하고 다음 수업을 준비하기 위해 아래 과제를 Colab에서 새 노트(Week1_Assignment.ipynb 등)에 풀어보세요.\n\nprint() 연습:\n\nprint() 함수를 여러 번 사용하여 다음과 같이 본인 소개를 여러 줄로 출력해보세요. 이름: [본인 이름]     학과: 경제학과     학번: [본인 학번]\n\n산술 연산 연습:\n\n어떤 물건의 가격이 50,000원이고, 10% 할인 쿠폰이 있다고 할 때, 할인 금액과 최종 가격을 계산하여 각각 출력하세요. (힌트: 할인 금액 = 원래 가격 * 0.1, 최종 가격 = 원래 가격 - 할인 금액)\n섭씨 온도(Celsius)를 화씨 온도(Fahrenheit)로 변환하는 공식은 \\(F = (C \\times 9/5) + 32\\) 입니다. 섭씨 25도를 화씨로 변환하여 결과를 출력하세요.\n\n주석 연습:\n\n위 2번 문제의 각 계산 코드 윗줄에 어떤 계산인지 설명하는 주석을 추가하세요.",
    "crumbs": [
      "Curriculum",
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>week1. Introduction to python</span>"
    ]
  },
  {
    "objectID": "week2.html",
    "href": "week2.html",
    "title": "2  week2. Variables",
    "section": "",
    "text": "3 제 2주차: 데이터에 이름표를 붙여주자! (변수와 기본 자료형)\n강의 개요:\n지난주에는 파이썬의 기본 계산 기능과 Colab 환경에 익숙해지는 시간을 가졌습니다. 하지만 실제 데이터를 다루려면 숫자나 글자들을 단순히 계산하는 것 이상이 필요합니다. 오늘은 데이터를 효율적으로 저장하고 관리하는 핵심 개념인 변수(Variable) 와 데이터의 종류를 나타내는 자료형(Data Type) 에 대해 깊이 알아볼 것입니다. 또한, 사용자로부터 직접 정보를 입력받는 방법과 데이터의 종류를 필요에 따라 바꾸는 형 변환에 대해서도 배우고 실습합니다. 이 개념들은 앞으로 우리가 경제 및 회계 데이터를 다루는 데 있어 가장 기초적이면서도 중요한 토대가 됩니다.\n이번 시간 학습 목표:",
    "crumbs": [
      "Curriculum",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>week2. Variables</span>"
    ]
  },
  {
    "objectID": "week2.html#왜-변수가-필요할까요-데이터-관리의-시작",
    "href": "week2.html#왜-변수가-필요할까요-데이터-관리의-시작",
    "title": "2  week2. Variables",
    "section": "3.1 1. 왜 ’변수’가 필요할까요? : 데이터 관리의 시작",
    "text": "3.1 1. 왜 ’변수’가 필요할까요? : 데이터 관리의 시작\n지난주 마지막 예제에서 티셔츠 가격(15000), 판매량(50) 등의 숫자를 코드에 직접 사용했었죠. 만약 이 티셔츠 가게의 분기별 매출 보고서를 작성한다고 상상해 봅시다. 1분기 매출액, 2분기 매출액, 영업 비용, 순이익… 이런 값들을 매번 숫자로 직접 입력한다면 어떨까요?\n\n실수 가능성: 숫자를 잘못 입력할 가능성이 커집니다. (예: ’15000’을 ’1500’으로 입력)\n수정의 어려움: 만약 특정 분기의 매출액이 수정되어야 한다면, 코드 전체에서 해당 숫자를 찾아 모두 바꿔야 합니다.\n가독성 저하: 15000 * 50 같은 코드만 봐서는 이 숫자들이 무엇을 의미하는지 바로 알기 어렵습니다.\n\n변수(Variable) 는 이러한 문제를 해결해 줍니다. 변수는 특정 값을 저장하는 메모리 공간에 붙이는 이름표입니다. 예를 들어, 한국의 2024년 GDP 추정치 약 2,200조 원이라는 값을 gdp_korea_2024 라는 이름표(변수명)를 붙여 저장해 둘 수 있습니다.\n\n# 예시 (아직 실행하지 마세요. 개념 설명입니다)\ngdp_korea_2024 = 2200.0 # 단위: 조 원 (실수)\npopulation_korea_2024 = 51700000 # 단위: 명 (정수)\n\n이렇게 변수를 사용하면 다음과 같은 장점이 있습니다.\n\n의미 명확화: gdp_korea_2024 라는 이름만 봐도 ’한국의 2024년 GDP 값’이라는 것을 알 수 있습니다. (가독성 향상)\n값 재사용: 이 값을 여러 계산(예: 1인당 GDP 계산)에 쉽게 반복 사용할 수 있습니다. (재사용성 증가)\n쉬운 수정: 만약 GDP 추정치가 2,250조 원으로 변경되면, gdp_korea_2024 = 2250.0 딱 한 줄만 수정하면 이 변수를 사용한 모든 계산 결과가 자동으로 업데이트됩니다. (유지보수 용이)",
    "crumbs": [
      "Curriculum",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>week2. Variables</span>"
    ]
  },
  {
    "objectID": "week2.html#변수-만들고-사용하기-이름표-붙이고-값-담기",
    "href": "week2.html#변수-만들고-사용하기-이름표-붙이고-값-담기",
    "title": "2  week2. Variables",
    "section": "3.2 2. 변수 만들고 사용하기 : 이름표 붙이고 값 담기",
    "text": "3.2 2. 변수 만들고 사용하기 : 이름표 붙이고 값 담기\n파이썬에서 변수를 만드는 방법은 아주 간단합니다. 할당 연산자 (=) 를 사용해서 변수 이름에 값을 저장(할당)하면 됩니다.\n변수이름 = 값\n주의: =는 “같다”는 의미가 아니라, “오른쪽의 값을 왼쪽의 변수 이름에 할당(저장)하라” 는 명령입니다!\n예제 1: 국가별 정보 변수에 저장하고 출력하기\n\n# 국가 정보 변수에 할당\ncountry_name_kr = \"대한민국\"\npopulation_kr = 51700000  # 2024년 추정치 (정수)\ngdp_kr_trillion_krw = 2200.0 # 2024년 추정치 (조 원, 실수)\n\ncountry_name_us = \"미국\"\npopulation_us = 335000000 # 2024년 추정치 (정수)\ngdp_us_trillion_usd = 27.0 # 2024년 추정치 (조 달러, 실수)\n\n# 변수에 저장된 값 출력\nprint(\"국가명:\", country_name_kr)\nprint(\"인구수:\", population_kr, \"명\")\nprint(f\"GDP: {gdp_kr_trillion_krw} 조 원\") # f-string 사용 예시\n\nprint(\"\\n--- 다른 국가 정보 ---\") # \\n은 줄바꿈\nprint(\"국가명:\", country_name_us)\nprint(\"인구수:\", population_us, \"명\")\nprint(f\"GDP: {gdp_us_trillion_usd} 조 달러\")\n\n국가명: 대한민국\n인구수: 51700000 명\nGDP: 2200.0 조 원\n\n--- 다른 국가 정보 ---\n국가명: 미국\n인구수: 335000000 명\nGDP: 27.0 조 달러\n\n\n예제 2: 회계 정보 변수에 저장하기\n\n# 가상 기업 'ABC전자'의 2024년 실적\ncompany_name = \"ABC전자\"\nrevenue_2024 = 150000000000 # 매출액 (원)\noperating_cost_2024 = 120000000000 # 영업 비용 (원)\nnet_income_2024 = revenue_2024 - operating_cost_2024 # 순이익 계산\n\nprint(\"회사명:\", company_name)\nprint(\"2024년 매출액:\", revenue_2024, \"원\")\nprint(\"2024년 영업비용:\", operating_cost_2024, \"원\")\nprint(\"2024년 순이익:\", net_income_2024, \"원\")\n\n회사명: ABC전자\n2024년 매출액: 150000000000 원\n2024년 영업비용: 120000000000 원\n2024년 순이익: 30000000000 원\n\n\n예제 3: 변수 값 변경 (재할당)\n변수에는 다른 값을 다시 할당할 수 있습니다. 변수는 이름표일 뿐이고, 그 안에 담긴 내용물(값)은 바뀔 수 있습니다.\n\n# 환율 정보 (2025년 4월 17일 가상 환율)\nexchange_rate_usd_krw = 1350.5 # 1달러당 원화\n\nprint(\"현재 달러 환율:\", exchange_rate_usd_krw)\n\n# 환율이 변경되었다고 가정\nexchange_rate_usd_krw = 1360.0 # 새로운 값 할당\n\nprint(\"변경된 달러 환율:\", exchange_rate_usd_krw)\n\n현재 달러 환율: 1350.5\n변경된 달러 환율: 1360.0\n\n\n변수 이름 규칙 (복습 및 추가)\n\n영문자 또는 밑줄(_)로 시작 (gdp_2024 O, 2024_gdp X)\n영문자, 숫자, 밑줄(_)만 사용 가능 (net_income O, net-income X)\n대소문자 구분 (gdp 와 GDP 는 다른 변수)\n파이썬 예약어 사용 불가 (if, else, class, import 등)\n[권장] 의미를 명확히 알 수 있는 이름 사용 (population_china &gt; pop_cn &gt; pc)\n[권장] 소문자와 밑줄 조합(스네이크 케이스) 사용 (per_capita_gdp)",
    "crumbs": [
      "Curriculum",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>week2. Variables</span>"
    ]
  },
  {
    "objectID": "week2.html#데이터의-종류-기본-자료형-data-types",
    "href": "week2.html#데이터의-종류-기본-자료형-data-types",
    "title": "2  week2. Variables",
    "section": "3.3 3. 데이터의 종류: 기본 자료형 (Data Types)",
    "text": "3.3 3. 데이터의 종류: 기본 자료형 (Data Types)\n변수에는 다양한 종류의 데이터를 담을 수 있습니다. 파이썬은 이 데이터의 종류, 즉 자료형(Data Type) 을 중요하게 생각합니다. 왜냐하면 데이터의 종류에 따라 할 수 있는 연산이나 기능이 다르기 때문이죠. 예를 들어, 숫자(GDP, 인구)는 더하거나 뺄 수 있지만, 글자(국가 이름)를 더하는 것은 의미가 다릅니다.\n파이썬의 기본적인 자료형들을 경제/회계 예시와 함께 살펴봅시다.\n1. int (Integer: 정수)\n\n소수점 없는 숫자를 나타냅니다.\n예시: 인구수, 상품 개수, 연도, 회계 계정 코드 등\n코드 예:\n\n\nyear = 2025\npopulation_seoul = 9400000 # 서울시 인구 (약 940만 명)\nnum_companies = 350\n\nprint(\"연도:\", year, type(year))\nprint(\"서울시 인구:\", population_seoul, type(population_seoul))\nprint(\"분석 대상 기업 수:\", num_companies, type(num_companies))\n\n연도: 2025 &lt;class 'int'&gt;\n서울시 인구: 9400000 &lt;class 'int'&gt;\n분석 대상 기업 수: 350 &lt;class 'int'&gt;\n\n\n2. float (Floating-point: 실수)\n\n소수점이 있는 숫자를 나타냅니다. 매우 큰 수나 작은 수를 표현할 때 지수 형태(예: 2.5e-4)를 사용하기도 합니다.\n예시: GDP, 주가, 이자율, 환율, 물가 상승률, 재무 비율 (예: 부채 비율) 등\n코드 예:\n\n\n\ngdp_china_trillion_usd = 19.0 # 중국 GDP (약 19조 달러)\ninterest_rate = 0.035       # 기준 금리 3.5%\nusd_krw_rate = 1355.75      # 달러/원 환율\ndebt_to_equity_ratio = 1.2  # 부채 비율 120%\n\nprint(\"중국 GDP:\", gdp_china_trillion_usd, \"조 달러\", type(gdp_china_trillion_usd))\nprint(\"기준 금리:\", interest_rate, type(interest_rate))\nprint(\"달러/원 환율:\", usd_krw_rate, type(usd_krw_rate))\nprint(\"부채 비율:\", debt_to_equity_ratio, type(debt_to_equity_ratio))\n\n중국 GDP: 19.0 조 달러 &lt;class 'float'&gt;\n기준 금리: 0.035 &lt;class 'float'&gt;\n달러/원 환율: 1355.75 &lt;class 'float'&gt;\n부채 비율: 1.2 &lt;class 'float'&gt;\n\n\n3. str (String: 문자열)\n\n글자들의 나열을 나타냅니다. 작은따옴표(') 또는 큰따옴표(\")로 감싸서 표현합니다.\n예시: 국가 이름, 도시 이름, 회사 이름, 보고서 제목, 날짜(텍스트 형태), 통화 단위(KRW, USD) 등\n코드 예:\n\n\ncountry = \"Germany\"\ncurrency = 'EUR'\nreport_title = \"2024년 4분기 경제 동향 보고서\"\ndate_str = \"2025-04-17\"\n\nprint(\"국가:\", country, type(country))\nprint(\"통화:\", currency, type(currency))\nprint(\"보고서 제목:\", report_title, type(report_title))\nprint(\"날짜(문자열):\", date_str, type(date_str))\n\n국가: Germany &lt;class 'str'&gt;\n통화: EUR &lt;class 'str'&gt;\n보고서 제목: 2024년 4분기 경제 동향 보고서 &lt;class 'str'&gt;\n날짜(문자열): 2025-04-17 &lt;class 'str'&gt;\n\n\n4. bool (Boolean: 불리언)\n\n‘참’(True) 또는 ‘거짓’(False) 두 가지 상태만을 나타냅니다. 주로 조건의 결과나 특정 상태를 표시할 때 사용됩니다. (주의: 첫 글자는 반드시 대문자!)\n예시: 경제 성장 여부 (is_growth_positive), 흑자 여부 (has_surplus), 특정 조건 만족 여부 등\n코드 예:\n\n\nis_inflation_high = True  # 물가가 높은 상태인가?\nis_recession = False      # 경기 침체 상태인가?\n\nprint(\"고인플레이션 상태:\", is_inflation_high, type(is_inflation_high))\nprint(\"경기 침체 상태:\", is_recession, type(is_recession))\n\n고인플레이션 상태: True &lt;class 'bool'&gt;\n경기 침체 상태: False &lt;class 'bool'&gt;\n\n\ntype() 함수 활용\n변수에 어떤 종류의 데이터가 들어있는지 확인하려면 type(변수명) 처럼 type() 함수를 사용하면 됩니다. 위 예제들에서 type() 함수의 결과를 함께 출력했습니다.\n\n\n[실습 1] 변수와 자료형 연습\n아래 경제/회계 관련 데이터를 변수에 저장하고, 각 변수의 값과 자료형을 print(), type() 함수를 사용하여 출력하는 코드를 작성하세요.\n\n일본(Japan)의 2024년 추정 GDP (약 4.5조 달러)를 gdp_japan_trillion_usd 변수에 저장하세요. (자료형: float)\n독일(Germany)의 2024년 추정 인구 (약 8,400만 명)를 population_germany 변수에 저장하세요. (자료형: int)\n유로화의 통화 코드(‘EUR’)를 currency_code_eur 변수에 저장하세요. (자료형: str)\n한국이 OECD 회원국인지 여부 (참)를 is_korea_oecd_member 변수에 저장하세요. (자료형: bool)\n\n\n\n# 실습코드 작성",
    "crumbs": [
      "Curriculum",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>week2. Variables</span>"
    ]
  },
  {
    "objectID": "week2.html#자료형-바꾸기-형-변환-type-conversion",
    "href": "week2.html#자료형-바꾸기-형-변환-type-conversion",
    "title": "2  week2. Variables",
    "section": "3.4 4. 자료형 바꾸기: 형 변환 (Type Conversion)",
    "text": "3.4 4. 자료형 바꾸기: 형 변환 (Type Conversion)\n데이터를 다루다 보면, 때때로 자료형을 바꿔야 할 필요가 생깁니다. 예를 들어, 웹사이트에서 가져온 GDP 데이터가 \"2200.0조\" 같은 문자열 형태일 수 있습니다. 이걸 계산에 사용하려면 숫자(실수) 형태로 바꿔야겠죠? 또는 사용자로부터 나이를 입력받으면 문자열로 들어오는데, 이를 가지고 출생 연도를 계산하려면 정수로 바꿔야 합니다. 이렇게 데이터의 형태(자료형)를 바꾸는 것을 형 변환(Type Conversion) 또는 캐스팅(Casting) 이라고 부릅니다.\n주요 형 변환 함수:\n\nint(값): 주어진 값을 정수(int) 로 변환합니다.\n\n실수를 정수로 바꾸면 소수점 이하는 버려집니다. (예: int(3.14) 는 3)\n숫자 형태의 문자열을 정수로 바꿀 수 있습니다. (예: int(\"100\") 는 100)\n\nfloat(값): 주어진 값을 실수(float) 로 변환합니다.\n\n정수나 숫자 형태의 문자열을 실수로 바꿀 수 있습니다. (예: float(100) 는 100.0, float(\"3.14\") 는 3.14)\n\nstr(값): 주어진 값을 문자열(str) 로 변환합니다.\n\n숫자나 불리언 값을 글자 형태로 바꿀 때 사용합니다. (예: str(100) 는 \"100\", str(True) 는 \"True\")\n\n\n형 변환 예제:\n예제 1: 문자열을 숫자로 변환하여 계산하기\n\ngdp_str = \"2200.0\" # GDP 데이터가 문자열로 저장된 경우 (단위: 조 원)\npopulation_str = \"51700000\" # 인구 데이터가 문자열로 저장된 경우\n\n# per_capita_gdp = gdp_str / population_str # 에러 발생! 문자열끼리는 나눗셈 불가\n\n# 계산을 위해 형 변환\ngdp_float = float(gdp_str)       # 문자열 \"2200.0\"을 실수 2200.0으로 변환\npopulation_int = int(population_str) # 문자열 \"51700000\"을 정수 51700000으로 변환\n\n# 1인당 GDP 계산 (단위: 조 원 / 명) -&gt; 원 단위로 바꾸려면 * 1조 / 명\n# 여기서는 조 원 / 명 단위로 계산\nper_capita_gdp = gdp_float / population_int\n\nprint(\"문자열 GDP:\", gdp_str, type(gdp_str))\nprint(\"실수 GDP:\", gdp_float, type(gdp_float))\nprint(\"문자열 인구:\", population_str, type(population_str))\nprint(\"정수 인구:\", population_int, type(population_int))\nprint(\"1인당 GDP (조 원/명):\", per_capita_gdp)\n\n# 원 단위로 1인당 GDP 출력 (약 4255만원)\nper_capita_gdp_krw = (gdp_float * 1000000000000) / population_int\nprint(f\"1인당 GDP (원): {per_capita_gdp_krw:.0f} 원\") # 소수점 아래 버리고 출력\n\n문자열 GDP: 2200.0 &lt;class 'str'&gt;\n실수 GDP: 2200.0 &lt;class 'float'&gt;\n문자열 인구: 51700000 &lt;class 'str'&gt;\n정수 인구: 51700000 &lt;class 'int'&gt;\n1인당 GDP (조 원/명): 4.2553191489361704e-05\n1인당 GDP (원): 42553191 원\n\n\n예제 2: 숫자를 문자열로 변환하여 문장 만들기\n숫자를 설명하는 글자와 함께 출력하고 싶을 때, str() 함수로 숫자를 문자열로 바꿔서 + 연산자로 연결할 수 있습니다. (하지만 f-string을 쓰는 것이 더 편리합니다!)\n\nunemployment_rate = 3.1 # 실업률 (퍼센트)\n\n# 에러 발생: print(\"실업률: \" + unemployment_rate + \"%\")\n\n# str() 사용하여 형 변환 후 연결\nreport_sentence = \"2024년 한국 실업률은 \" + str(unemployment_rate) + \"%로 집계되었습니다.\"\nprint(report_sentence)\n\n# f-string 사용 (권장)\nreport_sentence_f = f\"2024년 한국 실업률은 {unemployment_rate}%로 집계되었습니다.\"\nprint(report_sentence_f)\n\n2024년 한국 실업률은 3.1%로 집계되었습니다.\n2024년 한국 실업률은 3.1%로 집계되었습니다.\n\n\n예제 3: 실수(float)를 정수(int)로 변환 (소수점 버림 확인)\n\naverage_score = 85.7\nfinal_score = int(average_score) # 소수점 이하 버림\n\nprint(\"평균 점수 (실수):\", average_score)\nprint(\"최종 부여 점수 (정수):\", final_score)\n\n평균 점수 (실수): 85.7\n최종 부여 점수 (정수): 85",
    "crumbs": [
      "Curriculum",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>week2. Variables</span>"
    ]
  },
  {
    "objectID": "week2.html#sec-visualization-preview",
    "href": "week2.html#sec-visualization-preview",
    "title": "2  week2. Variables",
    "section": "3.5 5. 파이썬의 힘 맛보기: 데이터 시각화 미리보기",
    "text": "3.5 5. 파이썬의 힘 맛보기: 데이터 시각화 미리보기\n자, 지금까지 배운 변수, 자료형, 형 변환만으로는 파이썬 공부가 좀 건조하게 느껴질 수도 있을 것 같습니다. ‘그래서 이걸 배워서 뭘 할 수 있다는 거지?’ 하는 생각이 들 수도 있죠.\n여기서 잠깐! 우리가 이렇게 변수에 저장하고 처리하는 데이터들이 파이썬을 통해 얼마나 의미 있는 시각 정보로 변환될 수 있는지 미리 살짝 맛보는 시간을 가져보겠습니다. 우리가 앞에서 변수에 저장했던 여러 국가들의 GDP 데이터를 간단한 막대 그래프로 비교해 보는 거죠.\n아래 나오는 코드는 지금 당장 완벽하게 이해하지 않아도 괜찮습니다. 특히 import, plt, figure, bar, title, show 같은 부분들은 나중에 우리가 ’데이터 시각화’를 배울 때 자세히 다룰 내용이에요. 지금은 “아하! 우리가 변수에 넣은 데이터(국가 이름, GDP 값)가 이런 멋진 그래프를 만드는 재료가 되는구나!” 그리고 “파이썬 코드가 데이터를 이렇게 보기 좋은 그림으로 바꿔줄 수 있구나!” 라는 가능성을 느껴보는 것이 중요합니다.\n\n# --- 데이터 시각화 맛보기 ---\n# (아직 이 코드를 완벽히 이해할 필요는 없어요! 어떤 결과가 나오는지 보세요)\n\n# 데이터를 시각화하는 강력한 도구 'Matplotlib'을 불러옵니다.\nimport matplotlib.pyplot as plt\nimport platform\n\n# 한글 폰트 설정 (Colab 및 OS 환경에 맞게) - 중요!\n# Colab 환경에서는 아래 코드 실행으로 나눔폰트 설치가 필요할 수 있습니다.\n# !sudo apt-get update -qq\n# !sudo apt-get install -y fonts-nanum* -qq\n\n# 설치 후 진행 (런타임 다시 시작 필요할 수 있음)\ntry:\n    if platform.system() == 'Linux': # Colab 포함 리눅스 환경\n        plt.rc('font', family='NanumBarunGothic')\n    elif platform.system() == 'Windows': # 윈도우 환경\n        plt.rc('font', family='Malgun Gothic')\n    elif platform.system() == 'Darwin': # macOS 환경\n        plt.rc('font', family='AppleGothic')\nexcept FileNotFoundError:\n    print(\"한글 폰트를 찾을 수 없습니다. 영문으로 표시되거나 글자가 깨질 수 있습니다.\")\n    # 필요한 경우, 사용 가능한 다른 폰트 이름을 직접 지정해주세요.\n\nplt.rcParams['axes.unicode_minus'] = False # 마이너스 기호 깨짐 방지\n\n# --- 비교할 데이터 준비 ---\n# (앞에서 배운 변수를 사용하거나, 여기서 직접 값을 지정할 수 있습니다)\n# 예시: 몇 개 국가의 2024년 추정 GDP (단위: 조 USD)\ncountries = ['대한민국', '미국', '중국', '일본', '독일']\n# 앞에서 정의한 변수를 활용할 수도 있지만, 여기서는 간단히 값을 직접 입력\n# gdp_values_usd = [gdp_kr_trillion_krw / 1.35, gdp_us_trillion_usd, ...] # 단위 변환 필요시 복잡\ngdp_values_usd = [1.8, 27.0, 19.0, 4.5, 4.2] # 추정치 (단위: 조 USD)\n\n# --- 막대 그래프 그리기 ---\nplt.figure(figsize=(10, 6)) # 그래프 크기 지정 (선택 사항)\nplt.bar(countries, gdp_values_usd, color=['skyblue', 'red', 'orange', 'green', 'purple']) # 막대 그래프 생성\n\n# 그래프 제목 및 축 레이블 추가 (한글!)\nplt.title('주요 국가별 2024년 추정 GDP 비교', fontsize=15)\nplt.ylabel('GDP (단위: 조 USD)', fontsize=12)\nplt.xlabel('국가', fontsize=12)\nplt.xticks(fontsize=11) # x축 국가 이름 폰트 크기 조절 (선택 사항)\nplt.yticks(fontsize=11) # y축 값 폰트 크기 조절 (선택 사항)\n\n# 그래프 보여주기\nplt.show()\n\n\n\n\n\n\n\n\n어떤가요? 위 코드를 실행하면 주요 국가들의 GDP를 한눈에 비교할 수 있는 막대 그래프가 나타날 겁니다. 어떤 국가의 경제 규모가 가장 크고, 어떤 국가들이 비슷한 수준인지 숫자만 볼 때보다 훨씬 빠르고 명확하게 파악할 수 있죠?\n이것이 바로 데이터 시각화의 힘입니다! 우리가 지금 배우는 변수에 데이터를 담는 방법, 그리고 앞으로 배울 데이터 처리 및 시각화 라이브러리(Matplotlib 등)를 활용하면, 이렇게 복잡한 데이터를 이해하기 쉬운 그림으로 바꾸고 그 안에서 의미 있는 인사이트(통찰) 를 얻을 수 있습니다.\n예를 들어, 여러 국가의 시간에 따른 1인당 GDP 변화를 선 그래프로 그려 추세를 비교하거나, 소득과 소비의 관계를 점으로 찍어(산점도) 그 패턴을 분석하는 등 무궁무진한 분석이 가능해집니다.\n오늘 배운 변수와 자료형이 바로 이런 멋진 분석과 시각화의 가장 기본적인 출발점이라는 것을 기억하면서, 즐겁게 다음 단계로 나아가 봅시다!",
    "crumbs": [
      "Curriculum",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>week2. Variables</span>"
    ]
  },
  {
    "objectID": "week2.html#경제회계-응용-변수를-활용한-이익-계산",
    "href": "week2.html#경제회계-응용-변수를-활용한-이익-계산",
    "title": "2  week2. Variables",
    "section": "3.6 6. 경제/회계 응용: 변수를 활용한 이익 계산",
    "text": "3.6 6. 경제/회계 응용: 변수를 활용한 이익 계산\n이제 오늘 배운 내용을 모두 활용해서, 지난주에 했던 이익 계산 예제를 훨씬 개선해 봅시다. 모든 값을 변수로 먼저 정의하고, 계산은 변수 이름을 사용하여 수행합니다.\n시나리오 복습:\n\n티셔츠 가격(Price) = 15,000원\n판매량(Quantity) = 50장\n고정 비용(Fixed Cost) = 500,000원\n단위당 가변 비용(Variable Cost per Unit) = 5,000원\n\n변수를 사용한 계산:\n\n# --- 입력 정보 (변수로 정의) ---\nprice = 15000\nquantity = 50\nfixed_cost = 500000\nvariable_cost_per_unit = 5000\n\n# --- 계산 과정 (변수 사용) ---\n# 1. 총수입 (TR)\ntotal_revenue = price * quantity\n\n# 2. 총가변비용 (TVC)\ntotal_variable_cost = variable_cost_per_unit * quantity\n\n# 3. 총비용 (TC)\ntotal_cost = fixed_cost + total_variable_cost\n\n# 4. 이익 (Profit)\nprofit = total_revenue - total_cost\n\n# 5. 이익률 (Profit Margin) 계산 (추가)\n# 0으로 나누는 경우를 방지하기 위해 총수입이 0보다 클 때만 계산 (간단한 예방)\nif total_revenue &gt; 0:\n    profit_margin = (profit / total_revenue) * 100\nelse:\n    profit_margin = 0 # 매출이 없으면 이익률도 0\n\n# --- 결과 출력 ---\nprint(f\"--- 티셔츠 판매 분석 ({quantity}개 판매 기준) ---\")\nprint(f\"총수입 (TR): {total_revenue} 원\")\nprint(f\"총비용 (TC): {total_cost} 원 (고정:{fixed_cost}, 가변:{total_variable_cost})\")\nprint(f\"이익 (Profit): {profit} 원\")\nprint(f\"이익률 (Profit Margin): {profit_margin:.2f}%\") # 소수점 2자리까지 출력\n\n# --- 만약 가격이 16000원으로 변경된다면? ---\nprint(\"\\n--- 가격 변경 시뮬레이션 (가격을 16000원으로 변경) ---\")\nprice = 16000 # 이 변수 값만 수정!\n\n# 계산 다시 수행 (동일한 코드 재사용 가능)\ntotal_revenue = price * quantity\ntotal_variable_cost = variable_cost_per_unit * quantity\ntotal_cost = fixed_cost + total_variable_cost\nprofit = total_revenue - total_cost\nif total_revenue &gt; 0:\n    profit_margin = (profit / total_revenue) * 100\nelse:\n    profit_margin = 0\n\n# 변경된 결과 출력\nprint(f\"변경된 총수입 (TR): {total_revenue} 원\")\nprint(f\"변경된 이익 (Profit): {profit} 원\")\nprint(f\"변경된 이익률 (Profit Margin): {profit_margin:.2f}%\")\n\n--- 티셔츠 판매 분석 (50개 판매 기준) ---\n총수입 (TR): 750000 원\n총비용 (TC): 750000 원 (고정:500000, 가변:250000)\n이익 (Profit): 0 원\n이익률 (Profit Margin): 0.00%\n\n--- 가격 변경 시뮬레이션 (가격을 16000원으로 변경) ---\n변경된 총수입 (TR): 800000 원\n변경된 이익 (Profit): 50000 원\n변경된 이익률 (Profit Margin): 6.25%\n\n\n변수를 사용하니 어떤 점이 좋아졌나요? 가격(price) 값만 바꾸고 계산 부분을 다시 실행하면 모든 결과가 업데이트됩니다. 훨씬 효율적이죠!",
    "crumbs": [
      "Curriculum",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>week2. Variables</span>"
    ]
  },
  {
    "objectID": "week2.html#마무리-및-다음-시간-예고",
    "href": "week2.html#마무리-및-다음-시간-예고",
    "title": "2  week2. Variables",
    "section": "3.7 7. 마무리 및 다음 시간 예고",
    "text": "3.7 7. 마무리 및 다음 시간 예고\n오늘은 데이터를 다루는 데 있어 가장 기본이 되는 변수와 자료형, 그리고 형 변환과 사용자 입력(input()) 에 대해 배웠습니다. 변수를 이용해 어떻게 데이터를 효율적으로 관리하고 코드의 가독성과 유연성을 높이는지, 그리고 데이터의 종류에 맞게 형 변환을 하는 것이 왜 중요한지, 특히 input() 함수를 사용할 때의 주의점까지 확인했습니다. 다양한 경제/회계 관련 예시를 통해 개념을 익혔기를 바랍니다.\n다음 시간에는:\n이제 우리는 데이터를 변수에 담고 기본적인 처리를 할 수 있게 되었습니다. 다음 주에는 프로그램의 흐름을 제어하는 첫 번째 방법인 조건문(if, elif, else) 을 배웁니다. 조건문을 사용하면 특정 조건이 참인지 거짓인지에 따라 프로그램이 다른 동작을 하도록 만들 수 있습니다. 예를 들어, “GDP 성장률이 3% 이상이면 ’고성장’이라고 출력하고, 아니면 ’저성장’이라고 출력”하는 식의 코드를 작성할 수 있게 될 것입니다. 이를 통해 우리의 파이썬 코드가 훨씬 더 지능적으로 동작하게 될 테니 기대해주세요!",
    "crumbs": [
      "Curriculum",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>week2. Variables</span>"
    ]
  },
  {
    "objectID": "week2.html#두-번째-주차-과제",
    "href": "week2.html#두-번째-주차-과제",
    "title": "2  week2. Variables",
    "section": "3.8 두 번째 주차 과제",
    "text": "3.8 두 번째 주차 과제\n오늘 배운 변수, 자료형, 형 변환, input() 함수를 복습하기 위해 다음 과제를 Colab에서 새 노트(Week2_Assignment.ipynb 등)에 풀어보세요.\n\n국가별 1인당 GDP 계산기:\n\n사용자로부터 국가 이름을 입력받아 country_name 변수에 저장하세요.\n같은 사용자로부터 해당 국가의 총 GDP(예: 조 달러 단위)를 입력받아 total_gdp_str 에 저장 후, 실수(float) 로 변환하여 total_gdp 변수에 저장하세요.\n같은 사용자로부터 해당 국가의 인구 수(예: 만 명 단위)를 입력받아 population_str 에 저장 후, 정수(int) 로 변환하여 population 변수에 저장하세요. (단위 주의: 입력받은 값에 10000을 곱해야 실제 인구수가 됩니다)\n1인당 GDP(달러)를 계산하세요. (계산식: (total_gdp * 1조) / (population * 1만)) 또는 더 간단히 (total_gdp * 1억) / population (조/만 = 억)\nf-string을 이용하여 최종 결과를 “[국가이름]의 1인당 GDP는 약 X 달러입니다.” 형식으로 출력하세요 (X는 계산 결과, 소수점 없이 정수로 표현).\n\n재무 비율 계산 (가상):\n\n어떤 기업의 총 부채(Total Liabilities)가 500억 원이고, 총 자본(Total Equity)이 1000억 원이라고 가정합니다. 이 두 값을 각각 total_liabilities, total_equity 변수에 정수로 저장하세요 (단위: 원).\n부채 비율(Debt-to-Equity Ratio)을 계산하세요. (계산식: 총 부채 / 총 자본)\n계산된 부채 비율을 debt_ratio 변수에 저장하고, 이 값과 변수의 자료형을 함께 출력하세요.\nf-string을 이용하여 “해당 기업의 부채 비율은 Y 입니다.” 형식으로 출력하세요 (Y는 계산 결과).",
    "crumbs": [
      "Curriculum",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>week2. Variables</span>"
    ]
  },
  {
    "objectID": "week3.html",
    "href": "week3.html",
    "title": "3  3주차: 똑똑한 프로그램 만들기 (조건문 If)",
    "section": "",
    "text": "3.1 1. 조건문이란? : 상황에 따른 판단의 필요성\n강의 개요:\n지난주에는 여러 데이터를 묶어서 관리하는 리스트(list)와 딕셔너리(dict)에 대해 배웠습니다. 이를 통해 우리는 여러 국가의 GDP, 분기별 매출액, 포트폴리오 구성 등 다양한 정보를 구조화하여 저장할 수 있게 되었죠.\n하지만 단순히 데이터를 저장하는 것만으로는 부족합니다. 우리는 종종 이 데이터들을 분석하고, 특정 조건에 따라 판단을 내려야 합니다. 예를 들어, ‘이 국가의 경제 성장률이 3% 이상인가?’, ‘저 기업의 부채 비율은 안전한 수준인가?’, ‘포트폴리오에 특정 위험 자산이 포함되어 있는가?’ 와 같은 질문에 답해야 하죠.\n이번 주에는 바로 이러한 조건에 따른 판단을 가능하게 하는 조건문(Conditional Statements), 그중에서도 if, elif, else 구문을 배웁니다. 조건문을 통해 우리는 프로그램이 주어진 상황에 맞춰 다른 경로로 실행되도록 제어할 수 있으며, 이는 데이터를 분석하고 의사결정을 내리는 데 필수적인 기능입니다. 지난주에 배운 리스트와 딕셔너리에 담긴 데이터를 조건문을 이용해 어떻게 분석할 수 있는지 중점적으로 살펴보겠습니다.\n이번 시간 학습 목표:\n우리가 지난주에 만든 리스트나 딕셔너리를 생각해 봅시다.\n# 지난주 예시 데이터 (복습)\ngdp_growth_rates = [0.5, 4.1, 2.6, 1.4, 2.2] # 연도별 성장률 (%)\nfinancial_info = {\n    \"회사명\": \"가나다 기업\",\n    \"매출액(억 원)\": 850,\n    \"영업이익(억 원)\": 120.5,\n    \"당기순이익(억 원)\": 85.8,\n    \"부채비율(%)\": 75.3\n}\n이 데이터들을 가지고 우리는 무엇을 할 수 있을까요?\n이런 질문들에 답하려면 특정 조건을 확인하고, 그 결과가 참(True) 인지 거짓(False) 인지에 따라 다른 행동을 해야 합니다. 이것이 바로 조건문이 필요한 이유입니다. 조건문은 프로그램의 실행 흐름을 분기(Branching) 시켜, 특정 조건이 만족될 때만 특정 코드 블록을 실행하도록 만듭니다.",
    "crumbs": [
      "Curriculum",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>3주차: 똑똑한 프로그램 만들기 (조건문 If)</span>"
    ]
  },
  {
    "objectID": "week3.html#조건문이란-상황에-따른-판단의-필요성",
    "href": "week3.html#조건문이란-상황에-따른-판단의-필요성",
    "title": "3  3주차: 똑똑한 프로그램 만들기 (조건문 If)",
    "section": "",
    "text": "“첫 해(2020년) 성장률은 0보다 컸는가?” (긍정적 성장 여부 판단)\n“이 기업의 영업이익은 100억 원 이상인가?” (수익성 목표 달성 여부 판단)\n“부채비율이 100% 미만인가?” (재무 건전성 판단)",
    "crumbs": [
      "Curriculum",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>3주차: 똑똑한 프로그램 만들기 (조건문 If)</span>"
    ]
  },
  {
    "objectID": "week3.html#첫-번째-분기점-if-문과-비교-연산자",
    "href": "week3.html#첫-번째-분기점-if-문과-비교-연산자",
    "title": "3  3주차: 똑똑한 프로그램 만들기 (조건문 If)",
    "section": "3.2 2. 첫 번째 분기점: if 문과 비교 연산자",
    "text": "3.2 2. 첫 번째 분기점: if 문과 비교 연산자\n가장 기본적인 조건문은 if 문입니다. if 뒤에 오는 조건식이 True일 경우에만, 그 아래 들여쓰기 된 코드 블록이 실행됩니다.\n기본 구조 복습:\n\n# if 조건식:\n    # 조건식이 True일 때 실행될 코드 블록 (★반드시 들여쓰기★)\n    # 예: print(\"조건 만족!\")\n# if 블록 바깥의 코드\n\n조건식 만들기: 비교 연산자\n조건식은 주로 값을 비교하여 True 또는 False의 결과를 얻습니다. 이때 비교 연산자를 사용합니다.\n\n\n\n연산자\n의미\n예시 (a=10, b=5)\n\n\n\n\n==\n같다\na == 10 (True)\n\n\n!=\n다르다\na != b (True)\n\n\n&gt;\n크다\na &gt; b (True)\n\n\n&lt;\n작다\nb &lt; a (True)\n\n\n&gt;=\n크거나 같다\na &gt;= 10 (True)\n\n\n&lt;=\n작거나 같다\nb &lt;= 10 (True)\n\n\n\n주의: 할당 연산자 = 와 비교 연산자 == 를 절대 혼동하지 마세요!\nif 문 예제 (리스트/딕셔너리 활용):\n예제 1: 첫 해 GDP 성장률 확인\n\ngdp_growth_rates = [0.5, 4.1, 2.6, 1.4, 2.2] # 연도별 성장률 (%)\nfirst_year_growth = gdp_growth_rates[0] # 첫 번째 요소 접근 (인덱스 0)\n\nprint(f\"첫 해 성장률: {first_year_growth}%\")\n\nif first_year_growth &gt; 0:\n    print(\"첫 해에 경제가 성장했습니다.\")\n\nif first_year_growth &gt; 3.0:\n    print(\"첫 해 성장률이 3%를 넘었습니다.\") # 이 조건은 False이므로 출력 안됨\n\n첫 해 성장률: 0.5%\n첫 해에 경제가 성장했습니다.\n\n\n예제 2: 특정 기업의 매출액 확인\n\nfinancial_info = {\n    \"회사명\": \"가나다 기업\",\n    \"매출액(억 원)\": 850,\n    \"영업이익(억 원)\": 120.5,\n    \"부채비율(%)\": 75.3\n}\ncompany_revenue = financial_info[\"매출액(억 원)\"] # 딕셔너리 값 접근\n\nprint(f\"{financial_info['회사명']}의 매출액: {company_revenue}억 원\")\n\nif company_revenue &gt;= 1000:\n    print(\"매출액 1000억 원 이상 달성!\") # 조건 False, 출력 안됨\n\nif company_revenue &gt; 0:\n    print(\"매출이 발생했습니다.\") # 조건 True, 출력됨\n\n가나다 기업의 매출액: 850억 원\n매출이 발생했습니다.\n\n\n★ 들여쓰기의 중요성 ★\n파이썬에서 들여쓰기는 코드의 논리적 구조를 나타내는 문법 그 자체입니다. if 다음에 오는 코드 블록은 반드시 일관된 간격(보통 스페이스 4칸) 으로 들여쓰기 되어야 합니다. 그렇지 않으면 IndentationError가 발생합니다.\n\n# 잘못된 예시 (IndentationError 발생)\n# value = 10\n# if value &gt; 5:\n# print(\"값이 5보다 큽니다.\") # 들여쓰기 없음!",
    "crumbs": [
      "Curriculum",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>3주차: 똑똑한 프로그램 만들기 (조건문 If)</span>"
    ]
  },
  {
    "objectID": "week3.html#아니면-else-문",
    "href": "week3.html#아니면-else-문",
    "title": "3  3주차: 똑똑한 프로그램 만들기 (조건문 If)",
    "section": "3.3 3. 아니면? : else 문",
    "text": "3.3 3. 아니면? : else 문\nif 조건이 False일 때 실행할 코드를 지정하려면 else를 사용합니다.\n기본 구조 복습:\n\n#if 조건식:\n    # 조건식이 True일 때 실행될 코드\n#else:\n    # 조건식이 False일 때 실행될 코드\n\nif-else 문 예제:\n예제 1: 경제 성장 여부 판단 (0% 기준)\n\ngdp_growth_rates = [-0.2, 4.1, 2.6, 1.4, 2.2] # 첫 해 성장률 음수로 변경\nfirst_year_growth = gdp_growth_rates[0]\n\nprint(f\"첫 해 성장률: {first_year_growth}%\")\n\nif first_year_growth &gt; 0:\n    print(\"첫 해에 경제가 성장했습니다.\")\nelse: # first_year_growth &lt;= 0 인 경우\n    print(\"첫 해에 경제가 성장하지 못했거나 후퇴했습니다.\")\n\n첫 해 성장률: -0.2%\n첫 해에 경제가 성장하지 못했거나 후퇴했습니다.\n\n\n예제 2: 특정 통화 포함 여부 확인 (in 연산자 소개)\n리스트나 딕셔너리(의 키) 안에 특정 요소가 있는지 확인하고 싶을 때 in 연산자를 사용할 수 있습니다. 결과는 True 또는 False 입니다. (not in 은 포함되어 있지 않을 때 True)\n\ncurrency_list = [\"USD\", \"EUR\", \"JPY\", \"CNY\"]\nmy_currency = \"KRW\"\n\nprint(f\"분석 대상 통화: {currency_list}\")\nprint(f\"확인할 통화: {my_currency}\")\n\nif my_currency in currency_list: # 'KRW'가 currency_list 안에 있는가? (False)\n    print(f\"{my_currency}는(은) 주요 분석 대상 통화입니다.\")\nelse:\n    print(f\"{my_currency}는(은) 주요 분석 대상 통화가 아닙니다.\")\n\n# 딕셔너리 키 확인\ncountry_gdp_dict = {\"Korea\": 1.8, \"USA\": 27.0}\ntarget_country = \"USA\"\n\nif target_country in country_gdp_dict: # 'USA' 키가 딕셔너리에 있는가? (True)\n     print(f\"{target_country}의 GDP 정보가 있습니다: {country_gdp_dict[target_country]} 조 달러\")\nelse:\n     print(f\"{target_country}의 GDP 정보가 없습니다.\")\n\n분석 대상 통화: ['USD', 'EUR', 'JPY', 'CNY']\n확인할 통화: KRW\nKRW는(은) 주요 분석 대상 통화가 아닙니다.\nUSA의 GDP 정보가 있습니다: 27.0 조 달러",
    "crumbs": [
      "Curriculum",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>3주차: 똑똑한 프로그램 만들기 (조건문 If)</span>"
    ]
  },
  {
    "objectID": "week3.html#여러-갈래-길-elif-문",
    "href": "week3.html#여러-갈래-길-elif-문",
    "title": "3  3주차: 똑똑한 프로그램 만들기 (조건문 If)",
    "section": "3.4 4. 여러 갈래 길: elif 문",
    "text": "3.4 4. 여러 갈래 길: elif 문\n여러 조건을 순서대로 검사하여, 처음으로 True가 되는 조건의 코드 블록만 실행하고 싶을 때 elif (else if)를 사용합니다.\n기본 구조 복습:\nif 조건식1:\n    # 조건식1 True 시 실행\nelif 조건식2:\n    # 조건식1 False, 조건식2 True 시 실행\n# ... (elif 계속 추가 가능)\nelse:\n    # 모든 if/elif 조건이 False일 때 실행 (선택 사항)\nif-elif-else 문 예제:\n예제 1: GDP 성장률 구간 분류 (리스트 요소 사용)\n\ngdp_growth_rates = [0.5, 4.1, -0.8, 1.4, 2.2]\n# 검사할 성장률 (예: 2022년 데이터, 인덱스 2)\ngrowth_rate_to_check = gdp_growth_rates[2]\n\nprint(f\"검사 대상 성장률: {growth_rate_to_check}%\")\n\nif growth_rate_to_check &gt;= 3.0:\n    category = \"고성장\"\nelif growth_rate_to_check &gt;= 1.0:\n    category = \"중성장\"\nelif growth_rate_to_check &gt; -1.0: # -1.0 초과 1.0 미만\n    category = \"저성장\"\nelse: # -1.0 이하\n    category = \"경기 후퇴\"\n\nprint(f\"분류 결과: '{category}' 국면\")\n\n검사 대상 성장률: -0.8%\n분류 결과: '저성장' 국면\n\n\n예제 2: 기업 부채비율 기반 재무 안정성 평가 (딕셔너리 값 사용)\n\nfinancial_info = {\n    \"회사명\": \"다다다 상사\",\n    \"매출액(억 원)\": 620,\n    \"영업이익(억 원)\": 45.5,\n    \"부채비율(%)\": 185.2 # 부채 비율이 다소 높음\n}\ndebt_ratio = financial_info[\"부채비율(%)\"]\n\nprint(f\"{financial_info['회사명']}의 부채비율: {debt_ratio}%\")\n\nif debt_ratio &lt; 100.0:\n    stability = \"안정적\"\nelif debt_ratio &lt; 200.0: # 100.0 이상 200.0 미만\n    stability = \"보통 (주의 필요)\"\nelse: # 200.0 이상\n    stability = \"위험 수준\"\n\nprint(f\"재무 안정성 평가: {stability}\")\n\n다다다 상사의 부채비율: 185.2%\n재무 안정성 평가: 보통 (주의 필요)\n\n\n\n\n[실습 1] if, elif, else, 비교 연산자, in 연습\n\n리스트 요소 값 확인: stock_prices = [80000, 75000, 78000, 82000, 79000] 리스트가 주어졌을 때, 마지막 날 (인덱스 -1) 의 주가가 80000원 이상이면 “매도 고려”, 그렇지 않으면 “보유 또는 매수 고려”를 출력하세요.\n딕셔너리 값 분류: portfolio = {\"주식\": 0.5, \"채권\": 0.3, \"현금\": 0.2} 딕셔너리가 주어졌을 때 (값은 비중을 의미), “주식”의 비중이 0.6 이상이면 “공격적 포트폴리오”, 0.4 이상이면 “중립적 포트폴리오”, 그 외에는 “안정적 포트폴리오”를 출력하세요.\n자산 포함 여부 확인: 위 portfolio 딕셔너리에 “금” 이라는 키가 있는지 in 연산자와 if-else 문을 사용하여 확인하고, 있으면 “포트폴리오에 금이 포함되어 있습니다.”, 없으면 “포트폴리오에 금이 포함되어 있지 않습니다.” 를 출력하세요.\n\n\n\n# 실습 1-1: 마지막 날 주가 확인\nstock_prices = [80000, 75000, 78000, 82000, 79000]\nlast_day_price = stock_prices[-1]\nprint(f\"마지막 날 주가: {last_day_price}\")\nif last_day_price &gt;= 80000:\n    print(\"매도 고려\")\nelse:\n    print(\"보유 또는 매수 고려\")\n\n마지막 날 주가: 79000\n보유 또는 매수 고려\n\n\n\n# 실습 1-2: 포트폴리오 분류\nportfolio = {\"주식\": 0.5, \"채권\": 0.3, \"현금\": 0.2}\nstock_weight = portfolio[\"주식\"] # 주식 비중 가져오기\nprint(f\"주식 비중: {stock_weight}\")\nif stock_weight &gt;= 0.6:\n    print(\"공격적 포트폴리오\")\nelif stock_weight &gt;= 0.4: # 0.6 미만, 0.4 이상\n    print(\"중립적 포트폴리오\")\nelse: # 0.4 미만\n    print(\"안정적 포트폴리오\")\n\n주식 비중: 0.5\n중립적 포트폴리오\n\n\n\n# 실습 1-3: 자산 포함 여부 확인\n# portfolio 딕셔너리는 위 셀에서 정의됨\nasset_to_check = \"금\"\nif asset_to_check in portfolio: # 딕셔너리에서는 key를 기준으로 확인\n    print(f\"포트폴리오에 {asset_to_check}이(가) 포함되어 있습니다.\")\nelse:\n    print(f\"포트폴리오에 {asset_to_check}이(가) 포함되어 있지 않습니다.\")\n\n포트폴리오에 금이(가) 포함되어 있지 않습니다.",
    "crumbs": [
      "Curriculum",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>3주차: 똑똑한 프로그램 만들기 (조건문 If)</span>"
    ]
  },
  {
    "objectID": "week3.html#여러-조건을-조합하기-논리-연산자-and-or-not",
    "href": "week3.html#여러-조건을-조합하기-논리-연산자-and-or-not",
    "title": "3  3주차: 똑똑한 프로그램 만들기 (조건문 If)",
    "section": "3.5 5. 여러 조건을 조합하기: 논리 연산자 (and, or, not)",
    "text": "3.5 5. 여러 조건을 조합하기: 논리 연산자 (and, or, not)\n하나의 조건이 아니라 여러 조건을 동시에 만족하거나, 적어도 하나 만족하는지 등을 확인해야 할 때 논리 연산자를 사용합니다.\n\nand: 두 조건 모두 True 여야 최종 True\nor: 두 조건 중 하나라도 True 이면 최종 True\nnot: 조건의 True/False 를 반대로 바꿈\n\n논리 연산자 예제:\n예제 1: 경제 안정성 판단 (and 사용)\n\n# 딕셔너리에서 값 가져오기\nmacro_indicators = {\"inflation_rate\": 1.8, \"unemployment_rate\": 3.5}\ninflation = macro_indicators[\"inflation_rate\"]\nunemployment = macro_indicators[\"unemployment_rate\"]\n\nprint(f\"물가상승률: {inflation}%, 실업률: {unemployment}%\")\n\n# 물가 2% 미만 AND 실업률 4% 미만일 때 안정적이라고 판단\nif inflation &lt; 2.0 and unemployment &lt; 4.0:\n    print(\"경제 안정성: 양호\")\nelse:\n    print(\"경제 안정성: 개선 필요\")\n\n물가상승률: 1.8%, 실업률: 3.5%\n경제 안정성: 양호\n\n\n예제 2: 투자 위험 경고 (or 사용)\n부채 비율이 높거나(150% 이상) 영업 이익률이 낮으면(5% 미만) 위험 경고를 보냅니다.\n\ncompany_financials = {\"debt_ratio\": 180.0, \"operating_margin\": 3.2} # 단위: %\ndebt = company_financials[\"debt_ratio\"]\nmargin = company_financials[\"operating_margin\"]\n\nprint(f\"부채비율: {debt}%, 영업이익률: {margin}%\")\n\n# 부채비율이 150 이상이거나 OR 영업이익률이 5 미만이면 위험\nif debt &gt;= 150.0 or margin &lt; 5.0:\n    print(\"재무 위험 경고!\")\nelse:\n    print(\"재무 상태 비교적 안정적.\")\n\n부채비율: 180.0%, 영업이익률: 3.2%\n재무 위험 경고!\n\n\n예제 3: 특정 자산 제외 확인 (not in 사용)\n포트폴리오에 ’암호화폐’가 포함되어 있지 않은지 확인합니다. not in 은 in의 결과를 반대로 합니다.\n\nportfolio_assets = [\"주식\", \"채권\", \"부동산\"] # 리스트 사용 예시\nasset_check = \"암호화폐\"\n\nprint(f\"포트폴리오 구성: {portfolio_assets}\")\nprint(f\"확인 대상: {asset_check}\")\n\nif asset_check not in portfolio_assets: # '암호화폐'가 리스트에 없는가? (True)\n    print(f\"{asset_check}는 포트폴리오에 포함되지 않았습니다.\")\nelse:\n    print(f\"{asset_check}가 포트폴리오에 포함되어 있습니다.\")\n\n포트폴리오 구성: ['주식', '채권', '부동산']\n확인 대상: 암호화폐\n암호화폐는 포트폴리오에 포함되지 않았습니다.\n\n\n\n\n[실습 2] 논리 연산자 및 in 연습\n\n우수 고객 선정: 고객 정보 딕셔너리 customer = {\"age\": 35, \"total_purchase\": 1500000, \"is_member\": True} 가 주어졌을 때, 다음 두 조건을 모두 만족하면 “우수 고객”을 출력하는 코드를 작성하세요.\n\n조건 1: 총 구매액 (total_purchase) 100만원 이상\n조건 2: 멤버십 회원 (is_member 가 True)\n\n투자 부적격 자산 확인: 투자 대상 자산 리스트 investment_targets = [\"삼성전자\", \"미국 국채 10년물\", \"금 ETF\"] 가 있습니다. target_asset = \"비트코인\" 이라는 변수가 주어졌을 때, 이 자산이 investment_targets 리스트에 포함되어 있지 않다면 (not in 사용) “투자 부적격 자산입니다.” 를 출력하세요.\n\n\n\n# 실습 2-1: 우수 고객 선정\ncustomer = {\"age\": 35, \"total_purchase\": 1500000, \"is_member\": True}\ntotal_purchase = customer[\"total_purchase\"]\nis_member = customer[\"is_member\"]\n\nprint(f\"총 구매액: {total_purchase}, 멤버십 여부: {is_member}\")\n\nif total_purchase &gt;= 1000000 and is_member == True: # is_member 만 써도 True인지 확인 가능\n    print(\"우수 고객\")\nelse:\n    print(\"일반 고객\")\n\n총 구매액: 1500000, 멤버십 여부: True\n우수 고객\n\n\n\n# 실습 2-2: 투자 부적격 자산 확인\ninvestment_targets = [\"삼성전자\", \"미국 국채 10년물\", \"금 ETF\"]\ntarget_asset = \"비트코인\"\n\nprint(f\"투자 대상 리스트: {investment_targets}\")\nprint(f\"확인 자산: {target_asset}\")\n\nif target_asset not in investment_targets:\n    print(f\"{target_asset}은(는) 투자 부적격 자산입니다.\")\n# 만약 target_asset이 리스트에 있다면 아무것도 출력되지 않음 (else가 없으므로)\n\n투자 대상 리스트: ['삼성전자', '미국 국채 10년물', '금 ETF']\n확인 자산: 비트코인\n비트코인은(는) 투자 부적격 자산입니다.",
    "crumbs": [
      "Curriculum",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>3주차: 똑똑한 프로그램 만들기 (조건문 If)</span>"
    ]
  },
  {
    "objectID": "week3.html#경제회계-응용-리스트와-딕셔너리에-조건문-적용하기",
    "href": "week3.html#경제회계-응용-리스트와-딕셔너리에-조건문-적용하기",
    "title": "3  3주차: 똑똑한 프로그램 만들기 (조건문 If)",
    "section": "3.6 6. 경제/회계 응용: 리스트와 딕셔너리에 조건문 적용하기",
    "text": "3.6 6. 경제/회계 응용: 리스트와 딕셔너리에 조건문 적용하기\n이제 조건문을 리스트와 딕셔너리에 담긴 데이터를 분석하는 데 좀 더 구체적으로 적용해 봅시다.\n(주의!) 지금은 리스트나 딕셔너리의 개별 요소에 접근해서 조건을 확인하는 방식 위주로 살펴봅니다. 리스트나 딕셔너리의 모든 요소를 자동으로 하나씩 검사하려면 다음 주에 배울 반복문(Loop) 이 필요합니다. 오늘은 조건문 자체에 집중해 주세요.\n예제 1: 분기별 매출 목표 달성 여부 확인 (리스트)\n\nquarterly_revenue = [120.5, 135.2, 115.0, 150.0] # 단위: 억 원\nrevenue_target = 130.0 # 분기 목표 매출액\n\nprint(f\"분기별 매출액: {quarterly_revenue}\")\nprint(f\"목표 매출액: {revenue_target}억 원\")\n\n# 2분기 실적 확인 (인덱스 1)\nprint(\"\\n--- 2분기 실적 확인 ---\")\nif quarterly_revenue[1] &gt;= revenue_target:\n    print(\"2분기 목표 달성!\")\nelse:\n    print(\"2분기 목표 미달.\")\n\n# 4분기 실적 확인 (인덱스 3)\nprint(\"\\n--- 4분기 실적 확인 ---\")\nif quarterly_revenue[3] &gt;= revenue_target:\n    print(\"4분기 목표 달성!\")\nelse:\n    print(\"4분기 목표 미달.\")\n\n# 마지막 분기가 첫 분기보다 성장했는지 확인\nprint(\"\\n--- 4분기 vs 1분기 성장 확인 ---\")\nif quarterly_revenue[-1] &gt; quarterly_revenue[0]:\n    print(\"4분기 매출이 1분기보다 증가했습니다.\")\nelse:\n    print(\"4분기 매출이 1분기보다 증가하지 않았거나 동일합니다.\")\n\n분기별 매출액: [120.5, 135.2, 115.0, 150.0]\n목표 매출액: 130.0억 원\n\n--- 2분기 실적 확인 ---\n2분기 목표 달성!\n\n--- 4분기 실적 확인 ---\n4분기 목표 달성!\n\n--- 4분기 vs 1분기 성장 확인 ---\n4분기 매출이 1분기보다 증가했습니다.\n\n\n예제 2: 기업 재무 건전성 종합 평가 (딕셔너리)\n여러 재무 지표를 딕셔너리에 담고, 각 지표가 기준치를 만족하는지 종합적으로 판단해 봅시다.\n\nfinancial_health = {\n    \"유동비율(%)\": 150.5,   # Current Ratio (단기 부채 상환 능력, 보통 100% 이상 양호)\n    \"부채비율(%)\": 95.8,    # Debt-to-Equity Ratio (타인 자본 의존도, 낮을수록 좋음)\n    \"영업이익률(%)\": 12.3    # Operating Margin (수익성, 높을수록 좋음)\n}\n\nprint(\"--- 기업 재무 건전성 평가 ---\")\nprint(f\"데이터: {financial_health}\")\n\n# 평가 기준 설정\ncurrent_ratio_threshold = 100.0\ndebt_ratio_threshold = 150.0\noperating_margin_threshold = 10.0\n\n# 각 지표 평가\nis_current_ratio_ok = financial_health[\"유동비율(%)\"] &gt;= current_ratio_threshold\nis_debt_ratio_ok = financial_health[\"부채비율(%)\"] &lt; debt_ratio_threshold\nis_margin_ok = financial_health[\"영업이익률(%)\"] &gt;= operating_margin_threshold\n\nprint(f\"\\n유동비율 양호(&gt;{current_ratio_threshold}%): {is_current_ratio_ok}\")\nprint(f\"부채비율 양호(&lt;{debt_ratio_threshold}%): {is_debt_ratio_ok}\")\nprint(f\"영업이익률 양호(&gt;{operating_margin_threshold}%): {is_margin_ok}\")\n\n# 종합 평가 (모든 조건 만족 시 '매우 양호')\nif is_current_ratio_ok and is_debt_ratio_ok and is_margin_ok:\n    overall_assessment = \"매우 양호\"\n# 하나라도 만족 못하면 '개선 필요' (더 세분화 가능)\nelse:\n    overall_assessment = \"일부 개선 필요\"\n\nprint(f\"\\n종합 평가: {overall_assessment}\")\n\n--- 기업 재무 건전성 평가 ---\n데이터: {'유동비율(%)': 150.5, '부채비율(%)': 95.8, '영업이익률(%)': 12.3}\n\n유동비율 양호(&gt;100.0%): True\n부채비율 양호(&lt;150.0%): True\n영업이익률 양호(&gt;10.0%): True\n\n종합 평가: 매우 양호",
    "crumbs": [
      "Curriculum",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>3주차: 똑똑한 프로그램 만들기 (조건문 If)</span>"
    ]
  },
  {
    "objectID": "week3.html#마무리-및-다음-시간-예고",
    "href": "week3.html#마무리-및-다음-시간-예고",
    "title": "3  3주차: 똑똑한 프로그램 만들기 (조건문 If)",
    "section": "3.7 7. 마무리 및 다음 시간 예고",
    "text": "3.7 7. 마무리 및 다음 시간 예고\n오늘은 프로그램의 의사결정 능력을 부여하는 조건문 (if, elif, else) 과 이를 위한 비교 연산자, 논리 연산자에 대해 배웠습니다. 특히, 지난주에 배운 리스트와 딕셔너리에 저장된 데이터를 조건문을 이용해 어떻게 분석하고 판단할 수 있는지 살펴보았습니다. 코드의 논리적 흐름을 제어하는 들여쓰기의 중요성도 다시 한번 강조했습니다.\n다음 시간에는:\n이제 특정 조건에 따라 다른 행동을 하도록 만들 수 있게 되었으니, 다음 단계는 반복적인 작업을 효율적으로 처리하는 것입니다. 예를 들어, 리스트에 있는 모든 국가의 GDP를 하나씩 확인하거나, 딕셔너리에 있는 모든 재무 지표를 평가하는 작업을 자동화하는 방법을 배웁니다. 이를 위해 파이썬의 반복문 (Loops), 특히 for 반복문에 대해 배우고, 리스트와 함께 활용하는 방법을 익힐 것입니다. 반복문을 배우면 대량의 데이터를 처리하는 훨씬 강력한 코드를 작성할 수 있게 됩니다!",
    "crumbs": [
      "Curriculum",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>3주차: 똑똑한 프로그램 만들기 (조건문 If)</span>"
    ]
  },
  {
    "objectID": "week3.html#세-번째-주차-과제",
    "href": "week3.html#세-번째-주차-과제",
    "title": "3  3주차: 똑똑한 프로그램 만들기 (조건문 If)",
    "section": "3.8 세 번째 주차 과제",
    "text": "3.8 세 번째 주차 과제\n오늘 배운 조건문과 연산자들을 복습하기 위해 다음 과제를 Colab에서 새 노트(Week3_Assignment.ipynb 등)에 풀어보세요.\n\n포트폴리오 위험 평가:\n\nmy_assets = {\"주식\": 0.6, \"채권\": 0.2, \"현금\": 0.1, \"암호화폐\": 0.1} 딕셔너리가 있습니다 (값은 비중).\n“암호화폐” 비중이 0.05 (5%)를 초과 하거나 “주식” 비중이 0.7 (70%)을 초과하면 “고위험 포트폴리오 경고!”를 출력하세요 (or 사용).\n두 조건 모두 해당하지 않으면 “중위험 또는 저위험 포트폴리오”를 출력하세요.\n\n국가 리스트 분류:\n\ncountries = [\"미국\", \"중국\", \"한국\", \"베트남\", \"독일\"] 리스트가 있습니다.\ntarget_country = \"한국\" 이라는 변수가 주어졌을 때,\n\ntarget_country가 countries 리스트에 있으면서 (in) 그 이름이 “미국”, “중국”, “독일” 중 하나와 같다면 (==, or 사용) “G7 또는 주요 경제국 포함”을 출력하세요.\n리스트에 있긴 하지만 위 세 국가가 아니라면 (예: “한국”, “베트남”) “기타 분석 대상 국가”를 출력하세요.\n리스트에 아예 없다면 “분석 대상 국가 아님”을 출력하세요. (if-elif-else 구조와 in, and/or 조합 활용)\n\n\n간단한 환율 비교:\n\nexchange_rates = {\"USD\": 1350.0, \"EUR\": 1450.0, \"JPY\": 9.5} 딕셔너리가 있습니다 (1 단위당 원화 가치).\n“USD” 환율과 “EUR” 환율을 비교하여 어느 통화의 원화 가치가 더 높은지 출력하세요.\n“JPY” 환율이 10.0 미만인지 확인하고, 미만이라면 “엔화 약세 가능성”을 출력하세요.",
    "crumbs": [
      "Curriculum",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>3주차: 똑똑한 프로그램 만들기 (조건문 If)</span>"
    ]
  },
  {
    "objectID": "week4.html",
    "href": "week4.html",
    "title": "4  4주차: 반복 작업은 컴퓨터에게! (반복문 for 와 리스트 활용)",
    "section": "",
    "text": "4.1 1. 왜 ’반복문’이 필요할까요? : 반복 작업의 자동화\n강의 개요:\n지난 시간에는 조건문(if, elif, else)을 사용하여 프로그램이 특정 조건에 따라 다른 경로로 실행되도록 제어하는 방법을 배웠습니다. 이를 통해 리스트나 딕셔너리에 저장된 개별 데이터에 대해 판단을 내릴 수 있었죠.\n하지만 만약 리스트에 담긴 모든 국가의 GDP 성장률을 하나씩 확인하거나, 1년치(12개월) 월별 매출 데이터의 합계를 구하거나, 특정 조건을 만족하는 모든 항목을 찾아내는 작업을 하려면 어떻게 해야 할까요? 조건문만으로는 이런 반복적인 작업을 효율적으로 처리하기 어렵습니다. 100개 국가 데이터가 있다면 if문을 100번 써야 할까요? 그건 너무 비효율적이겠죠.\n이번 주에는 바로 이러한 반복 작업을 자동화하는 강력한 도구인 반복문(Loop), 그중에서도 for 반복문에 대해 집중적으로 배웁니다. for 반복문을 사용하면 리스트와 같은 순서열(sequence) 자료 구조의 모든 항목을 하나씩 꺼내어 동일한 작업을 반복 수행할 수 있습니다. 또한, range() 함수와 함께 사용하여 특정 횟수만큼 코드를 반복 실행하는 방법도 배울 것입니다. 반복문은 대량의 데이터를 처리하고 분석하는 데 필수적이므로, 오늘 내용을 잘 익혀두시기 바랍니다.\n이번 시간 학습 목표:\n다음과 같은 상황을 생각해 봅시다.\n이런 작업들은 모두 ‘리스트(또는 다른 데이터 묶음)의 각 항목에 대해 동일한 처리(출력, 계산 누적 등)를 반복한다’ 는 공통점이 있습니다. 만약 데이터가 10개, 100개, 1000개로 늘어난다면, 이 작업을 손으로(즉, 코드를 복사-붙여넣기 해서) 반복하는 것은 거의 불가능하며 실수의 위험도 매우 큽니다.\n반복문(Loop) 은 바로 이런 문제를 해결하기 위해 등장했습니다. 반복문은 특정 코드 블록을 여러 번 자동으로 실행해 주므로, 우리는 반복될 작업 내용만 한 번 정의하면 됩니다. 이를 통해 코드는 훨씬 간결해지고, 데이터 크기에 상관없이 동일한 로직을 적용할 수 있으며, 오류 발생 가능성도 줄어듭니다.",
    "crumbs": [
      "Curriculum",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>4주차: 반복 작업은 컴퓨터에게! (반복문 for 와 리스트 활용)</span>"
    ]
  },
  {
    "objectID": "week4.html#왜-반복문이-필요할까요-반복-작업의-자동화",
    "href": "week4.html#왜-반복문이-필요할까요-반복-작업의-자동화",
    "title": "4  4주차: 반복 작업은 컴퓨터에게! (반복문 for 와 리스트 활용)",
    "section": "",
    "text": "경제 데이터: 1960년부터 2023년까지 한국의 연도별 GDP 리스트가 있을 때, 각 연도의 GDP를 출력하고 전체 기간의 평균 GDP를 계산하고 싶다.\n회계 데이터: 어떤 회사의 12개월치 월별 매출액 리스트가 있을 때, 각 월의 매출액을 확인하고 연간 총 매출액을 구하고 싶다.\n금융 데이터: 포트폴리오에 담긴 모든 주식의 현재 가격을 가져와 평가 손익을 계산하고 싶다.",
    "crumbs": [
      "Curriculum",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>4주차: 반복 작업은 컴퓨터에게! (반복문 for 와 리스트 활용)</span>"
    ]
  },
  {
    "objectID": "week4.html#리스트-속-친구들을-하나씩-만나기-for-반복문-기초",
    "href": "week4.html#리스트-속-친구들을-하나씩-만나기-for-반복문-기초",
    "title": "4  4주차: 반복 작업은 컴퓨터에게! (반복문 for 와 리스트 활용)",
    "section": "4.2 2. 리스트 속 친구들을 하나씩 만나기: for 반복문 기초",
    "text": "4.2 2. 리스트 속 친구들을 하나씩 만나기: for 반복문 기초\n파이썬에서 가장 흔하게 사용되는 반복문은 for 반복문입니다. for 반복문은 리스트, 문자열, 튜플 등 여러 개의 요소를 순서대로 담고 있는 객체(순회 가능한 객체, Iterable) 의 요소들을 처음부터 끝까지 하나씩 꺼내어 지정된 작업을 반복 수행합니다.\n기본 구조:\n\n#for 임시변수 in 순회가능객체(예: 리스트):\n    # 순회가능객체의 각 요소에 대해 반복 실행될 코드 블록\n    # 이 블록 안에서는 '임시변수'를 통해 현재 요소를 사용할 수 있음\n    # ★★★ 이 부분도 반드시 들여쓰기! ★★★\n# 반복문이 모두 끝나고 실행될 코드\n\n구성 요소:\n\nfor 키워드: 반복문의 시작을 알립니다.\n임시변수(Temporary Variable): 반복문이 실행될 때마다 순회가능객체에서 꺼내온 요소가 임시로 저장될 변수입니다. 변수 이름은 자유롭게 지을 수 있지만, 보통 요소의 의미를 나타내는 이름을 사용합니다 (예: country in countries).\nin 키워드: 임시변수와 순회가능객체를 연결하는 역할을 합니다.\n순회가능객체(Iterable): 리스트(list), 튜플(tuple), 문자열(str), 딕셔너리(dict), range() 객체 등 여러 요소를 포함하고 있는 객체입니다. 오늘은 주로 리스트를 다룹니다.\n콜론(:): for ... in ... 끝에는 반드시 콜론을 붙입니다.\n들여쓰기된 코드 블록: 리스트의 각 요소에 대해 반복적으로 실행될 코드입니다. 이 블록 안에서 임시변수를 사용하여 현재 처리 중인 요소 값에 접근할 수 있습니다.\n\nfor 반복문 예제 (리스트 활용):\n예제 1: 국가 이름 리스트 순회하며 출력하기\n\ncountries = [\"대한민국\", \"미국\", \"중국\", \"일본\", \"독일\"]\n\nprint(\"--- 주요 국가 목록 ---\")\n# countries 리스트의 각 요소를 하나씩 꺼내어 country 변수에 담아 아래 코드를 반복 실행\nfor country in countries:\n    # country 변수에는 반복마다 \"대한민국\", \"미국\", ... , \"독일\" 이 차례대로 담김\n    print(f\"안녕하세요, {country}!\")\n\nprint(\"--- 목록 출력 완료 ---\")\n\n--- 주요 국가 목록 ---\n안녕하세요, 대한민국!\n안녕하세요, 미국!\n안녕하세요, 중국!\n안녕하세요, 일본!\n안녕하세요, 독일!\n--- 목록 출력 완료 ---\n\n\n위 코드는 countries 리스트의 첫 번째 요소 “대한민국”을 country 변수에 담아 print문을 실행하고, 다음 요소 “미국”을 country 변수에 담아 print문을 실행하고, … , 마지막 “독일”까지 반복한 후 종료됩니다.\n예제 2: GDP 성장률 리스트 순회하며 값 확인 및 합계 계산\n\ngdp_growth_rates = [0.5, 4.1, 2.6, 1.4, 2.2] # 단위: %\ntotal_growth = 0.0 # 성장률 합계를 저장할 변수 초기화\n\nprint(\"--- 연도별 GDP 성장률 ---\")\nfor rate in gdp_growth_rates:\n    # rate 변수에는 0.5, 4.1, 2.6, 1.4, 2.2 가 차례대로 담김\n    print(f\"이번 연도 성장률: {rate}%\")\n    total_growth = total_growth + rate # 각 연도 성장률을 total_growth에 누적하여 더함\n    # total_growth += rate 와 동일한 표현\n\n# 반복문이 끝난 후 최종 결과 출력\nprint(\"\\n--- 분석 결과 ---\")\nprint(f\"총 {len(gdp_growth_rates)} 년간의 누적 성장률 합계: {total_growth:.2f}%\") # len() 함수는 리스트의 길이를 반환\n\n# 평균 성장률 계산\nif len(gdp_growth_rates) &gt; 0:\n    average_growth = total_growth / len(gdp_growth_rates)\n    print(f\"평균 성장률: {average_growth:.2f}%\")\nelse:\n    print(\"데이터가 없어 평균 성장률을 계산할 수 없습니다.\")\n\n--- 연도별 GDP 성장률 ---\n이번 연도 성장률: 0.5%\n이번 연도 성장률: 4.1%\n이번 연도 성장률: 2.6%\n이번 연도 성장률: 1.4%\n이번 연도 성장률: 2.2%\n\n--- 분석 결과 ---\n총 5 년간의 누적 성장률 합계: 10.80%\n평균 성장률: 2.16%\n\n\n예제 3: 반복문 안에서 조건문(if) 사용하기 (필터링, 카운팅)\n반복문 코드 블록 안에서 if 문을 사용하여 특정 조건을 만족하는 요소에 대해서만 작업을 수행할 수 있습니다.\n\ngdp_growth_rates = [0.5, 4.1, -0.8, 1.4, 2.2, 3.1] # 마이너스 성장과 고성장(3% 이상) 포함\npositive_growth_count = 0 # 플러스 성장 횟수 카운트 변수\nhigh_growth_years = [] # 고성장 연도의 성장률을 저장할 빈 리스트 (개념 소개)\n\nprint(\"--- 성장률 분석 ---\")\nfor rate in gdp_growth_rates:\n    print(f\"처리 중인 성장률: {rate}%\")\n    # 조건 1: 플러스 성장(+)인 경우만 횟수 증가\n    if rate &gt; 0:\n        print(\"  -&gt; 플러스 성장입니다.\")\n        positive_growth_count = positive_growth_count + 1 # 카운트 증가\n    # 조건 2: 3% 이상 고성장인 경우, 해당 성장률을 다른 리스트에 추가 (나중에 활용 가능)\n    if rate &gt;= 3.0:\n        print(\"  -&gt; 고성장입니다!\")\n        high_growth_years.append(rate) # 리스트에 요소 추가\n\n# 반복문 종료 후 결과 출력\nprint(\"\\n--- 최종 분석 결과 ---\")\nprint(f\"총 {len(gdp_growth_rates)} 년 중 플러스(+) 성장 횟수: {positive_growth_count} 번\")\nprint(f\"고성장(3% 이상)을 기록한 성장률들: {high_growth_years}\")\n\n--- 성장률 분석 ---\n처리 중인 성장률: 0.5%\n  -&gt; 플러스 성장입니다.\n처리 중인 성장률: 4.1%\n  -&gt; 플러스 성장입니다.\n  -&gt; 고성장입니다!\n처리 중인 성장률: -0.8%\n처리 중인 성장률: 1.4%\n  -&gt; 플러스 성장입니다.\n처리 중인 성장률: 2.2%\n  -&gt; 플러스 성장입니다.\n처리 중인 성장률: 3.1%\n  -&gt; 플러스 성장입니다.\n  -&gt; 고성장입니다!\n\n--- 최종 분석 결과 ---\n총 6 년 중 플러스(+) 성장 횟수: 5 번\n고성장(3% 이상)을 기록한 성장률들: [4.1, 3.1]\n\n\n\n\n[실습 1] for 반복문과 리스트 연습\n\n주가지수 리스트 출력: stock_indices = [\"KOSPI\", \"Dow Jones\", \"Nasdaq\", \"Nikkei 225\"] 리스트가 있습니다. for 반복문을 사용하여 각 주가지수 이름을 한 줄에 하나씩 출력하세요.\n분기별 매출액 합계 및 평균 계산: quarterly_revenue = [120.5, 135.2, 115.0, 150.0] 리스트(단위: 억 원)가 있습니다. for 반복문을 사용하여 네 분기 전체 매출액의 합계와 평균 매출액을 계산하고 출력하세요.\n목표 매출액 초과 분기 카운트: 위 quarterly_revenue 리스트와 revenue_target = 130.0 (단위: 억 원) 목표액이 주어졌을 때, for 반복문과 if 문을 사용하여 목표 매출액을 초과한 분기가 총 몇 번인지 계산하고 출력하세요.\n\n\n\n# 실습 1-1: 주가지수 리스트 출력\nstock_indices = [\"KOSPI\", \"Dow Jones\", \"Nasdaq\", \"Nikkei 225\"]\nprint(\"--- 주요 주가지수 ---\")\nfor index_name in stock_indices:\n    print(index_name)\n\n--- 주요 주가지수 ---\nKOSPI\nDow Jones\nNasdaq\nNikkei 225\n\n\n\n# 실습 1-2: 분기별 매출액 합계 및 평균 계산\nquarterly_revenue = [120.5, 135.2, 115.0, 150.0] # 단위: 억 원\ntotal_revenue = 0.0\nnum_quarters = len(quarterly_revenue)\n\nfor revenue in quarterly_revenue:\n    total_revenue += revenue # total_revenue = total_revenue + revenue\n\nprint(f\"연간 총 매출액: {total_revenue:.2f} 억 원\")\n\nif num_quarters &gt; 0:\n    average_revenue = total_revenue / num_quarters\n    print(f\"평균 분기 매출액: {average_revenue:.2f} 억 원\")\nelse:\n    print(\"매출 데이터가 없습니다.\")\n\n연간 총 매출액: 520.70 억 원\n평균 분기 매출액: 130.18 억 원\n\n\n\n# 실습 1-3: 목표 매출액 초과 분기 카운트\n# quarterly_revenue = [120.5, 135.2, 115.0, 150.0] # 위 셀에서 정의됨\nrevenue_target = 130.0 # 단위: 억 원\nexceed_count = 0 # 목표 초과 횟수 카운트 변수\n\nfor revenue in quarterly_revenue:\n    if revenue &gt; revenue_target:\n        exceed_count += 1 # exceed_count = exceed_count + 1\n\nprint(f\"목표 매출액 ({revenue_target}억 원) 초과 분기 횟수: {exceed_count} 번\")\n\n목표 매출액 (130.0억 원) 초과 분기 횟수: 2 번",
    "crumbs": [
      "Curriculum",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>4주차: 반복 작업은 컴퓨터에게! (반복문 for 와 리스트 활용)</span>"
    ]
  },
  {
    "objectID": "week4.html#정해진-횟수만큼-반복하기-range-함수",
    "href": "week4.html#정해진-횟수만큼-반복하기-range-함수",
    "title": "4  4주차: 반복 작업은 컴퓨터에게! (반복문 for 와 리스트 활용)",
    "section": "4.3 3. 정해진 횟수만큼 반복하기: range() 함수",
    "text": "4.3 3. 정해진 횟수만큼 반복하기: range() 함수\nfor 반복문은 리스트의 요소들을 순회할 때뿐만 아니라, 단순히 정해진 횟수만큼 코드를 반복하고 싶을 때도 사용할 수 있습니다. 이때 range() 함수가 유용하게 사용됩니다. range() 함수는 특정 범위의 연속된 정수(처럼 보이는 것)를 만들어내는 객체를 반환합니다.\nrange() 함수 사용법:\n\nrange(stop): 0부터 stop - 1 까지의 정수를 생성합니다. (예: range(5) 는 0, 1, 2, 3, 4)\nrange(start, stop): start 부터 stop - 1 까지의 정수를 생성합니다. (예: range(2, 5) 는 2, 3, 4)\nrange(start, stop, step): start 부터 stop - 1 까지 step 간격으로 정수를 생성합니다. (예: range(2, 10, 2) 는 2, 4, 6, 8)\n\n주의: stop 값은 항상 포함되지 않습니다!\nfor 와 range() 함께 사용하기:\nfor 반복문에서 range() 함수를 사용하면, range()가 만들어내는 숫자들을 하나씩 꺼내어 임시변수에 담으면서 정해진 횟수만큼 반복을 수행합니다. 이때 임시변수(보통 i 라는 이름을 많이 사용)는 0, 1, 2, … 순서로 증가하는 인덱스처럼 활용될 수 있습니다.\n예제 1: 특정 메시지 5번 출력하기\n\n# 0부터 4까지 (총 5번) 반복\nfor i in range(5):\n    # 변수 i는 0, 1, 2, 3, 4 로 변하면서 반복됨\n    print(f\"{i+1}번째 메시지: 파이썬 공부는 재미있어요!\")\n\n1번째 메시지: 파이썬 공부는 재미있어요!\n2번째 메시지: 파이썬 공부는 재미있어요!\n3번째 메시지: 파이썬 공부는 재미있어요!\n4번째 메시지: 파이썬 공부는 재미있어요!\n5번째 메시지: 파이썬 공부는 재미있어요!\n\n\n예제 2: 연도 리스트 생성 및 출력\nrange()를 사용하여 특정 기간의 연도를 생성하고 리스트로 만들 수 있습니다. (리스트로 바로 만들려면 list() 함수 사용)\n\n# 2020년부터 2024년까지 연도 생성 (2025는 미포함)\nyears_range = range(2020, 2025)\n\nprint(\"range 객체:\", years_range) # range(2020, 2025) 라고 출력됨\n\n# range 객체를 리스트로 변환\nyears_list = list(years_range)\nprint(\"연도 리스트:\", years_list)\n\n# for문을 이용해 각 연도 출력\nprint(\"--- 연도 목록 ---\")\nfor year in years_list: # 또는 for year in range(2020, 2025): 로 바로 사용 가능\n    print(f\"{year}년\")\n\nrange 객체: range(2020, 2025)\n연도 리스트: [2020, 2021, 2022, 2023, 2024]\n--- 연도 목록 ---\n2020년\n2021년\n2022년\n2023년\n2024년\n\n\n예제 3: 간단한 복리 계산 시뮬레이션\n원금 100만원을 연 이율 5%로 3년간 예금했을 때의 원리금 변화를 for와 range()로 계산해 봅시다.\n\n\n\n\n  Cell In[11], line 3\n    원금 100만원을 연 이율 5%로 3년간 예금했을 때의 원리금 변화를 `for`와 `range()`로 계산해 봅시다.\n         ^\nSyntaxError: invalid decimal literal\n\n\n\n\n\nprincipal = 1000000 # 원금\ninterest_rate = 0.05 # 연 이율 5%\nnum_years = 3 # 예금 기간\n\ncurrent_value = principal # 현재 가치를 원금으로 초기화\n\nprint(f\"초기 원금: {current_value} 원\")\nprint(f\"연 이율: {interest_rate * 100}%\")\nprint(f\"예금 기간: {num_years} 년\")\nprint(\"--- 연도별 원리금 ---\")\n\n# 1년부터 3년까지 총 3번 반복 (range(3) -&gt; 0, 1, 2)\n# 여기서는 i를 연차 계산에 직접 쓰진 않지만, 횟수 제어에 사용\nfor i in range(num_years):\n    # 복리 계산: 현재 가치 = 현재 가치 * (1 + 이율)\n    current_value = current_value * (1 + interest_rate)\n    # current_value *= (1 + interest_rate) 와 동일\n    print(f\"{i+1} 년 후 원리금: {current_value:.0f} 원\") # 소수점 버리고 출력\n\nprint(f\"\\n{num_years}년 후 최종 원리금 합계: {current_value:.0f} 원\")\n\n초기 원금: 1000000 원\n연 이율: 5.0%\n예금 기간: 3 년\n--- 연도별 원리금 ---\n1 년 후 원리금: 1050000 원\n2 년 후 원리금: 1102500 원\n3 년 후 원리금: 1157625 원\n\n3년 후 최종 원리금 합계: 1157625 원\n\n\n\n\n[실습 2] for 반복문과 range() 연습\n\nfor 반복문과 range(1, 6) 을 사용하여 1부터 5까지의 숫자를 한 줄에 하나씩 출력하세요.\n어떤 투자 상품의 연평균 수익률이 7%라고 가정합니다. 초기 투자금 500만원이 5년 후에 얼마가 될지(복리 계산) for와 range()를 사용하여 계산하고 최종 금액을 출력하세요.\n\n\n\n# 실습 2-1: 1부터 5까지 출력\nprint(\"--- 1부터 5까지 출력 ---\")\nfor number in range(1, 6): # 1부터 (6-1)까지\n    print(number)\n\n--- 1부터 5까지 출력 ---\n1\n2\n3\n4\n5\n\n\n\n# 실습 2-2: 5년 후 투자금 계산 (복리)\ninitial_investment = 5000000 # 초기 투자금\nannual_return_rate = 0.07 # 연 수익률 7%\ninvestment_years = 5 # 투자 기간\n\ncurrent_investment_value = initial_investment\n\nfor year in range(investment_years): # 0, 1, 2, 3, 4 (총 5번 반복)\n    current_investment_value *= (1 + annual_return_rate)\n    # print(f\"{year+1}년 후 금액: {current_investment_value:.0f} 원\") # 중간 과정 확인용\n\nprint(f\"초기 투자금: {initial_investment} 원\")\nprint(f\"연 수익률: {annual_return_rate * 100}%\")\nprint(f\"투자 기간: {investment_years} 년\")\nprint(f\"{investment_years}년 후 예상 투자금액: {current_investment_value:.0f} 원\")\n\n초기 투자금: 5000000 원\n연 수익률: 7.000000000000001%\n투자 기간: 5 년\n5년 후 예상 투자금액: 7012759 원",
    "crumbs": [
      "Curriculum",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>4주차: 반복 작업은 컴퓨터에게! (반복문 for 와 리스트 활용)</span>"
    ]
  },
  {
    "objectID": "week4.html#sec-loop-visualization",
    "href": "week4.html#sec-loop-visualization",
    "title": "4  4주차: 반복 작업은 컴퓨터에게! (반복문 for 와 리스트 활용)",
    "section": "4.4 4. 반복문과 시각화의 만남 : 시계열 데이터 표현",
    "text": "4.4 4. 반복문과 시각화의 만남 : 시계열 데이터 표현\n지난주 시각화 맛보기에서는 단순히 몇 개의 값을 나열하여 막대 그래프를 그렸습니다. 하지만 경제나 금융에서는 시간에 따른 데이터의 변화, 즉 시계열(Time Series) 데이터를 시각화하는 경우가 매우 많습니다. 예를 들어, 연도별 GDP 변화, 월별 주가 추이, 분기별 실업률 변화 등이 있죠.\n이런 시계열 데이터를 표현하는 데는 선 그래프(Line Plot) 가 주로 사용됩니다. 그리고 선 그래프를 그리려면 순서가 있는 데이터(리스트 등) 와 반복 처리(개념적으로, 또는 라이브러리 내부에서) 가 필수적입니다.\nfor 반복문을 통해 우리는 리스트의 각 요소를 순서대로 처리하는 방법을 배웠습니다. 이 개념이 어떻게 시각화로 이어지는지 간단한 예제를 통해 살펴봅시다.\n예제: 연도별 GDP 성장률 추이 시각화\n\n# --- 시계열 시각화 맛보기 (리스트 + 반복문 개념 활용) ---\nimport matplotlib.pyplot as plt\nimport platform\n\n# 한글 폰트 설정 (이전 셀에서 실행했다고 가정)\ntry:\n    if platform.system() == 'Linux': plt.rc('font', family='NanumBarunGothic')\n    elif platform.system() == 'Windows': plt.rc('font', family='Malgun Gothic')\n    elif platform.system() == 'Darwin': plt.rc('font', family='AppleGothic')\nexcept NameError: # plt가 import 안된 경우 대비\n     print(\"Matplotlib이 import되지 않았거나 폰트 설정에 문제가 있습니다.\")\nexcept FileNotFoundError: print(\"한글 폰트를 찾을 수 없습니다.\")\nplt.rcParams['axes.unicode_minus'] = False\n\n# --- 시계열 데이터 준비 (리스트) ---\nyears = list(range(2020, 2026)) # 연도 리스트 (2020 ~ 2025)\n# 해당 연도별 가상 GDP 성장률 리스트 (단위: %) - years와 길이가 같아야 함!\ngdp_growth_rates = [0.5, 4.1, 2.6, 1.4, 2.2, 2.8]\n\nprint(\"연도 데이터:\", years)\nprint(\"성장률 데이터:\", gdp_growth_rates)\n\n# --- 선 그래프 그리기 (plt.plot 사용) ---\nplt.figure(figsize=(10, 5)) # 그래프 크기 설정\n\n# plt.plot 함수의 첫 인자로 x축 데이터(years), 두 번째 인자로 y축 데이터(gdp_growth_rates) 전달\n# 'marker=o'는 각 데이터 지점에 동그라미 표시 추가, 'linestyle=-'는 실선 사용\nplt.plot(years, gdp_growth_rates, marker='o', linestyle='-', color='dodgerblue')\n\nplt.title('연도별 GDP 성장률 추이', fontsize=15) # 그래프 제목\nplt.xlabel('연도', fontsize=12)             # x축 이름\nplt.ylabel('GDP 성장률 (%)', fontsize=12)   # y축 이름\nplt.grid(True, axis='y', linestyle='--', alpha=0.7) # y축 그리드 추가 (선택 사항)\nplt.xticks(years) # x축 눈금을 연도별로 표시 (선택 사항)\n\nplt.show() # 그래프 보여주기\n\n연도 데이터: [2020, 2021, 2022, 2023, 2024, 2025]\n성장률 데이터: [0.5, 4.1, 2.6, 1.4, 2.2, 2.8]\n\n\n\n\n\n\n\n\n\n어떤가요? plt.plot() 함수에 연도 리스트(years)와 성장률 리스트(gdp_growth_rates)를 전달하니, 시간에 따른 성장률 변화를 보여주는 선 그래프가 멋지게 그려졌습니다!\n핵심은 이것입니다:\n\n시간 순서대로 변화하는 데이터(시계열 데이터)는 리스트에 담아 관리하는 것이 자연스럽습니다.\n시각화 라이브러리(Matplotlib)는 이렇게 리스트(또는 유사한 구조)에 담긴 데이터를 입력으로 받아 그래프를 그려줍니다.\n우리가 배운 for 반복문은 이러한 리스트 데이터를 만들거나, 가공하거나, 또는 각 데이터 포인트에 대해 특정 계산을 수행하는 데 사용될 수 있습니다. (비록 위 예제에서는 plt.plot이 내부적으로 처리하지만, 개념적으로 연결됩니다.)\n\n즉, 데이터 구조(리스트 등) + 반복문(for) + 조건문(if) 이 세 가지가 앞으로 우리가 데이터를 분석하고 시각화하는 데 있어 핵심적인 역할을 하게 될 것입니다.",
    "crumbs": [
      "Curriculum",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>4주차: 반복 작업은 컴퓨터에게! (반복문 for 와 리스트 활용)</span>"
    ]
  },
  {
    "objectID": "week4.html#마무리-및-다음-시간-예고",
    "href": "week4.html#마무리-및-다음-시간-예고",
    "title": "4  4주차: 반복 작업은 컴퓨터에게! (반복문 for 와 리스트 활용)",
    "section": "4.5 5. 마무리 및 다음 시간 예고",
    "text": "4.5 5. 마무리 및 다음 시간 예고\n오늘은 반복문(Loop), 그중에서도 for 반복문의 강력함을 확인했습니다. for 반복문을 사용하면 리스트와 같은 순회 가능한 객체의 모든 요소를 하나씩 처리하거나, range() 함수와 함께 사용하여 특정 횟수만큼 코드를 반복 실행할 수 있습니다. 반복문 내에서 합계나 평균을 계산하고, 조건문을 사용하여 데이터를 필터링하거나 카운팅하는 방법도 배웠습니다. 또한, 이러한 반복 처리 개념이 시계열 데이터 시각화와 어떻게 연결되는지 맛보았습니다.\n다음 시간에는:\n데이터를 담는 그릇(자료 구조)과 반복 처리 방법을 배웠으니, 이제 코드를 좀 더 체계적으로 관리하고 재사용하는 방법을 배울 차례입니다. 다음 주에는 함수(Function) 에 대해 배웁니다. 함수를 사용하면 특정 작업을 수행하는 코드 묶음에 이름을 붙여두고, 필요할 때마다 그 이름만 호출하여 코드를 실행할 수 있습니다. 함수를 통해 우리는 코드를 훨씬 더 깔끔하고, 효율적이며, 재사용하기 쉽게 만들 수 있습니다. 더불어, 딕셔너리에 대해서도 조금 더 깊이 알아보는 시간을 가질 수 있습니다.",
    "crumbs": [
      "Curriculum",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>4주차: 반복 작업은 컴퓨터에게! (반복문 for 와 리스트 활용)</span>"
    ]
  },
  {
    "objectID": "week4.html#네-번째-주차-과제",
    "href": "week4.html#네-번째-주차-과제",
    "title": "4  4주차: 반복 작업은 컴퓨터에게! (반복문 for 와 리스트 활용)",
    "section": "4.6 네 번째 주차 과제",
    "text": "4.6 네 번째 주차 과제\n오늘 배운 for 반복문과 range() 함수를 연습하기 위해 다음 과제를 Colab에서 새 노트(Week4_Assignment.ipynb 등)에 풀어보세요.\n\n리스트 합계 및 평균 계산: monthly_sales = [1500, 1750, 1600, 1800, 1950, 2100] (단위: 만 원) 리스트가 주어졌을 때, for 반복문을 사용하여 6개월간의 총 매출액과 월평균 매출액을 계산하여 출력하세요.\n특정 조건 만족 요소 개수 세기: 위 monthly_sales 리스트에서 월 매출액이 1700만 원 이상인 달이 총 몇 개월인지 for 반복문과 if 문을 사용하여 계산하고 출력하세요.\nrange() 활용: for 반복문과 range() 함수를 사용하여 2010년부터 2019년까지의 연도를 한 줄에 하나씩 출력하세요.\n(도전 과제) 원리금 균등 상환액 계산 시뮬레이션 (개념):\n\n1000만원을 연리 6%로 3년간 빌렸다고 가정합니다(원리금 균등 상환 방식은 복잡하므로, 여기서는 매년 말 이자만 계산하여 원금과 함께 출력하는 것을 시뮬레이션 해봅시다).\nfor 반복문과 range(3)을 사용하여 1년차, 2년차, 3년차 각각의 연말에 내야 할 이자(남은 원금 * 이자율)와 그때까지 남은 원금을 출력하세요. (원금은 변하지 않는다고 가정)\n(참고: 실제 원리금 균등 상환 계산은 훨씬 복잡하며, 여기서는 for 반복문 연습을 위한 단순화된 문제입니다.)",
    "crumbs": [
      "Curriculum",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>4주차: 반복 작업은 컴퓨터에게! (반복문 for 와 리스트 활용)</span>"
    ]
  },
  {
    "objectID": "week5.html",
    "href": "week5.html",
    "title": "5  5주차: 코드를 재사용하는 마법 (함수와 딕셔너리 활용)",
    "section": "",
    "text": "5.1 1. 함수란 무엇이고 왜 사용할까요? : 코드 재사용과 구조화\n강의 개요:\n지난 4주차에는 for 반복문을 사용하여 리스트의 모든 요소를 처리하거나 특정 작업을 여러 번 반복하는 방법을 배웠습니다. 이를 통해 우리는 데이터를 순회하며 합계나 평균을 계산하고, 조건에 맞는 데이터를 필터링하는 등 훨씬 효율적인 코드 작성이 가능해졌죠. 반복문 덕분에 코드의 길이가 획기적으로 줄어드는 것을 경험했을 겁니다.\n하지만 코드를 작성하다 보면, 반복문만으로는 해결되지 않는 또 다른 문제에 직면하게 됩니다. 바로 코드의 중복입니다. 예를 들어, 특정 계산 로직( скажем, 1인당 GDP 계산, 이익률 계산)이 프로그램의 여러 부분에서 필요할 수 있습니다. 이때마다 해당 코드를 복사해서 붙여넣는다면, 코드가 길어지고 수정이 필요할 때 모든 복사본을 찾아 고쳐야 하는 불편함이 발생합니다.\n이번 주에는 이러한 코드의 중복을 방지하고, 코드를 재사용 가능한 부품(모듈) 으로 만드는 강력한 방법인 함수(Function) 에 대해 배웁니다. 함수를 사용하면 특정 작업을 수행하는 코드 블록에 이름을 붙여두고, 필요할 때마다 그 이름만 불러서 사용할 수 있습니다. 이를 통해 코드는 훨씬 간결하고, 체계적이며, 유지보수가 쉬워집니다. (이것을 프로그래밍에서는 DRY 원칙: Don’t Repeat Yourself 라고 부르기도 합니다).\n또한, 지난주에 잠시 맛보았던 딕셔너리(Dictionary) 에 대해 좀 더 깊이 알아보고, 함수와 함께 어떻게 효과적으로 활용될 수 있는지 경제/회계 예제를 통해 살펴볼 것입니다.\n이번 시간 학습 목표:\n함수(Function) 는 특정 작업을 수행하는 독립적인 코드 블록에 이름을 붙인 것입니다. 마치 우리가 자주 사용하는 도구나 레시피에 이름을 붙여놓고 필요할 때마다 꺼내 쓰는 것과 비슷합니다.\n왜 함수를 사용할까요?",
    "crumbs": [
      "Curriculum",
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>5주차: 코드를 재사용하는 마법 (함수와 딕셔너리 활용)</span>"
    ]
  },
  {
    "objectID": "week5.html#함수란-무엇이고-왜-사용할까요-코드-재사용과-구조화",
    "href": "week5.html#함수란-무엇이고-왜-사용할까요-코드-재사용과-구조화",
    "title": "5  5주차: 코드를 재사용하는 마법 (함수와 딕셔너리 활용)",
    "section": "",
    "text": "재사용성 (Reusability): 한번 잘 만들어 둔 함수는 프로그램의 여러 곳에서 필요할 때마다 이름만 불러서(호출하여) 쉽게 재사용할 수 있습니다. 똑같은 코드를 여러 번 작성할 필요가 없어지죠.\n\n경제학 예시: 여러 국가의 1인당 GDP를 계산해야 할 때, 1인당 GDP를 계산하는 함수 calculate_gdp_per_capita() 를 한 번만 만들어 두면, 각 국가의 GDP와 인구 데이터만 바꿔 넣으면서 함수를 호출하여 쉽게 계산할 수 있습니다.\n\n코드 구조화 및 가독성 향상: 복잡한 작업을 여러 개의 작은 함수로 나누어 구현하면, 전체 코드의 구조가 명확해지고 이해하기 쉬워집니다. 각 함수는 특정 기능만 담당하므로, 코드를 읽거나 수정할 때 해당 함수만 집중해서 보면 됩니다.\n\n회계 예시: 재무제표 분석 프로그램을 만들 때, ‘매출 총이익 계산 함수’, ‘영업 이익 계산 함수’, ‘부채 비율 계산 함수’ 등으로 기능을 나누어 구현하면 전체 로직을 파악하기 쉽습니다.\n\n유지보수 용이성: 특정 기능에 수정이 필요할 때, 해당 기능을 담당하는 함수 내부만 고치면 됩니다. 함수를 사용하지 않고 코드를 복사-붙여넣기 했다면, 관련된 모든 부분을 찾아서 수정해야 하는 번거로움이 있습니다.",
    "crumbs": [
      "Curriculum",
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>5주차: 코드를 재사용하는 마법 (함수와 딕셔너리 활용)</span>"
    ]
  },
  {
    "objectID": "week5.html#함수-만들기-정의-와-사용하기-호출",
    "href": "week5.html#함수-만들기-정의-와-사용하기-호출",
    "title": "5  5주차: 코드를 재사용하는 마법 (함수와 딕셔너리 활용)",
    "section": "5.2 2. 함수 만들기 (정의) 와 사용하기 (호출)",
    "text": "5.2 2. 함수 만들기 (정의) 와 사용하기 (호출)\n함수 정의 (Defining a Function):\n파이썬에서 함수를 만들 때는 def 키워드를 사용합니다.\ndef 함수이름(매개변수1, 매개변수2, ...):\n    \"\"\"\n    이 함수는 무엇을 하는 함수인지 설명하는 공간입니다. (Docstring)\n    여러 줄로 작성할 수도 있습니다.\n    \"\"\"\n    # 함수가 수행할 코드 블록 (★반드시 들여쓰기★)\n    # ... 코드 ...\n    # [선택 사항] 결과를 반환할 때는 return 키워드 사용\n    # return 결과값\n\n\ndef: “함수를 정의(define)한다”는 키워드입니다.\n함수이름: 함수를 식별하는 이름입니다. 변수 이름 규칙과 동일하게 짓습니다 (보통 소문자 스네이크 케이스). 함수가 하는 일을 잘 나타내는 동사 형태의 이름(예: calculate_average, print_report)을 많이 사용합니다.\n매개변수(Parameter): 함수가 작업을 수행하는 데 필요한 입력값을 받는 변수입니다. 괄호 () 안에 쉼표로 구분하여 적습니다. 매개변수가 필요 없으면 ()만 씁니다. 함수 내부에서 일반 변수처럼 사용됩니다.\n콜론(:): 함수 정의부 끝에는 반드시 콜론을 붙입니다.\nDocstring (문서 문자열): 함수 정의 바로 아래 따옴표 세 개(\"\"\"Docstring\"\"\" 또는 '''Docstring''')로 감싸서 함수에 대한 설명을 적는 부분입니다. 필수는 아니지만, 함수가 어떤 기능을 하고, 어떤 매개변수를 받으며, 무엇을 반환하는지 등을 적어두면 매우 유용합니다 (협업 및 코드 유지보수에 중요!).\n함수 본문(Body): 함수가 실제로 수행할 코드를 작성하는 부분입니다. 반드시 들여쓰기 해야 합니다.\nreturn 결과값: 함수가 작업을 마친 후, 호출한 곳으로 결과를 돌려줄 때 사용합니다. return 문이 실행되면 함수는 즉시 종료되고 결과값이 반환됩니다. return 문이 없거나 return 만 쓰면 함수는 None 이라는 특별한 값을 반환합니다.\n\n함수 호출 (Calling a Function):\n함수를 정의했다고 해서 바로 실행되는 것은 아닙니다. 함수를 사용하려면 그 이름을 불러주어야(호출해야) 합니다.\n함수이름(인자1, 인자2, ...)\n\n함수이름(): 사용할 함수의 이름을 적고 괄호 ()를 붙입니다.\n인자(Argument): 함수를 호출할 때 실제로 전달하는 값입니다. 함수 정의 시 작성한 매개변수(parameter)의 순서와 개수에 맞게 전달해야 합니다.\n\n매개변수(Parameter) vs 인자(Argument):\n\n매개변수: 함수를 정의할 때 괄호 안에 적는 입력 변수 이름 (함수 내부에서 사용).\n인자: 함수를 호출할 때 괄호 안에 실제로 전달하는 값.",
    "crumbs": [
      "Curriculum",
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>5주차: 코드를 재사용하는 마법 (함수와 딕셔너리 활용)</span>"
    ]
  },
  {
    "objectID": "week5.html#간단한-함수-예제-경제회계-맥락",
    "href": "week5.html#간단한-함수-예제-경제회계-맥락",
    "title": "5  5주차: 코드를 재사용하는 마법 (함수와 딕셔너리 활용)",
    "section": "5.3 3. 간단한 함수 예제 (경제/회계 맥락)",
    "text": "5.3 3. 간단한 함수 예제 (경제/회계 맥락)\n예제 1: 두 수의 합계를 계산하여 반환하는 함수\n\ndef calculate_sum(a, b):\n  \"\"\"두 개의 숫자를 입력받아 그 합계를 반환합니다.\"\"\"\n  result = a + b\n  return result # 계산 결과를 반환\n\n# 함수 호출 및 결과 사용\nnum1 = 150\nnum2 = 350\ntotal_sum = calculate_sum(num1, num2) # a에 num1(150), b에 num2(350) 전달\n\nprint(f\"{num1}와 {num2}의 합계는 {total_sum} 입니다.\")\n\n# 다른 값으로 함수 재사용\nrevenue_q1 = 1200\nrevenue_q2 = 1500\nhalf_year_revenue = calculate_sum(revenue_q1, revenue_q2)\nprint(f\"상반기 매출 합계: {half_year_revenue}\")\n\n150와 350의 합계는 500 입니다.\n상반기 매출 합계: 2700\n\n\n예제 2: 간단한 이자 계산 함수 (결과를 print, 반환값 없음)\n\ndef print_interest(principal, rate):\n  \"\"\"원금과 이자율을 받아 이자를 계산하고 출력합니다. (반환값 없음)\"\"\"\n  interest = principal * rate\n  print(f\"원금 {principal}원에 대한 이자율 {rate*100}%의 이자는 {interest:.0f}원 입니다.\")\n  # return 문이 없으므로 None을 반환\n\n# 함수 호출\nprincipal_amount = 1000000 # 100만원\ninterest_rate = 0.04 # 4%\n\nresult_value = print_interest(principal_amount, interest_rate)\nprint(\"함수 반환값:\", result_value) # None 출력됨\n\n원금 1000000원에 대한 이자율 4.0%의 이자는 40000원 입니다.\n함수 반환값: None\n\n\n예제 3: 기본 매개변수 값을 가지는 함수 (환율 변환)\n함수를 정의할 때 매개변수에 기본값을 설정해 둘 수 있습니다. 함수 호출 시 해당 인자가 생략되면 기본값이 사용됩니다.\n\ndef convert_usd_to_krw(usd_amount, exchange_rate=1350.0):\n  \"\"\"USD 금액을 KRW로 변환합니다. 환율 미지정시 기본값 1350.0 사용.\"\"\"\n  krw_amount = usd_amount * exchange_rate\n  return krw_amount\n\n# 기본 환율(1350.0) 사용\nkrw1 = convert_usd_to_krw(100) # usd_amount에 100 전달, exchange_rate는 기본값 사용\nprint(f\"100 USD는 {krw1:.0f} KRW 입니다. (기본 환율 적용)\")\n\n# 특정 환율 지정\nkrw2 = convert_usd_to_krw(100, 1400.5) # exchange_rate에 1400.5 전달\nprint(f\"100 USD는 {krw2:.0f} KRW 입니다. (환율 1400.5 적용)\")\n\n100 USD는 135000 KRW 입니다. (기본 환율 적용)\n100 USD는 140050 KRW 입니다. (환율 1400.5 적용)",
    "crumbs": [
      "Curriculum",
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>5주차: 코드를 재사용하는 마법 (함수와 딕셔너리 활용)</span>"
    ]
  },
  {
    "objectID": "week5.html#함수로-경제-개념-표현하기",
    "href": "week5.html#함수로-경제-개념-표현하기",
    "title": "5  5주차: 코드를 재사용하는 마법 (함수와 딕셔너리 활용)",
    "section": "5.4 4. 함수로 경제 개념 표현하기",
    "text": "5.4 4. 함수로 경제 개념 표현하기\n이제 함수를 사용하여 좀 더 구체적인 경제 개념을 코드로 구현해 봅시다.\n예제 4: 수요 함수 (Linear Demand Function)\n경제학 원론에서 배우는 가장 기본적인 수요 함수 \\(Q_d = a - bP\\) 를 함수로 만들어 봅시다. (\\(Q_d\\): 수요량, \\(P\\): 가격, \\(a, b\\): 상수)\n\ndef quantity_demanded(price, a=100, b=2):\n  \"\"\"선형 수요 함수 Q_d = a - bP 에 따라 주어진 가격(price)에서의 수요량을 계산합니다.\n  a와 b는 함수의 파라미터(절편, 기울기)이며 기본값을 가집니다.\n  \"\"\"\n  # 수요량이 음수가 될 수 없으므로, 0보다 작으면 0으로 처리\n  q_d = a - b * price\n  if q_d &lt; 0:\n    return 0 # 0을 반환하고 함수 종료\n  else:\n    return q_d\n\n# 가격이 10일 때 수요량\ndemand_at_10 = quantity_demanded(10)\nprint(f\"가격이 10일 때 수요량: {demand_at_10}\") # Q_d = 100 - 2*10 = 80\n\n# 가격이 40일 때 수요량\ndemand_at_40 = quantity_demanded(40)\nprint(f\"가격이 40일 때 수요량: {demand_at_40}\") # Q_d = 100 - 2*40 = 20\n\n# 가격이 60일 때 수요량 (음수가 되지만 함수 내에서 0으로 처리됨)\ndemand_at_60 = quantity_demanded(60)\nprint(f\"가격이 60일 때 수요량: {demand_at_60}\") # Q_d = 100 - 2*60 = -20 -&gt; 0 반환\n\n# 다른 파라미터(a=120, b=3)를 가진 수요 함수\ndemand_scenario2 = quantity_demanded(15, a=120, b=3)\nprint(f\"다른 수요 함수 (a=120, b=3)에서 가격이 15일 때 수요량: {demand_scenario2}\")\n\n가격이 10일 때 수요량: 80\n가격이 40일 때 수요량: 20\n가격이 60일 때 수요량: 0\n다른 수요 함수 (a=120, b=3)에서 가격이 15일 때 수요량: 75\n\n\n예제 5: 간단한 총비용 함수 (Linear Total Cost Function)\n총비용 \\(TC = FC + VC(Q) = FC + v \\times Q\\) 를 계산하는 함수를 만들어 봅시다. (\\(TC\\): 총비용, \\(FC\\): 고정비용, \\(VC\\): 가변비용, \\(Q\\): 생산량, \\(v\\): 단위당 가변비용)\n\ndef total_cost(quantity, fixed_cost=500, variable_cost_per_unit=20):\n  \"\"\"고정비용(fixed_cost)과 단위당 가변비용(variable_cost_per_unit)을 바탕으로\n  주어진 생산량(quantity)에서의 총비용(TC)을 계산합니다.\n  \"\"\"\n  tc = fixed_cost + (variable_cost_per_unit * quantity)\n  return tc\n\n# 생산량이 100일 때 총비용\ncost_at_100 = total_cost(100)\nprint(f\"생산량이 100일 때 총비용: {cost_at_100}\") # TC = 500 + 20*100 = 2500\n\n# 생산량이 200일 때 총비용\ncost_at_200 = total_cost(200)\nprint(f\"생산량이 200일 때 총비용: {cost_at_200}\") # TC = 500 + 20*200 = 4500\n\n# 고정비용이 1000, 단위당 가변비용이 15인 다른 경우\ncost_scenario2 = total_cost(150, fixed_cost=1000, variable_cost_per_unit=15)\nprint(f\"다른 비용 구조에서 생산량 150일 때 총비용: {cost_scenario2}\")\n\n생산량이 100일 때 총비용: 2500\n생산량이 200일 때 총비용: 4500\n다른 비용 구조에서 생산량 150일 때 총비용: 3250\n\n\n예제 6: 1인당 GDP 계산 함수 (오류 처리 포함)\n\ndef calculate_gdp_per_capita(total_gdp, population):\n  \"\"\"총 GDP와 인구수를 입력받아 1인당 GDP를 계산합니다.\n  인구가 0 이하인 경우 오류를 방지하고 None을 반환합니다.\n  \"\"\"\n  if population &lt;= 0:\n    print(\"오류: 인구는 0보다 커야 합니다.\")\n    return None # 오류 발생 시 None 반환\n\n  gdp_pc = total_gdp / population\n  return gdp_pc\n\n# 한국 데이터 (예시: GDP 2200조 원, 인구 5170만 명)\nkorea_gdp = 2200 * 10**12 # 조 단위를 원 단위로\nkorea_population = 51700000\nkorea_gdp_pc = calculate_gdp_per_capita(korea_gdp, korea_population)\n\n# 반환값이 None이 아닐 경우 (즉, 계산 성공 시) 출력\nif korea_gdp_pc is not None:\n    print(f\"한국의 1인당 GDP는 약 {korea_gdp_pc:.0f} 원 입니다.\")\n\n# 인구가 0인 경우 테스트\ninvalid_result = calculate_gdp_per_capita(1000, 0)\nprint(f\"잘못된 인구 입력 시 반환값: {invalid_result}\")\n\n한국의 1인당 GDP는 약 42553191 원 입니다.\n오류: 인구는 0보다 커야 합니다.\n잘못된 인구 입력 시 반환값: None\n\n\n\n\n[실습 1] 함수 정의 및 호출 연습\n\n단순 이자 계산 함수: 원금(principal), 연 이율(rate, 소수점 형태), 기간(years, 정수)을 매개변수로 받아서 단리 이자(\\(Interest = Principal \\times Rate \\times Years\\))를 계산하여 반환하는 함수 calculate_simple_interest() 를 정의하고, 원금 1,000,000원, 연 이율 3%, 5년 기간의 이자를 계산하여 출력하세요.\n공급 함수: \\(Q_s = c + dP\\) 형태의 간단한 공급 함수를 파이썬 함수 quantity_supplied(price, c=10, d=3) 로 정의하세요. (c, d는 파라미터, 기본값 사용). 가격(P)이 20일 때의 공급량(Qs)을 계산하여 출력하세요.\n통화 변환 함수 확장: 예제 3의 convert_usd_to_krw() 함수를 참고하여, 유로(EUR)를 원화(KRW)로 변환하는 함수 convert_eur_to_krw(eur_amount, exchange_rate=1450.0) 를 정의하고, 500 유로를 기본 환율로 변환했을 때 얼마인지 계산하여 출력하세요.\n\n\n\n# 실습 1-1: 단순 이자 계산 함수\ndef calculate_simple_interest(principal, rate, years):\n  \"\"\"원금, 연 이율, 기간을 받아 단리 이자를 계산하여 반환합니다.\"\"\"\n  interest = principal * rate * years\n  return interest\n\n# 함수 호출\np = 1000000\nr = 0.03\ny = 5\nsimple_interest = calculate_simple_interest(p, r, y)\nprint(f\"원금 {p}원, 연 이율 {r*100}%, {y}년 기간의 단리 이자: {simple_interest:.0f}원\")\n\n원금 1000000원, 연 이율 3.0%, 5년 기간의 단리 이자: 150000원\n\n\n\n# 실습 1-2: 공급 함수\ndef quantity_supplied(price, c=10, d=3):\n  \"\"\"선형 공급 함수 Q_s = c + dP 에 따라 주어진 가격(price)에서의 공급량을 계산합니다.\"\"\"\n  q_s = c + d * price\n  # 공급량은 보통 음수가 되지 않지만, 여기선 그대로 반환 (필요시 if q_s &lt; 0: return 0 추가)\n  return q_s\n\n# 함수 호출\nprice_p = 20\nsupply_at_20 = quantity_supplied(price_p)\nprint(f\"가격이 {price_p}일 때 공급량: {supply_at_20}\") # Q_s = 10 + 3*20 = 70\n\n가격이 20일 때 공급량: 70\n\n\n\n# 실습 1-3: 유로 -&gt; 원화 변환 함수\ndef convert_eur_to_krw(eur_amount, exchange_rate=1450.0):\n  \"\"\"EUR 금액을 KRW로 변환합니다. 환율 미지정시 기본값 1450.0 사용.\"\"\"\n  krw_amount = eur_amount * exchange_rate\n  return krw_amount\n\n# 함수 호출\neur_value = 500\nkrw_converted = convert_eur_to_krw(eur_value)\nprint(f\"{eur_value} EUR는 {krw_converted:.0f} KRW 입니다. (기본 환율 적용)\")\n\n500 EUR는 725000 KRW 입니다. (기본 환율 적용)",
    "crumbs": [
      "Curriculum",
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>5주차: 코드를 재사용하는 마법 (함수와 딕셔너리 활용)</span>"
    ]
  },
  {
    "objectID": "week5.html#함수와-찰떡궁합-딕셔너리-활용-심화",
    "href": "week5.html#함수와-찰떡궁합-딕셔너리-활용-심화",
    "title": "5  5주차: 코드를 재사용하는 마법 (함수와 딕셔너리 활용)",
    "section": "5.5 5. 함수와 찰떡궁합: 딕셔너리 활용 심화",
    "text": "5.5 5. 함수와 찰떡궁합: 딕셔너리 활용 심화\n함수는 종종 여러 관련 데이터를 담고 있는 딕셔너리와 함께 사용될 때 더욱 강력해집니다. 딕셔너리를 함수의 인자로 넘겨주거나, 함수가 처리 결과를 딕셔너리 형태로 반환할 수 있습니다.\n딕셔너리를 함수 인자로 사용하기:\n예제 7: 기업 재무 정보 분석 함수\n지난주에 만들었던 기업 재무 정보 딕셔너리를 받아서, 주요 지표를 계산하고 출력하는 함수를 만들어 봅시다.\n\ndef analyze_financials(financial_dict):\n  \"\"\"기업 재무 정보 딕셔너리를 받아 주요 지표를 분석하고 출력합니다.\"\"\"\n  print(f\"--- {financial_dict.get('회사명', '정보 없음')} 재무 분석 ---\") # .get() 메소드는 키가 없을 때 기본값 반환\n\n  revenue = financial_dict.get(\"매출액(억 원)\", 0)\n  operating_profit = financial_dict.get(\"영업이익(억 원)\", 0)\n  # ... (다른 필요한 값들도 .get()으로 안전하게 가져오기)\n\n  print(f\"매출액: {revenue} 억 원\")\n  print(f\"영업이익: {operating_profit} 억 원\")\n\n  # 영업 이익률 계산 및 출력\n  if revenue &gt; 0:\n    margin = (operating_profit / revenue) * 100\n    print(f\"영업 이익률: {margin:.2f}%\")\n  else:\n    print(\"영업 이익률: 계산 불가 (매출액 0)\")\n\n  # 필요하다면 다른 지표 분석 추가...\n  # 부채비율 등...\n\n# 분석할 딕셔너리 데이터\ncompany_a_finance = {\n    \"회사명\": \"가나다 기업\",\n    \"매출액(억 원)\": 850,\n    \"영업이익(억 원)\": 120.5,\n    \"부채비율(%)\": 75.3\n}\ncompany_b_finance = {\n    \"회사명\": \"XYZ 물산\",\n    \"매출액(억 원)\": 620,\n    # 영업이익 정보 누락 가정\n    \"부채비율(%)\": 185.2\n}\n\n# 함수 호출 (각 회사 딕셔너리 전달)\nanalyze_financials(company_a_finance)\nprint(\"-\" * 20) # 구분선\nanalyze_financials(company_b_finance)\n\n--- 가나다 기업 재무 분석 ---\n매출액: 850 억 원\n영업이익: 120.5 억 원\n영업 이익률: 14.18%\n--------------------\n--- XYZ 물산 재무 분석 ---\n매출액: 620 억 원\n영업이익: 0 억 원\n영업 이익률: 0.00%\n\n\n.get(key, default_value) 메소드는 딕셔너리에 해당 key가 없을 경우 오류를 내는 대신 default_value(지정 안하면 None)를 반환하여 좀 더 안전하게 값을 가져올 수 있습니다.\n함수에서 딕셔너리 반환하기:\n예제 8: GDP 구성 요소 계산 및 딕셔너리 반환\n소비(C), 투자(I), 정부지출(G), 순수출(NX) 값을 받아서, 각 구성요소와 총 GDP를 포함하는 딕셔너리를 반환하는 함수를 만들어 봅시다.\n\ndef calculate_gdp_components(c, i, g, nx):\n  \"\"\"소비(c), 투자(i), 정부지출(g), 순수출(nx) 값을 받아\n  각 구성요소와 총 GDP를 포함하는 딕셔너리를 반환합니다.\n  \"\"\"\n  total_gdp = c + i + g + nx\n  gdp_dict = {\n      \"소비(C)\": c,\n      \"투자(I)\": i,\n      \"정부지출(G)\": g,\n      \"순수출(NX)\": nx,\n      \"총 GDP(Y)\": total_gdp\n  }\n  return gdp_dict\n\n# 함수 호출 및 결과(딕셔너리) 받기\nconsumption = 1200.0\ninvestment = 400.5\ngovernment_spending = 550.0\nnet_exports = -50.8 # 순수출은 음수일 수도 있음\n\ngdp_result_dict = calculate_gdp_components(consumption, investment, government_spending, net_exports)\n\nprint(\"GDP 구성요소 및 총 GDP:\")\n# print(gdp_result_dict) # 딕셔너리 전체 출력\n\n# 결과 딕셔너리를 보기 좋게 출력 (딕셔너리 순회 활용)\nfor key, value in gdp_result_dict.items():\n    print(f\"  {key}: {value}\")\n\n# 특정 값 접근\nprint(f\"\\n계산된 총 GDP: {gdp_result_dict['총 GDP(Y)']}\")\n\nGDP 구성요소 및 총 GDP:\n  소비(C): 1200.0\n  투자(I): 400.5\n  정부지출(G): 550.0\n  순수출(NX): -50.8\n  총 GDP(Y): 2099.7\n\n계산된 총 GDP: 2099.7\n\n\n딕셔너리 순회 (Iteration):\n딕셔너리에 있는 모든 키-값 쌍을 처리해야 할 때 for 반복문을 사용할 수 있습니다. .items() 메소드를 사용하면 편리합니다.\n\nfor key in my_dict:: 딕셔너리의 키(key)들을 순회합니다.\nfor value in my_dict.values():: 딕셔너리의 값(value)들을 순회합니다.\nfor key, value in my_dict.items():: 딕셔너리의 키-값 쌍(pair)을 순회합니다. 각 반복마다 key 변수에는 키가, value 변수에는 해당 값이 담깁니다. (가장 유용!)\n\n예제 9: 딕셔너리 순회하며 출력하기\n\nexchange_rates = {\"USD\": 1350.0, \"EUR\": 1450.0, \"JPY\": 9.5}\n\nprint(\"\\n--- 주요 통화 환율 정보 (키-값 순회) ---\")\nfor currency_code, rate in exchange_rates.items():\n    print(f\"통화: {currency_code}, 1 단위당 원화: {rate} KRW\")\n\nprint(\"\\n--- 환율 값만 출력 (값 순회) ---\")\nfor rate_value in exchange_rates.values():\n    print(rate_value)\n\n\n--- 주요 통화 환율 정보 (키-값 순회) ---\n통화: USD, 1 단위당 원화: 1350.0 KRW\n통화: EUR, 1 단위당 원화: 1450.0 KRW\n통화: JPY, 1 단위당 원화: 9.5 KRW\n\n--- 환율 값만 출력 (값 순회) ---\n1350.0\n1450.0\n9.5",
    "crumbs": [
      "Curriculum",
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>5주차: 코드를 재사용하는 마법 (함수와 딕셔너리 활용)</span>"
    ]
  },
  {
    "objectID": "week5.html#잠깐-순서는-있는데-수정은-안돼요-튜플-tuple---선택-사항",
    "href": "week5.html#잠깐-순서는-있는데-수정은-안돼요-튜플-tuple---선택-사항",
    "title": "5  5주차: 코드를 재사용하는 마법 (함수와 딕셔너리 활용)",
    "section": "5.6 6. 잠깐! 순서는 있는데 수정은 안돼요: 튜플 (Tuple) - 선택 사항",
    "text": "5.6 6. 잠깐! 순서는 있는데 수정은 안돼요: 튜플 (Tuple) - 선택 사항\n파이썬에는 리스트와 비슷하지만 약간 다른 튜플(Tuple) 이라는 자료 구조도 있습니다.\n\n특징:\n\n순서가 있다: 리스트처럼 인덱스로 요소에 접근 가능합니다.\n변경 불가능(Immutable): ★가장 큰 차이점!★ 한번 생성되면 그 안의 요소를 바꾸거나 추가/삭제할 수 없습니다.\n\n생성: 소괄호 () 안에 요소들을 쉼표(,)로 구분하여 넣거나, 괄호 없이 쉼표로만 구분해도 됩니다. (단, 요소가 하나일 때는 (요소,) 처럼 뒤에 쉼표를 붙여야 튜플로 인식됩니다.)\n\n튜플 예제:\n\n# 튜플 생성\ncoordinates = (10, 20) # x, y 좌표\nrgb_color = 255, 0, 0 # 빨간색 (괄호 생략 가능)\nsingle_element_tuple = (2024,) # 요소 하나일 때는 쉼표 필수!\n\nprint(\"좌표 튜플:\", coordinates, type(coordinates))\nprint(\"RGB 색상 튜플:\", rgb_color, type(rgb_color))\nprint(\"단일 요소 튜플:\", single_element_tuple, type(single_element_tuple))\n\n# 인덱싱 및 슬라이싱 (리스트와 동일)\nprint(\"x 좌표:\", coordinates[0])\nprint(\"G, B 값:\", rgb_color[1:])\n\n# 요소 변경 시도 (오류 발생!)\n# coordinates[0] = 15 # TypeError 발생! 튜플은 변경 불가\n\n# 튜플은 언제 사용할까요?\n# - 함수가 여러 값을 '하나의 묶음'으로 반환할 때 (예: 최댓값과 최솟값을 함께 반환)\n# - 딕셔너리의 키(Key)로 사용될 때 (키는 변경 불가능해야 하므로)\n# - 값이 절대 바뀌면 안 되는 고정된 목록을 표현할 때 (예: 함수의 고정 파라미터 세트)\n# - 리스트보다 약간 더 빠르거나 메모리를 적게 사용하는 경우가 있음 (미미한 차이)\n\n좌표 튜플: (10, 20) &lt;class 'tuple'&gt;\nRGB 색상 튜플: (255, 0, 0) &lt;class 'tuple'&gt;\n단일 요소 튜플: (2024,) &lt;class 'tuple'&gt;\nx 좌표: 10\nG, B 값: (0, 0)\n\n\n튜플은 리스트만큼 자주 사용되지는 않지만, ’변경 불가능’이라는 특성 때문에 특정 상황에서 유용하게 쓰입니다. 지금은 이런 것이 있다는 정도만 알아두세요.\n\n\n[실습 2] 딕셔너리와 튜플 연습\n\n학생 정보 딕셔너리 함수: 학생의 이름(str), 전공(str), 평점(float)을 키로 가지는 딕셔너리를 인자로 받아서, “이름: [이름], 전공: [전공], 평점: [평점]” 형식으로 정보를 출력하는 함수 print_student_info(student_dict) 를 정의하세요. 그리고 아래 student_A 딕셔너리를 사용하여 함수를 호출해보세요. student_A = {\"이름\": \"김민수\", \"전공\": \"경제학과\", \"평점\": 3.85}\n딕셔너리 순회: stock_portfolio = {\"삼성전자\": 100, \"카카오\": 50, \"현대차\": 30} 딕셔너리가 주어졌을 때 (값은 보유 주식 수), for 반복문과 .items() 메소드를 사용하여 “종목명: 보유량 주” 형식으로 각 종목과 보유량을 출력하세요.\n(선택) 튜플 생성: 위도와 경도를 나타내는 (37.5665, 126.9780) 튜플을 seoul_location 변수에 저장하고, 첫 번째 요소(위도)를 출력하세요.\n\n\n\n# 실습 2-1: 학생 정보 출력 함수\ndef print_student_info(student_dict):\n  \"\"\"학생 정보 딕셔너리를 받아 정보를 출력합니다.\"\"\"\n  name = student_dict.get(\"이름\", \"정보 없음\")\n  major = student_dict.get(\"전공\", \"정보 없음\")\n  gpa = student_dict.get(\"평점\", \"정보 없음\")\n  print(f\"이름: {name}, 전공: {major}, 평점: {gpa}\")\n\nstudent_A = {\"이름\": \"김민수\", \"전공\": \"경제학과\", \"평점\": 3.85}\nprint_student_info(student_A)\n\n이름: 김민수, 전공: 경제학과, 평점: 3.85\n\n\n\n# 실습 2-2: 포트폴리오 딕셔너리 순회\nstock_portfolio = {\"삼성전자\": 100, \"카카오\": 50, \"현대차\": 30}\nprint(\"--- 보유 주식 현황 ---\")\nfor stock_name, quantity in stock_portfolio.items():\n    print(f\"{stock_name}: {quantity} 주\")\n\n--- 보유 주식 현황 ---\n삼성전자: 100 주\n카카오: 50 주\n현대차: 30 주\n\n\n\n# 실습 2-3 (선택): 튜플 생성 및 접근\nseoul_location = (37.5665, 126.9780)\nprint(\"서울 위치 튜플:\", seoul_location)\nprint(\"위도:\", seoul_location[0])\n\n서울 위치 튜플: (37.5665, 126.978)\n위도: 37.5665",
    "crumbs": [
      "Curriculum",
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>5주차: 코드를 재사용하는 마법 (함수와 딕셔너리 활용)</span>"
    ]
  },
  {
    "objectID": "week5.html#sec-function-visualization",
    "href": "week5.html#sec-function-visualization",
    "title": "5  5주차: 코드를 재사용하는 마법 (함수와 딕셔너리 활용)",
    "section": "5.7 7. 함수와 시각화의 만남 : 함수로 그린 수요 곡선",
    "text": "5.7 7. 함수와 시각화의 만남 : 함수로 그린 수요 곡선\n함수는 단순히 계산만 하는 것이 아니라, 데이터를 생성하는 역할도 할 수 있습니다. 그리고 이렇게 생성된 데이터를 시각화하면 경제 이론을 눈으로 확인할 수 있게 됩니다!\n앞서 만들었던 수요 함수 quantity_demanded(price, a=100, b=2) 를 이용하여 여러 가격 지점에서의 수요량을 계산하고, 이를 선 그래프로 그려서 우하향하는 수요 곡선을 직접 확인해 봅시다.\n\n# --- 함수와 시각화 연결 맛보기 ---\nimport matplotlib.pyplot as plt\nimport platform # 이전 셀들에서 import 되었다고 가정\n\n# 한글 폰트 설정 (이전 셀들에서 실행되었다고 가정)\ntry:\n    if platform.system() == 'Linux': plt.rc('font', family='NanumBarunGothic')\n    elif platform.system() == 'Windows': plt.rc('font', family='Malgun Gothic')\n    elif platform.system() == 'Darwin': plt.rc('font', family='AppleGothic')\nexcept NameError: pass # plt가 import 안된 경우 무시\nexcept FileNotFoundError: print(\"한글 폰트를 찾을 수 없습니다.\")\nplt.rcParams['axes.unicode_minus'] = False\n\n# 수요 함수 정의 (앞선 예제와 동일)\ndef quantity_demanded(price, a=100, b=2):\n  q_d = a - b * price\n  return max(0, q_d) # 음수일 경우 0 반환 (max 함수 사용)\n\n# --- 데이터 생성 (함수와 반복문 활용) ---\n# 다양한 가격대를 리스트로 준비 (예: 0부터 50까지 5단위)\nprices = list(range(0, 51, 5)) # 0, 5, 10, ..., 50\nquantities = [] # 해당 가격에서의 수요량을 저장할 빈 리스트\n\n# 각 가격에 대해 수요량 계산 함수를 호출하고 결과를 리스트에 추가\nfor p in prices:\n    q = quantity_demanded(p) # 함수 호출!\n    quantities.append(q)\n\nprint(\"가격 리스트:\", prices)\nprint(\"수요량 리스트:\", quantities)\n\n# --- 시각화 (생성된 데이터 사용) ---\nplt.figure(figsize=(8, 6))\nplt.plot(prices, quantities, marker='o', color='crimson') # 가격(x축), 수요량(y축)으로 선 그래프\n\nplt.title('수요 곡선 (Demand Curve)', fontsize=15)\nplt.xlabel('가격 (Price)', fontsize=12)\nplt.ylabel('수요량 (Quantity Demanded)', fontsize=12)\nplt.grid(True, linestyle='--', alpha=0.6)\n\nplt.show()\n\n가격 리스트: [0, 5, 10, 15, 20, 25, 30, 35, 40, 45, 50]\n수요량 리스트: [100, 90, 80, 70, 60, 50, 40, 30, 20, 10, 0]\n\n\n\n\n\n\n\n\n\n결과를 보세요! 우리가 정의한 간단한 quantity_demanded 함수와 for 반복문을 이용해 여러 가격 지점에서의 수요량 데이터를 생성했고, 이 데이터를 Matplotlib을 이용해 그래프로 그리니 경제학 교과서에서 보던 우하향하는 수요 곡선이 나타났습니다!\n이것이 바로 함수와 프로그래밍을 통해 경제 이론을 현실적xx인 데이터와 시각화로 연결하는 강력한 예시입니다. 함수로 경제 모델을 표현하고, 반복문으로 데이터를 생성하며, 시각화 도구로 그 결과를 분석하는 이 과정이 앞으로 우리가 파이썬으로 경제 분석을 하는 핵심적인 흐름이 될 것입니다.",
    "crumbs": [
      "Curriculum",
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>5주차: 코드를 재사용하는 마법 (함수와 딕셔너리 활용)</span>"
    ]
  },
  {
    "objectID": "week5.html#마무리-및-다음-시간-예고",
    "href": "week5.html#마무리-및-다음-시간-예고",
    "title": "5  5주차: 코드를 재사용하는 마법 (함수와 딕셔너리 활용)",
    "section": "5.8 8. 마무리 및 다음 시간 예고",
    "text": "5.8 8. 마무리 및 다음 시간 예고\n이번 주에는 코드를 재사용하고 구조화하는 핵심적인 방법인 함수(Function) 에 대해 배웠습니다. 함수를 정의(def)하고 호출하는 방법, 입력을 받는 매개변수(parameter)와 결과를 돌려주는 반환값(return)의 개념을 익혔고, 이를 다양한 경제/회계 계산 함수 예제로 구현해 보았습니다. 또한, 딕셔너리를 함수와 함께 활용하고 순회하는 방법, 그리고 잠깐 튜플에 대해서도 알아보았습니다. 마지막으로 함수를 이용해 생성한 데이터를 시각화하여 이론적인 경제 개념(수요 곡선)을 눈으로 확인하는 과정까지 경험했습니다.\n다음 시간에는:\n이제 우리는 파이썬의 기본적인 데이터 타입, 자료 구조(리스트, 딕셔너리), 제어 흐름(조건문, 반복문), 그리고 코드 구조화(함수)까지 배웠습니다! 다음 주에는 이 모든 지식을 종합하여 좀 더 본격적인 경제 모델링에 적용해 볼 것입니다. 특히 경제학의 가장 기본 모델인 수요와 공급 모형을 파이썬 코드로 구현하고, 두 곡선이 만나는 시장 균형점을 찾는 방법에 대해 (개념적으로, 또는 간단한 대수적/수치적 방법으로) 알아볼 예정입니다. 필요하다면, 수치 계산에 더욱 강력한 NumPy 라이브러리를 살짝 소개할 수도 있습니다.",
    "crumbs": [
      "Curriculum",
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>5주차: 코드를 재사용하는 마법 (함수와 딕셔너리 활용)</span>"
    ]
  },
  {
    "objectID": "week5.html#다섯-번째-주차-과제",
    "href": "week5.html#다섯-번째-주차-과제",
    "title": "5  5주차: 코드를 재사용하는 마법 (함수와 딕셔너리 활용)",
    "section": "5.9 다섯 번째 주차 과제",
    "text": "5.9 다섯 번째 주차 과제\n오늘 배운 함수, 딕셔너리, (선택) 튜플을 연습하기 위해 다음 과제를 Colab에서 새 노트(Week5_Assignment.ipynb 등)에 풀어보세요.\n\n탄력성 계산 함수: 두 점 \\((P_1, Q_1)\\) 과 \\((P_2, Q_2)\\) 가 주어졌을 때, 수요의 가격 탄력성(중간점 공식)을 계산하는 함수 calculate_elasticity(p1, q1, p2, q2) 를 정의하세요.\n\n중간점 공식: \\(E_d = \\frac{(Q_2 - Q_1) / ((Q_1 + Q_2)/2)}{(P_2 - P_1) / ((P_1 + P_2)/2)}\\)\n함수는 계산된 탄력성 값(실수)을 반환해야 합니다.\n주의: 분모가 0이 되는 경우(가격 또는 수량이 변하지 않는 경우) 오류가 발생할 수 있습니다. 간단하게 if p1 == p2 or q1 == q2: 조건을 넣어 0을 반환하거나 None을 반환하도록 처리해보세요.\n함수를 호출하여 \\(P_1=10, Q_1=80\\) 과 \\(P_2=15, Q_2=60\\) 일 때의 탄력성을 계산하고 출력하세요.\n\n생산 함수: 간단한 콥-더글라스 생산 함수 \\(Y = A K^\\alpha L^\\beta\\) 를 계산하는 함수 cobb_douglas(capital, labor, alpha=0.3, beta=0.7, A=1) 를 정의하세요 (K: 자본, L: 노동, alpha/beta: 생산요소 탄력성, A: 총요소생산성).\n\n자본(K)이 100, 노동(L)이 200일 때, 기본 파라미터 값 (\\(\\alpha=0.3, \\beta=0.7, A=1\\))을 사용하여 총 생산량(Y)을 계산하고 출력하세요.\n\n딕셔너리 활용: 학생 정보를 담은 딕셔너리 리스트 students = [{\"name\": \"Lee\", \"major\": \"Economics\", \"gpa\": 4.1}, {\"name\": \"Park\", \"major\": \"Business\", \"gpa\": 3.7}, {\"name\": \"Choi\", \"major\": \"Economics\", \"gpa\": 3.9}] 가 있습니다.\n\nfor 반복문과 if 조건문을 사용하여 전공이 “Economics”인 학생들의 이름만 출력하세요.\n(도전) 경제학과 학생들의 평균 GPA를 계산하여 출력하세요. (힌트: 경제학과 학생의 gpa만 따로 리스트에 모아서 계산)\n\n(선택) 튜플 사용: 2023년과 2024년의 (연도, 성장률) 데이터를 각각 (2023, 1.4) 와 (2024, 2.2) 튜플로 만들고, 이 두 튜플을 요소로 가지는 리스트 growth_data 를 만드세요. 그리고 리스트의 첫 번째 요소(2023년 데이터 튜플)를 출력하세요.",
    "crumbs": [
      "Curriculum",
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>5주차: 코드를 재사용하는 마법 (함수와 딕셔너리 활용)</span>"
    ]
  },
  {
    "objectID": "week6.html",
    "href": "week6.html",
    "title": "6  6주차: 시장의 작동 원리 파헤치기 (수요와 공급 모델링 및 균형 찾기)",
    "section": "",
    "text": "6.1 1. 경제 모델링과 파이썬: 수요와 공급 복습\n강의 개요:\n지난 5주차에는 코드를 재사용하고 구조화하는 강력한 도구인 함수(Function) 에 대해 배웠습니다. 함수를 통해 우리는 수요량 계산, 비용 계산 등 특정 경제 개념이나 계산 로직을 하나의 독립된 단위로 묶을 수 있었습니다. 또한, 딕셔너리를 활용하여 구조화된 데이터를 함수와 함께 사용하는 방법도 익혔습니다.\n이번 주에는 우리가 배운 파이썬 지식, 특히 함수와 데이터 구조(리스트), 그리고 시각화(맛보기) 를 총동원하여 경제학의 가장 핵심적인 모델 중 하나인 수요와 공급 모형(Supply and Demand Model) 을 직접 구현하고 분석해 볼 것입니다. 파이썬 함수를 이용해 수요 곡선과 공급 곡선을 표현하고, 두 곡선이 만나는 시장 균형점(Market Equilibrium) 을 찾는 방법을 배웁니다. 더 나아가, 수요나 공급에 변화가 생겼을 때(곡선 이동) 시장 균형이 어떻게 변하는지 코드를 통해 시뮬레이션하고 시각적으로 확인해 보겠습니다. 이를 통해 파이썬이 어떻게 경제 모델을 분석하고 시장의 작동 원리를 이해하는 데 강력한 도구가 될 수 있는지 체감하게 될 것입니다.\n이번 시간 학습 목표:\n우리가 파이썬 프로그래밍을 배우는 중요한 이유 중 하나는 바로 경제 모델(Economic Model) 을 직접 만들고 분석하기 위해서입니다. 경제 모델은 복잡한 현실 세계를 단순화하여 경제 현상의 작동 원리를 이해하고 예측하는 데 도움을 주는 틀입니다.\n그중에서도 수요와 공급 모델은 미시경제학의 가장 기본적이면서도 중요한 모델입니다.\n이제 파이썬을 이용해 이 모델을 어떻게 표현하고 분석할 수 있는지 살펴봅시다.",
    "crumbs": [
      "Curriculum",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>6주차: 시장의 작동 원리 파헤치기 (수요와 공급 모델링 및 균형 찾기)</span>"
    ]
  },
  {
    "objectID": "week6.html#경제-모델링과-파이썬-수요와-공급-복습",
    "href": "week6.html#경제-모델링과-파이썬-수요와-공급-복습",
    "title": "6  6주차: 시장의 작동 원리 파헤치기 (수요와 공급 모델링 및 균형 찾기)",
    "section": "",
    "text": "수요(Demand): 특정 가격 수준에서 소비자들이 원하는 재화나 서비스의 양입니다. 일반적으로 가격이 오르면 수요량은 감소하고, 가격이 내리면 수요량은 증가합니다 (수요의 법칙, Law of Demand). 이는 보통 우하향하는 수요 곡선으로 표현됩니다.\n공급(Supply): 특정 가격 수준에서 생산자들이 판매하려는 재화나 서비스의 양입니다. 일반적으로 가격이 오르면 공급량은 증가하고, 가격이 내리면 공급량은 감소합니다 (공급의 법칙, Law of Supply). 이는 보통 우상향하는 공급 곡선으로 표현됩니다.\n시장 균형(Market Equilibrium): 수요량과 공급량이 일치하는 지점입니다 (\\(Q_d = Q_s\\)). 이 지점에서의 가격을 균형 가격(\\(P^*\\)), 거래량을 균형 거래량(\\(Q^*\\)) 이라고 합니다. 시장은 보이지 않는 손에 의해 이 균형점을 향해 움직이는 경향이 있습니다.",
    "crumbs": [
      "Curriculum",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>6주차: 시장의 작동 원리 파헤치기 (수요와 공급 모델링 및 균형 찾기)</span>"
    ]
  },
  {
    "objectID": "week6.html#수요와-공급-함수-정의하기-파이썬-함수-활용",
    "href": "week6.html#수요와-공급-함수-정의하기-파이썬-함수-활용",
    "title": "6  6주차: 시장의 작동 원리 파헤치기 (수요와 공급 모델링 및 균형 찾기)",
    "section": "6.2 2. 수요와 공급 함수 정의하기 (파이썬 함수 활용)",
    "text": "6.2 2. 수요와 공급 함수 정의하기 (파이썬 함수 활용)\n지난주에 함수를 배웠으니, 수요량과 공급량을 계산하는 함수를 만들어 봅시다. 가장 간단한 형태인 선형(Linear) 함수를 사용하겠습니다.\n\n선형 수요 함수: \\(Q_d = a - bP\\)\n\n\\(Q_d\\): 수요량\n\\(P\\): 가격\n\\(a\\): 수요 곡선의 y절편 (가격이 0일 때 수요량, \\(a &gt; 0\\)). 소득, 취향 등 가격 외 요인 변화 시 \\(a\\) 값 변동.\n\\(b\\): 수요 곡선 기울기의 절댓값 (\\(b &gt; 0\\)). 가격 변화에 대한 수요량의 민감도.\n\n선형 공급 함수: \\(Q_s = c + dP\\)\n\n\\(Q_s\\): 공급량\n\\(P\\): 가격\n\\(c\\): 공급 곡선의 y절편 (가격이 0일 때 공급량, \\(c\\)는 양수, 0, 또는 음수일 수 있음. 생산 기술, 요소 가격 등 가격 외 요인 변화 시 \\(c\\) 값 변동).\n\\(d\\): 공급 곡선의 기울기 (\\(d &gt; 0\\)). 가격 변화에 대한 공급량의 민감도.\n\n\n이제 이 함수들을 파이썬 코드로 정의해 봅시다.\n\ndef quantity_demanded(price, a, b):\n  \"\"\"선형 수요 함수 Q_d = a - bP 를 계산합니다.\"\"\"\n  # 가격이나 파라미터가 음수가 되는 비현실적인 경우를 고려할 수 있으나, 여기서는 단순화\n  if b &lt;= 0:\n      print(\"오류: 수요 곡선 기울기(b)는 양수여야 합니다.\")\n      return None\n  q_d = a - b * price\n  return max(0, q_d) # 수요량은 0 이상이어야 함\n\ndef quantity_supplied(price, c, d):\n  \"\"\"선형 공급 함수 Q_s = c + dP 를 계산합니다.\"\"\"\n  if d &lt;= 0:\n      print(\"오류: 공급 곡선 기울기(d)는 양수여야 합니다.\")\n      return None\n  q_s = c + d * price\n  return max(0, q_s) # 공급량은 0 이상이어야 함\n\n# 예시 파라미터 설정 (가상 시장)\n# 수요: Qd = 100 - 2P\ndemand_a = 100\ndemand_b = 2\n# 공급: Qs = 10 + 3P\nsupply_c = 10\nsupply_d = 3\n\n# 특정 가격에서 수요량 및 공급량 계산 테스트\ntest_price = 15\nqd_at_15 = quantity_demanded(test_price, demand_a, demand_b)\nqs_at_15 = quantity_supplied(test_price, supply_c, supply_d)\n\nprint(f\"가격이 {test_price}일 때:\")\nprint(f\"  수요량(Qd): {qd_at_15}\") # 100 - 2*15 = 70\nprint(f\"  공급량(Qs): {qs_at_15}\") # 10 + 3*15 = 55\n\n가격이 15일 때:\n  수요량(Qd): 70\n  공급량(Qs): 55",
    "crumbs": [
      "Curriculum",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>6주차: 시장의 작동 원리 파헤치기 (수요와 공급 모델링 및 균형 찾기)</span>"
    ]
  },
  {
    "objectID": "week6.html#시장-균형-찾기-대수적-방법",
    "href": "week6.html#시장-균형-찾기-대수적-방법",
    "title": "6  6주차: 시장의 작동 원리 파헤치기 (수요와 공급 모델링 및 균형 찾기)",
    "section": "6.3 3. 시장 균형 찾기 (대수적 방법)",
    "text": "6.3 3. 시장 균형 찾기 (대수적 방법)\n시장 균형은 수요량(\\(Q_d\\))과 공급량(\\(Q_s\\))이 같아지는 지점입니다. 즉, \\(Q_d = Q_s\\) 를 만족하는 가격(\\(P^*\\))과 거래량(\\(Q^*\\))을 찾는 것입니다.\n선형 함수의 경우, 이 방정식을 \\(P\\)에 대해 풀면 균형 가격 \\(P^*\\)를 구할 수 있습니다.\n\\(Q_d = a - bP\\) \\(Q_s = c + dP\\)\n균형점에서 \\(Q_d = Q_s\\) 이므로, \\(a - bP^* = c + dP^*\\) \\(a - c = bP^* + dP^*\\) \\(a - c = (b + d)P^*\\)\n따라서, 균형 가격 \\(P^*\\)는: \\(P^* = \\frac{a - c}{b + d}\\)\n균형 가격 \\(P^*\\)를 구한 뒤, 이를 수요 함수나 공급 함수 중 하나에 대입하면 균형 거래량 \\(Q^*\\)를 얻을 수 있습니다. \\(Q^* = a - bP^*\\) 또는 \\(Q^* = c + dP^*\\)\n주의: * 분모 \\((b + d)\\) 가 0이 되면 안 됩니다. (보통 \\(b&gt;0, d&gt;0\\) 이므로 이 경우는 드뭅니다.) * 계산된 \\(P^*\\) 또는 \\(Q^*\\) 가 음수가 나오면, 해당 시장에서는 (주어진 함수 형태 하에서) 경제적으로 의미 있는 균형이 존재하지 않을 수 있습니다.\n이제 이 계산 과정을 파이썬 함수로 만들어 봅시다.\n\ndef find_equilibrium(a, b, c, d):\n  \"\"\"선형 수요(Qd=a-bP)와 공급(Qs=c+dP) 함수의 파라미터를 받아\n  균형 가격(P*)과 균형 거래량(Q*)을 계산하여 튜플로 반환합니다.\n  균형이 없거나 계산할 수 없는 경우 None을 반환합니다.\n  \"\"\"\n  # 파라미터 유효성 검사 (기울기는 양수여야 함)\n  if b &lt;= 0 or d &lt;= 0:\n    print(\"오류: 수요/공급 곡선 기울기(b, d)는 양수여야 합니다.\")\n    return None\n\n  # 분모 (b+d)가 0인지 확인 (이론상 발생하기 어려움)\n  if (b + d) == 0:\n    print(\"오류: 수요와 공급 곡선 기울기 합이 0입니다. 균형 계산 불가.\")\n    return None\n\n  # 균형 가격 계산\n  p_star = (a - c) / (b + d)\n\n  # 균형 가격이 음수이면 의미 있는 균형 없음\n  if p_star &lt; 0:\n    print(\"계산된 균형 가격이 음수입니다. 시장 균형이 존재하지 않을 수 있습니다.\")\n    return None\n\n  # 균형 거래량 계산 (수요 함수 사용)\n  q_star = quantity_demanded(p_star, a, b) # 앞서 정의한 함수 사용\n  # 또는 q_star = quantity_supplied(p_star, c, d) 사용해도 결과는 동일 (오차 제외)\n\n  # 균형 거래량이 (계산 오차 감안하여) 0보다 작은 경우도 체크 가능\n  # if q_star &lt; -1e-9: # 아주 작은 음수까지는 허용 (부동소수점 오차)\n  #     print(\"계산된 균형 거래량이 음수입니다. 시장 균형이 존재하지 않을 수 있습니다.\")\n  #     return None\n\n  return p_star, q_star # 균형 가격과 균형 거래량을 튜플로 반환\n\n# 앞서 설정한 파라미터로 균형점 찾기\n# Qd = 100 - 2P, Qs = 10 + 3P\nequilibrium = find_equilibrium(demand_a, demand_b, supply_c, supply_d)\n\n# 결과 출력\nif equilibrium: # 반환값이 None이 아닐 경우 (즉, 균형점을 찾은 경우)\n    p_eq, q_eq = equilibrium # 튜플 언패킹 (결과를 각 변수에 할당)\n    print(f\"\\n--- 시장 균형점 ---\")\n    print(f\"균형 가격 (P*): {p_eq:.2f}\") # P* = (100-10)/(2+3) = 90/5 = 18\n    print(f\"균형 거래량 (Q*): {q_eq:.2f}\") # Q* = 100 - 2*18 = 64 (또는 10 + 3*18 = 64)\nelse:\n    print(\"\\n시장 균형점을 찾을 수 없습니다.\")\n\n\n--- 시장 균형점 ---\n균형 가격 (P*): 18.00\n균형 거래량 (Q*): 64.00",
    "crumbs": [
      "Curriculum",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>6주차: 시장의 작동 원리 파헤치기 (수요와 공급 모델링 및 균형 찾기)</span>"
    ]
  },
  {
    "objectID": "week6.html#눈으로-보는-시장-균형-수요와-공급-그래프-그리기",
    "href": "week6.html#눈으로-보는-시장-균형-수요와-공급-그래프-그리기",
    "title": "6  6주차: 시장의 작동 원리 파헤치기 (수요와 공급 모델링 및 균형 찾기)",
    "section": "6.4 4. 눈으로 보는 시장 균형: 수요와 공급 그래프 그리기",
    "text": "6.4 4. 눈으로 보는 시장 균형: 수요와 공급 그래프 그리기\n수요/공급 곡선과 균형점을 그래프로 시각화하면 시장의 작동 원리를 훨씬 직관적으로 이해할 수 있습니다. matplotlib 라이브러리를 사용하여 그래프를 그려봅시다.\n경제학 그래프 vs 일반 그래프: 보통 수학이나 프로그래밍에서는 x축을 가로, y축을 세로로 그립니다. 하지만 경제학에서는 관례적으로 가격을 세로축(y축), 수량(거래량)을 가로축(x축) 에 놓고 그립니다. 이를 반영하여 그래프를 그려보겠습니다. 즉, \\(P = f(Q)\\) 형태의 함수를 그려야 합니다.\n우리가 정의한 함수는 \\(Q = f(P)\\) 형태이므로, 그래프를 그리려면: 1. 가격(P) 범위를 정합니다. 2. 각 가격(P)에 대해 수요량(\\(Q_d\\))과 공급량(\\(Q_s\\))을 계산하여 리스트에 저장합니다. 3. 가로축에 수량 리스트, 세로축에 가격 리스트를 넣어 plt.plot() 함수를 호출합니다.\n\nimport matplotlib.pyplot as plt\nimport numpy as np # 수치 계산 및 배열 생성을 위해 NumPy 사용 (없으면 range로 대체 가능)\nimport platform\n\n# 한글 폰트 설정 (이전 셀에서 실행했다고 가정)\ntry:\n    if platform.system() == 'Linux': plt.rc('font', family='NanumBarunGothic')\n    elif platform.system() == 'Windows': plt.rc('font', family='Malgun Gothic')\n    elif platform.system() == 'Darwin': plt.rc('font', family='AppleGothic')\nexcept NameError: pass\nexcept FileNotFoundError: print(\"한글 폰트를 찾을 수 없습니다.\")\nplt.rcParams['axes.unicode_minus'] = False\n\n# --- 그래프를 위한 데이터 생성 ---\n# 파라미터 (이전 예제와 동일)\na, b = 100, 2 # Qd = 100 - 2P\nc, d = 10, 3  # Qs = 10 + 3P\n\n# 1. 가격(P) 범위 설정 (균형 가격 근처 포함하도록)\n# NumPy의 linspace(시작, 끝, 개수) 사용하면 편리. 또는 list(range(...)) 활용 가능\np_max_demand = a / b # 수요량이 0이 되는 가격 (100/2 = 50)\nprice_range = np.linspace(0, p_max_demand, 50) # 0부터 50까지 50개 가격 생성\n# 만약 NumPy가 없다면: price_range = list(range(0, 51, 1)) # 0부터 50까지 1단위 가격\n\n# 2. 각 가격에 대한 수요량(Qd) 및 공급량(Qs) 계산\nqd_values = [quantity_demanded(p, a, b) for p in price_range]\nqs_values = [quantity_supplied(p, c, d) for p in price_range]\n# 위 코드는 리스트 컴프리헨션(List Comprehension)으로, 아래 for문과 동일\n# qd_values = []\n# for p in price_range:\n#     qd_values.append(quantity_demanded(p, a, b))\n# (qs_values도 동일하게 생성 가능)\n\n# 3. 균형점 계산\nequilibrium = find_equilibrium(a, b, c, d)\nif equilibrium:\n    p_eq, q_eq = equilibrium\nelse: # 균형점 계산 실패 시 그래프에 표시하지 않음\n    p_eq, q_eq = None, None\n\n# --- 그래프 그리기 ---\nplt.figure(figsize=(10, 7))\n\n# 수요 곡선 플롯 (X축: 수량 Qd, Y축: 가격 P)\nplt.plot(qd_values, price_range, label='수요 곡선 (Demand)', color='blue')\n# 공급 곡선 플롯 (X축: 수량 Qs, Y축: 가격 P)\nplt.plot(qs_values, price_range, label='공급 곡선 (Supply)', color='red')\n\n# 균형점 표시 (균형점이 계산되었을 경우)\nif p_eq is not None and q_eq is not None:\n    plt.scatter(q_eq, p_eq, color='black', zorder=5, s=100, label=f'균형점 E ({q_eq:.1f}, {p_eq:.1f})')\n    # 균형점까지 점선 추가 (선택 사항)\n    plt.plot([q_eq, q_eq], [0, p_eq], color='grey', linestyle='--', linewidth=0.8)\n    plt.plot([0, q_eq], [p_eq, p_eq], color='grey', linestyle='--', linewidth=0.8)\n\n\n# 그래프 제목 및 축 레이블 (경제학 관례에 맞게)\nplt.title('시장 수요와 공급 곡선 및 균형점', fontsize=15)\nplt.xlabel('수량 (Quantity)', fontsize=12)\nplt.ylabel('가격 (Price)', fontsize=12)\nplt.legend() # 범례 표시\nplt.grid(True, linestyle='--', alpha=0.6) # 그리드 표시\n\n# 축 범위 설정 (0 이상으로)\nplt.xlim(left=0)\nplt.ylim(bottom=0)\n\nplt.show()\n\n\n\n\n\n\n\n\n그래프를 보면 파란색 수요 곡선과 빨간색 공급 곡선이 만나는 검은색 점이 정확히 우리가 앞에서 계산한 균형점(\\(Q^* \\approx 64, P^* = 18\\))과 일치하는 것을 확인할 수 있습니다!\n\n\n[실습 1] 균형점 계산 및 시각화\n어떤 가상 상품 시장의 수요와 공급 함수가 다음과 같다고 가정합니다. * 수요 함수: \\(Q_d = 150 - 3P\\) * 공급 함수: \\(Q_s = 30 + 2P\\)\n\n위 수요/공급 함수를 나타내는 파이썬 함수 quantity_demanded_ex1 와 quantity_supplied_ex1 을 정의하세요. (파라미터 a, b, c, d 값 확인!)\n앞서 정의한 find_equilibrium 함수를 사용하여 이 시장의 균형 가격(\\(P^*\\))과 균형 거래량(\\(Q^*\\))을 계산하고 출력하세요.\nNumPy 또는 range를 이용하여 적절한 가격 범위를 설정하고, 각 가격에 대한 수요량과 공급량 리스트를 만드세요.\nmatplotlib을 이용하여 수요 곡선과 공급 곡선을 그리고, 계산된 균형점을 그래프에 표시하세요. (X축: 수량, Y축: 가격)\n\n\n\n# 실습 1-1: 함수 정의 (기존 함수 재사용)\n# quantity_demanded 함수와 quantity_supplied 함수는 이미 위에서 정의됨\n\n# 파라미터 설정\na_ex1, b_ex1 = 150, 3\nc_ex1, d_ex1 = 30, 2\n\n\n# 실습 1-2: 균형점 계산\nequilibrium_ex1 = find_equilibrium(a_ex1, b_ex1, c_ex1, d_ex1)\n\nif equilibrium_ex1:\n    p_eq_ex1, q_eq_ex1 = equilibrium_ex1\n    print(f\"--- 실습 1 시장 균형점 ---\")\n    print(f\"균형 가격 (P*): {p_eq_ex1:.2f}\") # (150-30)/(3+2) = 120/5 = 24\n    print(f\"균형 거래량 (Q*): {q_eq_ex1:.2f}\") # 150 - 3*24 = 78 (또는 30 + 2*24 = 78)\nelse:\n    print(\"시장 균형점을 찾을 수 없습니다.\")\n\n--- 실습 1 시장 균형점 ---\n균형 가격 (P*): 24.00\n균형 거래량 (Q*): 78.00\n\n\n\n# 실습 1-3: 시각화를 위한 데이터 생성\nimport numpy as np\nimport matplotlib.pyplot as plt\n\n# a, b, c, d 값 설정 (이미 위에서 함)\n# a_ex1, b_ex1 = 150, 3\n# c_ex1, d_ex1 = 30, 2\n\n# 적절한 가격 범위 설정\np_max_demand_ex1 = a_ex1 / b_ex1\nprice_range_ex1 = np.linspace(0, p_max_demand_ex1, 50)\n\n# 수요량 및 공급량 리스트 계산\nqd_values_ex1 = [quantity_demanded(p, a_ex1, b_ex1) for p in price_range_ex1]\nqs_values_ex1 = [quantity_supplied(p, c_ex1, d_ex1) for p in price_range_ex1]\n\n# 균형점 다시 계산 (그래프 표시용)\n# equilibrium_ex1 = find_equilibrium(a_ex1, b_ex1, c_ex1, d_ex1) # 이미 위에서 함\n# p_eq_ex1, q_eq_ex1 = (None, None) # 초기화\n# if equilibrium_ex1:\n#     p_eq_ex1, q_eq_ex1 = equilibrium_ex1 # 이미 위에서 함\n\n\n# 실습 1-4: 그래프 그리기\n# 한글 폰트 설정 등은 이전 셀에서 적용되었다고 가정\n\nplt.figure(figsize=(10, 7))\nplt.plot(qd_values_ex1, price_range_ex1, label='수요 곡선 (D)', color='blue')\nplt.plot(qs_values_ex1, price_range_ex1, label='공급 곡선 (S)', color='red')\n\nif p_eq_ex1 is not None and q_eq_ex1 is not None:\n    plt.scatter(q_eq_ex1, p_eq_ex1, color='black', zorder=5, s=100, label=f'균형점 E ({q_eq_ex1:.1f}, {p_eq_ex1:.1f})')\n    plt.plot([q_eq_ex1, q_eq_ex1], [0, p_eq_ex1], color='grey', linestyle='--', linewidth=0.8)\n    plt.plot([0, q_eq_ex1], [p_eq_ex1, p_eq_ex1], color='grey', linestyle='--', linewidth=0.8)\n\nplt.title('실습 1: 시장 수요와 공급 및 균형점', fontsize=15)\nplt.xlabel('수량 (Quantity)', fontsize=12)\nplt.ylabel('가격 (Price)', fontsize=12)\nplt.legend()\nplt.grid(True, linestyle='--', alpha=0.6)\nplt.xlim(left=0)\nplt.ylim(bottom=0)\nplt.show()",
    "crumbs": [
      "Curriculum",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>6주차: 시장의 작동 원리 파헤치기 (수요와 공급 모델링 및 균형 찾기)</span>"
    ]
  },
  {
    "objectID": "week6.html#수요와-공급의-변화-분석하기-곡선-이동",
    "href": "week6.html#수요와-공급의-변화-분석하기-곡선-이동",
    "title": "6  6주차: 시장의 작동 원리 파헤치기 (수요와 공급 모델링 및 균형 찾기)",
    "section": "6.5 5. 수요와 공급의 변화 분석하기 (곡선 이동)",
    "text": "6.5 5. 수요와 공급의 변화 분석하기 (곡선 이동)\n수요와 공급 곡선은 고정된 것이 아니라, 가격 외 다른 요인들에 의해 이동(shift) 할 수 있습니다.\n\n수요 곡선 이동 요인: 소득 변화, 연관재 가격 변화, 소비자의 취향 변화, 미래 가격 예상 변화, 인구 변화 등\n공급 곡선 이동 요인: 기술 발전, 생산 요소 가격 변화, 정부 정책(세금, 보조금), 미래 가격 예상 변화, 공급자 수 변화 등\n\n파이썬 함수를 이용하면 이러한 변화를 파라미터 수정으로 쉽게 반영하고, 새로운 균형점을 계산하며 시각화를 통해 그 효과를 직관적으로 확인할 수 있습니다.\n예제 1: 수요 증가 시뮬레이션\n소득 증가로 인해 수요 함수의 \\(a\\) 값이 100에서 120으로 증가했다고 가정해 봅시다. (\\(Q_d = 120 - 2P\\), 공급은 \\(Q_s = 10 + 3P\\) 로 동일)\n\n# --- 수요 증가 시뮬레이션 ---\n# 원래 파라미터\na_old, b_old = 100, 2\nc_old, d_old = 10, 3\n\n# 수요 증가 후 새 파라미터 (a만 변경)\na_new = 120\nb_new = b_old # b는 그대로\nc_new, d_new = c_old, d_old # 공급은 그대로\n\n# 1. 새로운 균형점 계산\nequilibrium_new_demand = find_equilibrium(a_new, b_new, c_new, d_new)\nif equilibrium_new_demand:\n    p_eq_new_d, q_eq_new_d = equilibrium_new_demand\n    print(\"--- 수요 증가 후 새로운 균형점 ---\")\n    print(f\"새 균형 가격 (P*'): {p_eq_new_d:.2f}\") # (120-10)/(2+3) = 110/5 = 22\n    print(f\"새 균형 거래량 (Q*'): {q_eq_new_d:.2f}\") # 120 - 2*22 = 76\nelse:\n    print(\"새로운 균형점을 찾을 수 없습니다.\")\n    p_eq_new_d, q_eq_new_d = None, None # 시각화를 위해 초기화\n\n# 2. 시각화: 이전 곡선과 새 수요 곡선, 새 균형점 표시\nprice_range_shift = np.linspace(0, a_new / b_new, 50) # 새 수요에 맞춰 가격 범위 조정\nqd_values_old = [quantity_demanded(p, a_old, b_old) for p in price_range_shift]\nqs_values_shift = [quantity_supplied(p, c_new, d_new) for p in price_range_shift]\nqd_values_new = [quantity_demanded(p, a_new, b_new) for p in price_range_shift]\n\n# 원래 균형점 (위에서 계산된 값 사용)\n# p_eq, q_eq\n\nplt.figure(figsize=(10, 7))\n# 원래 수요(파선), 공급 곡선\nplt.plot(qd_values_old, price_range_shift, label='원래 수요 (D0)', color='blue', linestyle='--')\nplt.plot(qs_values_shift, price_range_shift, label='공급 (S)', color='red')\n# 새로운 수요 곡선 (실선)\nplt.plot(qd_values_new, price_range_shift, label='새로운 수요 (D1)', color='blue', linestyle='-')\n\n# 원래 균형점 표시\nif p_eq is not None and q_eq is not None:\n    plt.scatter(q_eq, p_eq, color='grey', zorder=5, s=80, label=f'원래 균형 E0 ({q_eq:.1f}, {p_eq:.1f})')\n# 새로운 균형점 표시\nif p_eq_new_d is not None and q_eq_new_d is not None:\n    plt.scatter(q_eq_new_d, p_eq_new_d, color='black', zorder=5, s=100, label=f'새 균형 E1 ({q_eq_new_d:.1f}, {p_eq_new_d:.1f})')\n\nplt.title('수요 증가 시 균형점 변화', fontsize=15)\nplt.xlabel('수량 (Quantity)', fontsize=12)\nplt.ylabel('가격 (Price)', fontsize=12)\nplt.legend()\nplt.grid(True, linestyle='--', alpha=0.6)\nplt.xlim(left=0)\nplt.ylim(bottom=0)\nplt.show()\n\n# 결과 해석\nprint(\"\\n결과 해석: 수요 증가는 균형 가격과 균형 거래량을 모두 상승시킵니다.\")\nprint(f\"(P: {p_eq:.1f} -&gt; {p_eq_new_d:.1f}), (Q: {q_eq:.1f} -&gt; {q_eq_new_d:.1f})\")\n\n--- 수요 증가 후 새로운 균형점 ---\n새 균형 가격 (P*'): 22.00\n새 균형 거래량 (Q*'): 76.00\n\n\n\n\n\n\n\n\n\n\n결과 해석: 수요 증가는 균형 가격과 균형 거래량을 모두 상승시킵니다.\n(P: 18.0 -&gt; 22.0), (Q: 64.0 -&gt; 76.0)\n\n\n그래프에서 수요 곡선이 오른쪽으로 이동(D0 -&gt; D1)하면서 균형점(E0 -&gt; E1)이 오른쪽 위로 이동하여 가격과 거래량 모두 증가하는 것을 명확히 볼 수 있습니다.\n예제 2: 공급 증가 시뮬레이션 (기술 발전)\n기술 발전으로 공급 곡선의 \\(c\\) 값이 10에서 30으로 증가했다고 가정해 봅시다. (\\(Q_s = 30 + 3P\\), 수요는 \\(Q_d = 100 - 2P\\) 로 동일)\n\n# --- 공급 증가 시뮬레이션 ---\n# 원래 파라미터\na_old, b_old = 100, 2\nc_old, d_old = 10, 3\n\n# 공급 증가 후 새 파라미터 (c만 변경)\na_new_s = a_old\nb_new_s = b_old # 수요는 그대로\nc_new_s = 30 # c 값 증가\nd_new_s = d_old # d는 그대로\n\n# 1. 새로운 균형점 계산\nequilibrium_new_supply = find_equilibrium(a_new_s, b_new_s, c_new_s, d_new_s)\nif equilibrium_new_supply:\n    p_eq_new_s, q_eq_new_s = equilibrium_new_supply\n    print(\"--- 공급 증가 후 새로운 균형점 ---\")\n    print(f\"새 균형 가격 (P*''): {p_eq_new_s:.2f}\") # (100-30)/(2+3) = 70/5 = 14\n    print(f\"새 균형 거래량 (Q*''): {q_eq_new_s:.2f}\") # 100 - 2*14 = 72\nelse:\n    print(\"새로운 균형점을 찾을 수 없습니다.\")\n    p_eq_new_s, q_eq_new_s = None, None\n\n# 2. 시각화: 이전 곡선과 새 공급 곡선, 새 균형점 표시\nprice_range_shift_s = np.linspace(0, a_new_s / b_new_s, 50)\nqd_values_shift_s = [quantity_demanded(p, a_new_s, b_new_s) for p in price_range_shift_s]\nqs_values_old = [quantity_supplied(p, c_old, d_old) for p in price_range_shift_s]\nqs_values_new = [quantity_supplied(p, c_new_s, d_new_s) for p in price_range_shift_s]\n\n# 원래 균형점 (이전 계산 값 사용)\n# p_eq, q_eq\n\nplt.figure(figsize=(10, 7))\n# 수요 곡선, 원래 공급 곡선(파선)\nplt.plot(qd_values_shift_s, price_range_shift_s, label='수요 (D)', color='blue')\nplt.plot(qs_values_old, price_range_shift_s, label='원래 공급 (S0)', color='red', linestyle='--')\n# 새로운 공급 곡선 (실선)\nplt.plot(qs_values_new, price_range_shift_s, label='새로운 공급 (S1)', color='red', linestyle='-')\n\n# 원래 균형점 표시\nif p_eq is not None and q_eq is not None:\n    plt.scatter(q_eq, p_eq, color='grey', zorder=5, s=80, label=f'원래 균형 E0 ({q_eq:.1f}, {p_eq:.1f})')\n# 새로운 균형점 표시\nif p_eq_new_s is not None and q_eq_new_s is not None:\n    plt.scatter(q_eq_new_s, p_eq_new_s, color='black', zorder=5, s=100, label=f'새 균형 E1 ({q_eq_new_s:.1f}, {p_eq_new_s:.1f})')\n\nplt.title('공급 증가 시 균형점 변화', fontsize=15)\nplt.xlabel('수량 (Quantity)', fontsize=12)\nplt.ylabel('가격 (Price)', fontsize=12)\nplt.legend()\nplt.grid(True, linestyle='--', alpha=0.6)\nplt.xlim(left=0)\nplt.ylim(bottom=0)\nplt.show()\n\n# 결과 해석\nprint(\"\\n결과 해석: 공급 증가는 균형 가격을 하락시키고 균형 거래량을 상승시킵니다.\")\nprint(f\"(P: {p_eq:.1f} -&gt; {p_eq_new_s:.1f}), (Q: {q_eq:.1f} -&gt; {q_eq_new_s:.1f})\")\n\n--- 공급 증가 후 새로운 균형점 ---\n새 균형 가격 (P*''): 14.00\n새 균형 거래량 (Q*''): 72.00\n\n\n\n\n\n\n\n\n\n\n결과 해석: 공급 증가는 균형 가격을 하락시키고 균형 거래량을 상승시킵니다.\n(P: 18.0 -&gt; 14.0), (Q: 64.0 -&gt; 72.0)\n\n\n그래프에서 공급 곡선이 오른쪽으로 이동(S0 -&gt; S1)하면서 균형점(E0 -&gt; E1)이 오른쪽 아래로 이동하여 가격은 하락하고 거래량은 증가하는 것을 명확히 볼 수 있습니다.\n\n\n[실습 2] 수요/공급 변화 분석\n실습 1의 시장(\\(Q_d = 150 - 3P\\), \\(Q_s = 30 + 2P\\))을 기준으로 다음 변화의 효과를 분석하세요.\n\n수요 감소: 소비자들의 선호도 감소로 수요 함수의 \\(a\\) 값이 150에서 120으로 감소했습니다 (\\(Q_d = 120 - 3P\\)). 공급 함수는 그대로입니다. 새로운 균형 가격과 거래량을 계산하고, 원래 균형과 비교하여 가격과 거래량이 어떻게 변했는지 설명하세요.\n(선택) 시각화: 위 수요 감소 상황을 시각화하세요. 원래 수요/공급 곡선과 변경된 수요 곡선, 그리고 원래 균형점과 새로운 균형점을 하나의 그래프에 표시하세요.\n\n\n\n힌트 템플릿\n\n# 실습 2-1: 수요 감소 후 새 균형점 계산 및 변화 설명\n# 원래 파라미터 (실습 1 기준)\na_ex1_old, b_ex1_old = 150, 3\nc_ex1_old, d_ex1_old = 30, 2\n\n# 수요 감소 후 새 파라미터\na_ex1_new = 120\nb_ex1_new = b_ex1_old\nc_ex1_new, d_ex1_new = c_ex1_old, d_ex1_old\n\n# 새로운 균형점 계산\nequilibrium_new_demand_ex1 = # find_equilibrium 호출\np_eq_new_d_ex1, q_eq_new_d_ex1 = None, None\nif equilibrium_new_demand_ex1:\n    p_eq_new_d_ex1, q_eq_new_d_ex1 = equilibrium_new_demand_ex1\n    print(\"--- 수요 감소 후 새로운 균형점 ---\")\n    # 새 균형 가격과 거래량 출력\n\n# 원래 균형점 (실습 1 정답 값 활용)\n# p_eq_ex1, q_eq_ex1 = 24, 78\n\n# 변화 설명 출력\n# 여기에 가격과 거래량이 어떻게 변했는지 설명하는 print 문 작성\n\n힌트 템플릿\n\n# 실습 2-2 (선택): 수요 감소 시각화\n# import numpy as np # 필요시\n# import matplotlib.pyplot as plt # 필요시\n\n# 파라미터 설정 (old, new)\n# ...\n\n# 가격 범위 설정\n# price_range_ex1_shift = ...\n\n# 수요/공급량 리스트 계산 (원래 S, 원래 D, 새로운 D)\n# qd_values_ex1_old = ...\n# qs_values_ex1_shift = ...\n# qd_values_ex1_new = ...\n\n# 균형점 정보 (원래, 새로운)\n# p_eq_ex1, q_eq_ex1 = ...\n# p_eq_new_d_ex1, q_eq_new_d_ex1 = ...\n\n# 그래프 그리기\n# plt.figure(...)\n# plt.plot(..., label='원래 수요 (D0)', linestyle='--')\n# plt.plot(..., label='공급 (S)', ...)\n# plt.plot(..., label='새로운 수요 (D1)', linestyle='-')\n# plt.scatter(원래 균형점)\n# plt.scatter(새로운 균형점)\n# ... (제목, 레이블, 범례, 그리드, 축 범위, show)\n\n# 실습 2-1: 수요 감소 후 새 균형점 계산 및 변화 설명\n# 원래 파라미터 (실습 1 기준)\na_ex1_old, b_ex1_old = 150, 3\nc_ex1_old, d_ex1_old = 30, 2\n\n# 수요 감소 후 새 파라미터\na_ex1_new = 120\nb_ex1_new = b_ex1_old\nc_ex1_new, d_ex1_new = c_ex1_old, d_ex1_old\n\n# 새로운 균형점 계산\nequilibrium_new_demand_ex1 = find_equilibrium(a_ex1_new, b_ex1_new, c_ex1_new, d_ex1_new)\np_eq_new_d_ex1, q_eq_new_d_ex1 = None, None\nif equilibrium_new_demand_ex1:\n    p_eq_new_d_ex1, q_eq_new_d_ex1 = equilibrium_new_demand_ex1\n    print(\"--- 수요 감소 후 새로운 균형점 ---\")\n    print(f\"새 균형 가격 (P*'): {p_eq_new_d_ex1:.2f}\") # (120-30)/(3+2) = 90/5 = 18\n    print(f\"새 균형 거래량 (Q*'): {q_eq_new_d_ex1:.2f}\") # 120 - 3*18 = 66\nelse:\n    print(\"새로운 균형점을 찾을 수 없습니다.\")\n\n# 원래 균형점 (실습 1 정답 값)\np_eq_ex1, q_eq_ex1 = 24, 78\n\n# 변화 설명 출력\nprint(\"\\n--- 균형점 변화 분석 ---\")\nif p_eq_new_d_ex1 is not None and q_eq_new_d_ex1 is not None:\n    print(\"수요 감소는 원래 균형점(P=24, Q=78)과 비교하여\")\n    print(f\"균형 가격을 {p_eq_ex1:.1f}에서 {p_eq_new_d_ex1:.1f}로 하락시키고,\")\n    print(f\"균형 거래량을 {q_eq_ex1:.1f}에서 {q_eq_new_d_ex1:.1f}로 감소시킵니다.\")\nelse:\n    print(\"원래 또는 새로운 균형점을 계산할 수 없어 변화를 분석할 수 없습니다.\")\n\n--- 수요 감소 후 새로운 균형점 ---\n새 균형 가격 (P*'): 18.00\n새 균형 거래량 (Q*'): 66.00\n\n--- 균형점 변화 분석 ---\n수요 감소는 원래 균형점(P=24, Q=78)과 비교하여\n균형 가격을 24.0에서 18.0로 하락시키고,\n균형 거래량을 78.0에서 66.0로 감소시킵니다.\n\n\n\n# 실습 2-2 (선택): 수요 감소 시각화\nimport numpy as np\nimport matplotlib.pyplot as plt\n\n# 파라미터 설정 (old, new)\na_ex1_old, b_ex1_old = 150, 3\nc_ex1_old, d_ex1_old = 30, 2\na_ex1_new = 120\nb_ex1_new = b_ex1_old\nc_ex1_new, d_ex1_new = c_ex1_old, d_ex1_old\n\n# 가격 범위 설정\np_max_demand_ex1_old = a_ex1_old / b_ex1_old\np_max_demand_ex1_new = a_ex1_new / b_ex1_new\nprice_range_ex1_shift = np.linspace(0, p_max_demand_ex1_old, 50) # 더 넓은 범위 사용\n\n# 수요/공급량 리스트 계산\nqd_values_ex1_old = [quantity_demanded(p, a_ex1_old, b_ex1_old) for p in price_range_ex1_shift]\nqs_values_ex1_shift = [quantity_supplied(p, c_ex1_new, d_ex1_new) for p in price_range_ex1_shift]\nqd_values_ex1_new = [quantity_demanded(p, a_ex1_new, b_ex1_new) for p in price_range_ex1_shift]\n\n# 균형점 정보 (원래, 새로운 - 위 셀에서 계산됨)\n# p_eq_ex1, q_eq_ex1 = 24, 78\n# p_eq_new_d_ex1, q_eq_new_d_ex1 = 18, 66\n\n# 그래프 그리기\n# 한글 폰트 설정 등은 이전에 적용되었다고 가정\nplt.figure(figsize=(10, 7))\nplt.plot(qd_values_ex1_old, price_range_ex1_shift, label='원래 수요 (D0)', color='blue', linestyle='--')\nplt.plot(qs_values_ex1_shift, price_range_ex1_shift, label='공급 (S)', color='red')\nplt.plot(qd_values_ex1_new, price_range_ex1_shift, label='새로운 수요 (D1)', color='blue', linestyle='-')\n\nif p_eq_ex1 is not None and q_eq_ex1 is not None:\n    plt.scatter(q_eq_ex1, p_eq_ex1, color='grey', zorder=5, s=80, label=f'원래 균형 E0 ({q_eq_ex1:.1f}, {p_eq_ex1:.1f})')\nif p_eq_new_d_ex1 is not None and q_eq_new_d_ex1 is not None:\n    plt.scatter(q_eq_new_d_ex1, p_eq_new_d_ex1, color='black', zorder=5, s=100, label=f'새 균형 E1 ({q_eq_new_d_ex1:.1f}, {p_eq_new_d_ex1:.1f})')\n\nplt.title('수요 감소 시 균형점 변화', fontsize=15)\nplt.xlabel('수량 (Quantity)', fontsize=12)\nplt.ylabel('가격 (Price)', fontsize=12)\nplt.legend()\nplt.grid(True, linestyle='--', alpha=0.6)\nplt.xlim(left=0)\nplt.ylim(bottom=0)\nplt.show()",
    "crumbs": [
      "Curriculum",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>6주차: 시장의 작동 원리 파헤치기 (수요와 공급 모델링 및 균형 찾기)</span>"
    ]
  },
  {
    "objectID": "week6.html#마무리-및-다음-시간-예고",
    "href": "week6.html#마무리-및-다음-시간-예고",
    "title": "6  6주차: 시장의 작동 원리 파헤치기 (수요와 공급 모델링 및 균형 찾기)",
    "section": "6.6 6. 마무리 및 다음 시간 예고",
    "text": "6.6 6. 마무리 및 다음 시간 예고\n오늘은 파이썬 함수와 기본 로직을 활용하여 경제학의 핵심 모델인 수요와 공급 모형을 구현하고 분석하는 방법을 배웠습니다. 함수로 수요와 공급 관계를 표현하고, 대수적으로 시장 균형점을 계산했으며, matplotlib을 이용해 이를 시각화하여 눈으로 확인했습니다. 또한, 수요나 공급 곡선이 이동했을 때 새로운 균형점이 어떻게 변하는지 시뮬레이션하고 그 결과를 그래프로 분석하는 과정까지 경험했습니다. 이를 통해 파이썬이 단순한 코딩 도구를 넘어, 경제 이론을 검증하고 시장 현상을 분석하는 강력한 도구가 될 수 있음을 확인하셨기를 바랍니다.\n다음 시간에는:\n이번 주까지 파이썬의 기본적인 문법과 자료 구조, 제어 흐름, 함수, 그리고 간단한 모델링 및 시각화까지 경험했습니다. 다음 주에는 본격적으로 데이터 시각화(Data Visualization) 에 초점을 맞추어 matplotlib 라이브러리의 다양한 기능을 좀 더 체계적으로 배우는 시간을 갖겠습니다. 여러 종류의 그래프(선, 막대, 산점도 등)를 그리는 방법, 그래프의 축, 제목, 범례 등을 꾸미는 방법 등을 익혀서 데이터를 더욱 효과적으로 표현하고 전달하는 능력을 키울 것입니다.",
    "crumbs": [
      "Curriculum",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>6주차: 시장의 작동 원리 파헤치기 (수요와 공급 모델링 및 균형 찾기)</span>"
    ]
  },
  {
    "objectID": "week6.html#여섯-번째-주차-과제",
    "href": "week6.html#여섯-번째-주차-과제",
    "title": "6  6주차: 시장의 작동 원리 파헤치기 (수요와 공급 모델링 및 균형 찾기)",
    "section": "6.7 여섯 번째 주차 과제",
    "text": "6.7 여섯 번째 주차 과제\n오늘 배운 수요/공급 모델링 및 분석을 연습하기 위해 다음 과제를 Colab에서 새 노트(Week6_Assignment.ipynb 등)에 풀어보세요.\n\n새로운 시장 분석: 어떤 시장의 수요 함수가 \\(Q_d = 200 - 4P\\) 이고, 공급 함수가 \\(Q_s = 50 + P\\) 라고 합니다.\n\n이 시장의 균형 가격(\\(P^*\\))과 균형 거래량(\\(Q^*\\))을 계산하세요. (함수 정의 및 find_equilibrium 활용)\n(선택) 계산된 균형점을 포함하여 수요/공급 곡선을 시각화하세요.\n\n공급 감소 분석: 위 1번 시장에서, 생산 비용 증가로 공급 함수가 \\(Q_s = 20 + P\\) 로 변했다고 가정합니다 (\\(c\\) 값이 50에서 20으로 감소). 수요 함수는 그대로입니다.\n\n새로운 균형 가격과 거래량을 계산하세요.\n공급 감소가 균형 가격과 거래량에 어떤 영향을 미쳤는지 원래 균형과 비교하여 설명하세요.\n(선택) 원래 수요/공급 곡선과 변경된 공급 곡선, 그리고 원래 균형점과 새로운 균형점을 하나의 그래프에 시각화하세요.\n\n수요/공급 동시 변화 (생각해보기): 만약 위 1번 시장에서 소득 증가로 수요가 \\(Q_d = 220 - 4P\\) 로 증가하는 동시에, 기술 발전으로 공급이 \\(Q_s = 60 + P\\) 로 증가했다면, 새로운 균형 가격과 거래량은 어떻게 변할지 계산해보고, 원래 균형과 비교하여 설명해보세요. (시각화는 선택)",
    "crumbs": [
      "Curriculum",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>6주차: 시장의 작동 원리 파헤치기 (수요와 공급 모델링 및 균형 찾기)</span>"
    ]
  },
  {
    "objectID": "week6-a.html",
    "href": "week6-a.html",
    "title": "7  보충 학습: 파이썬 스크립트와 코드 재사용 심화 (Advanced Topic)",
    "section": "",
    "text": "지금까지 우리는 주로 Colab 노트북 환경에서 코드를 작성하고 즉시 결과를 확인하는 방식으로 파이썬을 배워왔습니다. 노트북 환경은 탐색적 데이터 분석이나 학습 과정에는 매우 훌륭하지만, 실제 연구나 프로젝트에서는 다음과 같은 요구사항이 생길 수 있습니다.\n\n자동화: 매번 노트북을 열어 코드를 실행하는 것이 아니라, 특정 분석 작업을 자동으로 또는 명령 한 줄로 실행하고 싶을 때 (예: 매일 새로운 데이터를 받아 균형점을 계산하고 보고).\n코드 재사용: 우리가 만든 유용한 함수들(예: find_equilibrium)을 이번 분석뿐만 아니라, 다른 프로젝트나 다른 스크립트에서도 쉽게 가져다 쓰고 싶을 때.\n협업 및 관리: 코드가 점점 길고 복잡해질 때, 여러 개의 파일로 기능별로 나누어 관리하고 다른 사람들과 협업하고 싶을 때.\n\n이러한 요구사항을 해결하기 위해 파이썬에서는 명령줄 스크립트(Command-line Script) 와 모듈(Module)/패키지(Package) 라는 개념을 사용합니다. 오늘은 이 두 가지 개념에 대해 간단히 맛보는 시간을 갖겠습니다. (이 내용은 고급 과정이므로, 지금 당장 완벽히 이해하지 않아도 괜찮습니다!)\n\n1. 명령줄에서 파이썬 실행하기 (argparse 소개)\n우리가 작성한 파이썬 코드를 .py 라는 확장자로 저장하면, 터미널(명령 프롬프트, PowerShell 등) 환경에서 python 파일이름.py 명령으로 실행할 수 있습니다. 이것을 파이썬 스크립트라고 부릅니다.\n그런데 스크립트를 실행할 때마다 수요/공급 함수의 파라미터(a, b, c, d) 값을 코드 내부에서 직접 수정하는 것은 번거롭습니다. 스크립트를 실행하는 시점에 이 값들을 외부에서 전달해주면 훨씬 유연하겠죠? 이때 사용하는 것이 명령줄 인자(Command-line Argument) 이며, 파이썬에서는 argparse 라는 표준 라이브러리를 통해 이를 쉽게 처리할 수 있습니다.\nargparse 사용 예시 (sd_analyzer.py 가상 스크립트)\n만약 아래와 같은 내용으로 sd_analyzer.py 파일을 만들었다고 가정해 봅시다. (Colab에서는 아래 코드를 직접 실행하기보다, 이런 .py 파일을 만들 수 있다는 개념을 이해하는 것이 중요합니다.)\n\n\n파일명: sd_analyzer.py (실제 파일로 저장해야 함)\nimport argparse\n\n# --- S&D 관련 함수 정의 (또는 다른 파일에서 import) ---\n# (이 부분은 설명을 위해 간단히 다시 정의합니다. 실제로는 import 사용 권장)\ndef quantity_demanded(price, a, b):\n    if b &lt;= 0: return None\n    q_d = a - b * price\n    return max(0, q_d)\n\ndef quantity_supplied(price, c, d):\n    if d &lt;= 0: return None\n    q_s = c + d * price\n    return max(0, q_s)\n\ndef find_equilibrium(a, b, c, d):\n    if b &lt;= 0 or d &lt;= 0 or (b + d) == 0: return None\n    p_star = (a - c) / (b + d)\n    if p_star &lt; 0: return None\n    q_star = quantity_demanded(p_star, a, b)\n    # if q_star &lt; 0: return None # 필요시 추가\n    return p_star, q_star\n# --- 함수 정의 끝 ---\n\n# 1. ArgumentParser 객체 생성\nparser = argparse.ArgumentParser(description='선형 수요/공급 모델의 균형점을 계산합니다.')\n\n# 2. 명령줄 인자 정의 (--a, --b, --c, --d 라는 이름으로 인자를 받음)\n#    type=float : 입력값을 실수로 처리\n#    required=True : 필수 인자임을 명시\n#    help='...' : 도움말 메시지\nparser.add_argument('--a', type=float, required=True, help='수요 함수 절편 (Qd = a - bP)')\nparser.add_argument('--b', type=float, required=True, help='수요 함수 기울기 절대값 (Qd = a - bP)')\nparser.add_argument('--c', type=float, required=True, help='공급 함수 절편 (Qs = c + dP)')\nparser.add_argument('--d', type=float, required=True, help='공급 함수 기울기 (Qs = c + dP)')\n\n# 3. 명령줄 인자 파싱(분석)\nargs = parser.parse_args()\n\n# 4. 파싱된 인자를 사용하여 균형점 계산 함수 호출\n#    args.a, args.b 등으로 접근 가능\nequilibrium_point = find_equilibrium(args.a, args.b, args.c, args.d)\n\n# 5. 결과 출력\nif equilibrium_point:\n    p_eq, q_eq = equilibrium_point\n    print(f\"--- 계산 결과 ---\")\n    print(f\"수요 함수: Qd = {args.a} - {args.b}P\")\n    print(f\"공급 함수: Qs = {args.c} + {args.d}P\")\n    print(f\"균형 가격(P*): {p_eq:.2f}\")\n    print(f\"균형 거래량(Q*): {q_eq:.2f}\")\nelse:\n    print(\"오류: 균형점을 계산할 수 없습니다. 파라미터를 확인하세요.\")\n스크립트 실행 방법 (터미널에서):\n위 sd_analyzer.py 파일이 저장된 디렉토리에서, 터미널을 열고 다음과 같이 명령어를 입력하면 됩니다.\npython sd_analyzer.py --a 100 --b 2 --c 10 --d 3\n이렇게 하면 --a 뒤의 100이 args.a로, --b 뒤의 2가 args.b로 전달되어 코드가 실행되고 결과가 터미널에 출력됩니다. 파라미터 값을 바꿔가며 스크립트를 쉽게 재실행할 수 있습니다.\n(Colab/Jupyter 환경에서는) 위 파이썬 코드를 직접 실행하면 argparse가 명령줄 인자를 찾지 못해 오류가 발생합니다. Colab에서 명령줄 인자를 테스트하려면 특별한 방법(sys.argv 조작 등)이 필요하지만, 여기서는 “파이썬 스크립트를 만들고 명령줄에서 인자를 받아 실행할 수 있다” 는 개념을 이해하는 것이 중요합니다.\n\n\n2. 나만의 코드 모음 만들기 (모듈과 패키지 기초)\n우리가 작성한 함수들(quantity_demanded, quantity_supplied, find_equilibrium)은 다른 분석에서도 유용하게 쓰일 수 있습니다. 이 함수들을 별도의 파이썬 파일(.py)로 저장해두면, 다른 노트북이나 스크립트에서 가져와서(import) 재사용할 수 있습니다. 이렇게 재사용 가능한 코드(함수, 클래스, 변수 등)를 담고 있는 .py 파일을 모듈(Module) 이라고 부릅니다.\n모듈 만들기 (Colab에서 %%writefile 사용):\nColab에서는 %%writefile 파일이름.py 이라는 특별한 명령(Cell Magic)을 코드 셀 맨 위에 써서 해당 셀의 내용을 파이썬 파일로 저장할 수 있습니다.\n\n%%writefile market_models.py\n# 이 셀의 내용은 market_models.py 파일로 저장됩니다.\n\n\"\"\"\n시장 수요, 공급, 균형점 계산 관련 함수들을 모아놓은 모듈\n\"\"\"\n\ndef quantity_demanded(price, a, b):\n    \"\"\"선형 수요 함수 Qd = a - bP 를 계산합니다.\"\"\"\n    if b &lt;= 0:\n        # print(\"오류: 수요 곡선 기울기(b)는 양수여야 합니다.\") # 모듈에서는 print보다 오류 발생 권장\n        raise ValueError(\"수요 곡선 기울기(b)는 양수여야 합니다.\")\n    q_d = a - b * price\n    return max(0, q_d)\n\ndef quantity_supplied(price, c, d):\n    \"\"\"선형 공급 함수 Qs = c + dP 를 계산합니다.\"\"\"\n    if d &lt;= 0:\n        raise ValueError(\"공급 곡선 기울기(d)는 양수여야 합니다.\")\n    q_s = c + d * price\n    return max(0, q_s)\n\ndef find_equilibrium(a, b, c, d):\n    \"\"\"선형 수요/공급 함수의 균형 가격(P*)과 균형 거래량(Q*)을 계산하여 튜플로 반환합니다.\"\"\"\n    if b &lt;= 0 or d &lt;= 0:\n        raise ValueError(\"수요/공급 곡선 기울기(b, d)는 양수여야 합니다.\")\n    if (b + d) == 0:\n        raise ValueError(\"수요와 공급 곡선 기울기 합이 0입니다. 평행선.\")\n\n    p_star = (a - c) / (b + d)\n\n    if p_star &lt; 0:\n        # print(\"균형 가격이 음수입니다.\") # 실제 균형 없음\n        return (None, None) # 음수 가격 대신 None 반환 고려\n\n    # 균형 거래량 계산\n    q_star = quantity_demanded(p_star, a, b) # 같은 모듈 내 함수 호출\n    # if q_star &lt; 0: q_star = 0 # 필요시 음수 거래량 0 처리\n\n    return p_star, q_star\n\n# 모듈로 만들 때는 아래와 같은 직접 실행 코드는 보통 if __name__ == \"__main__\": 블록 안에 넣습니다.\n# (이 부분은 모듈로 사용될 때는 실행되지 않음)\nif __name__ == \"__main__\":\n    print(\"market_models 모듈이 직접 실행되었습니다. (테스트용)\")\n    # 간단한 테스트 코드\n    a_test, b_test = 100, 1\n    c_test, d_test = 20, 2\n    p_eq, q_eq = find_equilibrium(a_test, b_test, c_test, d_test)\n    if p_eq is not None:\n        print(f\"테스트 균형점: P*={p_eq:.2f}, Q*={q_eq:.2f}\")\n\nWriting market_models.py\n\n\n위 셀을 실행하면 Colab의 현재 작업 디렉토리에 market_models.py 파일이 생성됩니다. (왼쪽 파일 탐색기 탭에서 확인 가능)\n모듈 가져와서 사용하기 (import):\n이제 다른 코드 셀이나 다른 노트북에서 이 market_models.py 모듈을 가져와서 그 안에 정의된 함수들을 사용할 수 있습니다.\n\n# 1. 모듈 전체를 import 하기\nimport market_models\n\n# 함수 호출 시 모듈 이름을 앞에 붙여야 함\neq1 = market_models.find_equilibrium(a=100, b=2, c=10, d=3)\nif eq1[0] is not None:\n    print(f\"(import 모듈 전체) 균형 가격: {eq1[0]:.2f}, 균형 거래량: {eq1[1]:.2f}\")\n\n# 2. 모듈에서 특정 함수만 import 하기\nfrom market_models import quantity_demanded, find_equilibrium\n\n# 함수 이름으로 직접 호출 가능\nqd1 = quantity_demanded(price=15, a=100, b=2)\neq2 = find_equilibrium(a=150, b=3, c=30, d=2)\nprint(f\"(from import) 가격 15일 때 수요량: {qd1}\")\nif eq2[0] is not None:\n    print(f\"(from import) 균형 가격: {eq2[0]:.2f}, 균형 거래량: {eq2[1]:.2f}\")\n\n# 3. 모듈에 별명(alias) 붙여서 사용하기 (자주 사용됨!)\nimport market_models as mm # mm 이라는 별명으로 사용\n\neq3 = mm.find_equilibrium(a=50, b=1, c=5, d=1)\nif eq3[0] is not None:\n    print(f\"(import as 별명) 균형 가격: {eq3[0]:.2f}, 균형 거래량: {eq3[1]:.2f}\")\n\n(import 모듈 전체) 균형 가격: 18.00, 균형 거래량: 64.00\n(from import) 가격 15일 때 수요량: 70\n(from import) 균형 가격: 24.00, 균형 거래량: 78.00\n(import as 별명) 균형 가격: 22.50, 균형 거래량: 27.50\n\n\n\n\n3. 코드를 더욱 체계적으로: 패키지(Package) 구성하기\n이전 섹션에서 우리는 관련된 함수들을 하나의 .py 파일(모듈)로 묶어 재사용하는 방법을 배웠습니다 (market_models.py 예시). 프로젝트의 규모가 커지면, 단순히 모듈 하나만으로는 부족할 수 있습니다. 예를 들어, 시장 모델 자체를 정의하는 함수들, 그 모델을 분석하는 함수들, 분석 결과를 시각화하는 함수들 등 기능별로 코드를 더 세분화하여 관리하고 싶을 수 있습니다.\n이럴 때 사용하는 것이 바로 패키지(Package) 입니다. 패키지는 관련된 모듈들을 담는 디렉토리(폴더) 라고 생각할 수 있습니다. 패키지를 사용하면 다음과 같은 장점이 있습니다.\n\n계층적 구조: 관련 기능별로 하위 디렉토리를 만들어 코드를 더욱 체계적으로 구성할 수 있습니다 (예: 모델 정의는 models 폴더, 분석 코드는 analysis 폴더).\n이름 충돌 방지 (Namespace Management): 서로 다른 패키지나 모듈 안에 같은 이름의 함수가 있더라도, 패키지명.모듈명.함수명 형태로 구분하여 사용할 수 있으므로 이름 충돌을 피할 수 있습니다.\n배포 및 공유 용이: 잘 만들어진 패키지는 다른 사람들과 쉽게 공유하고 설치하여 사용할 수 있습니다 (오늘 다루지는 않지만 pip install ... 과 관련됩니다).\n\n패키지 구성의 핵심: __init__.py 파일\n파이썬이 어떤 디렉토리를 패키지로 인식하게 하려면, 그 디렉토리 안에 __init__.py 라는 이름의 특별한 파일이 반드시 있어야 합니다. 이 파일은 비어 있어도 괜찮지만, 존재 자체가 “이 디렉토리는 파이썬 패키지입니다” 라고 알려주는 역할을 합니다. (패키지 초기화 코드를 넣을 수도 있습니다.)\n예시: 수요/공급 분석 코드를 패키지로 구성하기\nWeek 6 실습 2에서는 수요 또는 공급 변화 후 새로운 균형점을 계산하고 원래 균형과 비교하는 분석을 했습니다. 이 분석 과정을 가상의 econo_analyzer 라는 패키지로 구성해 봅시다.\n패키지 구조:\necono_analyzer/              &lt;-- 최상위 패키지 디렉토리\n|-- __init__.py              &lt;-- 이 디렉토리가 패키지임을 알림\n|-- models/                  &lt;-- 모델 정의 관련 모듈들을 담을 하위 디렉토리(서브 패키지)\n|   |-- __init__.py          &lt;-- 이 디렉토리도 패키지임을 알림\n|   |-- market.py          &lt;-- 수요(Qd), 공급(Qs), 균형점(find_equilibrium) 함수 정의\n|-- analysis/                &lt;-- 분석 관련 모듈들을 담을 하위 디렉토리(서브 패키지)\n|   |-- __init__.py          &lt;-- 이 디렉토리도 패키지임을 알림\n|   |-- shifts.py          &lt;-- 수요/공급 변화(shift) 분석 함수 정의\n|-- utils/                   &lt;-- (선택 사항) 보조 기능 모듈 (예: 시각화)\n|   |-- __init__.py\n|   |-- plotting.py\n각 파일의 역할 (가상):\n\necono_analyzer/__init__.py: econo_analyzer 를 패키지로 만듭니다. (비어 있어도 됨)\necono_analyzer/models/__init__.py: models 를 서브 패키지로 만듭니다.\necono_analyzer/models/market.py: 이전 보충 자료의 market_models.py 내용과 같이 quantity_demanded, quantity_supplied, find_equilibrium 함수를 포함합니다.\necono_analyzer/analysis/__init__.py: analysis 를 서브 패키지로 만듭니다.\necono_analyzer/analysis/shifts.py: (실습 2 관련) 수요 또는 공급 변화 전후의 파라미터를 받아 두 균형점을 계산하고 비교/분석하는 함수 (예: analyze_demand_shift, analyze_supply_shift 또는 compare_equilibria)를 포함합니다.\necono_analyzer/utils/plotting.py: (선택) 수요/공급 곡선 및 균형점을 그리는 함수를 분리하여 포함할 수 있습니다.\n\nColab에서 패키지 구조 만들기 (명령어 사용):\nColab 노트북 환경에서는 실제 디렉토리와 파일을 직접 만들기 어렵기 때문에, 터미널 명령어(앞에 !를 붙여 실행)와 %%writefile 매직 명령어를 사용하여 가상으로 구조를 만들어 볼 수 있습니다.\n1단계: 디렉토리 생성\n!mkdir -p econo_analyzer/models  # econo_analyzer 디렉토리와 그 하위 models 디렉토리 생성 (-p 옵션)\n!mkdir -p econo_analyzer/analysis # econo_analyzer 하위 analysis 디렉토리 생성\n# !mkdir -p econo_analyzer/utils # 필요하다면 utils 디렉토리도 생성\n2단계: __init__.py 파일 생성 (빈 파일)\n!touch econo_analyzer/__init__.py\n!touch econo_analyzer/models/__init__.py\n!touch econo_analyzer/analysis/__init__.py\n# !touch econo_analyzer/utils/__init__.py # 필요하다면\n(!touch 명령어는 빈 파일을 생성합니다.)\n3단계: 모듈 파일 내용 작성 (%%writefile)\n\nmarket.py 파일 작성:\n\n\n%%writefile econo_analyzer/models/market.py\n# 이 셀의 내용은 econo_analyzer/models/market.py 파일로 저장됩니다.\n\n\"\"\"\n시장 수요, 공급, 균형점 계산 관련 함수들을 모아놓은 모듈\n\"\"\"\n\ndef quantity_demanded(price, a, b):\n    \"\"\"선형 수요 함수 Qd = a - bP 를 계산합니다.\"\"\"\n    if b &lt;= 0: raise ValueError(\"수요 곡선 기울기(b)는 양수여야 합니다.\")\n    q_d = a - b * price\n    return max(0, q_d)\n\ndef quantity_supplied(price, c, d):\n    \"\"\"선형 공급 함수 Qs = c + dP 를 계산합니다.\"\"\"\n    if d &lt;= 0: raise ValueError(\"공급 곡선 기울기(d)는 양수여야 합니다.\")\n    q_s = c + d * price\n    return max(0, q_s)\n\ndef find_equilibrium(a, b, c, d):\n    \"\"\"선형 수요/공급 함수의 균형 가격(P*)과 균형 거래량(Q*)을 계산하여 튜플로 반환합니다.\"\"\"\n    if b &lt;= 0 or d &lt;= 0: raise ValueError(\"수요/공급 곡선 기울기(b, d)는 양수여야 합니다.\")\n    if (b + d) == 0: raise ValueError(\"수요와 공급 곡선 기울기 합이 0입니다. 평행선.\")\n\n    p_star = (a - c) / (b + d)\n    if p_star &lt; 0: return (None, None) # 음수 가격\n\n    q_star = quantity_demanded(p_star, a, b)\n    return p_star, q_star\n\nprint(\"econo_analyzer.models.market 모듈 로드됨\") # 모듈 로드 확인용 (선택 사항)\n\nWriting econo_analyzer/models/market.py\n\n\n\nshifts.py 파일 작성 (실습 2 분석 기능 구현):\n\n\n%%writefile econo_analyzer/analysis/shifts.py\n# 이 셀의 내용은 econo_analyzer/analysis/shifts.py 파일로 저장됩니다.\n\n\"\"\"\n수요 또는 공급 변화 분석 함수 모듈\n\"\"\"\n# 다른 모듈의 함수를 사용하기 위해 import\nfrom econo_analyzer.models import market # 같은 패키지 내 models 폴더의 market 모듈 import\n\ndef compare_equilibria(params_old, params_new):\n    \"\"\"\n    변화 전후의 파라미터 딕셔너리를 받아 두 균형점을 계산하고 비교 결과를 반환합니다.\n    파라미터 딕셔너리 예시: {'a': 150, 'b': 3, 'c': 30, 'd': 2}\n    \"\"\"\n    # 원래 균형점 계산\n    p_old, q_old = market.find_equilibrium(params_old['a'], params_old['b'], params_old['c'], params_old['d'])\n\n    # 새로운 균형점 계산\n    p_new, q_new = market.find_equilibrium(params_new['a'], params_new['b'], params_new['c'], params_new['d'])\n\n    results = {\n        \"old_equilibrium\": (p_old, q_old),\n        \"new_equilibrium\": (p_new, q_new),\n    }\n\n    # 변화 설명 추가 (선택 사항)\n    if p_old is not None and p_new is not None:\n        if p_new &gt; p_old: results[\"price_change\"] = \"상승\"\n        elif p_new &lt; p_old: results[\"price_change\"] = \"하락\"\n        else: results[\"price_change\"] = \"변동 없음\"\n    else: results[\"price_change\"] = \"비교 불가\"\n\n    if q_old is not None and q_new is not None:\n        if q_new &gt; q_old: results[\"quantity_change\"] = \"증가\"\n        elif q_new &lt; q_old: results[\"quantity_change\"] = \"감소\"\n        else: results[\"quantity_change\"] = \"변동 없음\"\n    else: results[\"quantity_change\"] = \"비교 불가\"\n\n    return results\n\nprint(\"econo_analyzer.analysis.shifts 모듈 로드됨\") # 모듈 로드 확인용 (선택 사항)\n\nWriting econo_analyzer/analysis/shifts.py\n\n\n패키지 사용하기:\n이제 위에서 만든 패키지의 함수들을 import 해서 사용할 수 있습니다.\n\n# 패키지 및 모듈 import\nfrom econo_analyzer.models import market\nfrom econo_analyzer.analysis import shifts\n\n# 실습 2-1의 파라미터 설정\nparams_initial = {'a': 150, 'b': 3, 'c': 30, 'd': 2} # 원래 상태\nparams_demand_decrease = {'a': 120, 'b': 3, 'c': 30, 'd': 2} # 수요 감소 후 상태\n\n# 변화 분석 함수 호출\ncomparison_result = shifts.compare_equilibria(params_initial, params_demand_decrease)\n\n# 결과 출력\nprint(\"\\n--- 수요 감소 효과 분석 결과 (패키지 사용) ---\")\np_old, q_old = comparison_result[\"old_equilibrium\"]\np_new, q_new = comparison_result[\"new_equilibrium\"]\nprice_change_desc = comparison_result[\"price_change\"]\nquantity_change_desc = comparison_result[\"quantity_change\"]\n\nprint(f\"원래 균형점: P*={p_old:.2f}, Q*={q_old:.2f}\")\nprint(f\"새로운 균형점: P*={p_new:.2f}, Q*={q_new:.2f}\")\nprint(f\"균형 가격 변화: {price_change_desc}\")\nprint(f\"균형 거래량 변화: {quantity_change_desc}\")\n\n# market 모듈의 함수도 직접 사용 가능\np_test = 20\nqd_test = market.quantity_demanded(p_test, params_initial['a'], params_initial['b'])\nprint(f\"\\n(market 모듈 직접 호출) 가격 {p_test}에서 수요량: {qd_test}\")\n\necono_analyzer.models.market 모듈 로드됨\necono_analyzer.analysis.shifts 모듈 로드됨\n\n--- 수요 감소 효과 분석 결과 (패키지 사용) ---\n원래 균형점: P*=24.00, Q*=78.00\n새로운 균형점: P*=18.00, Q*=66.00\n균형 가격 변화: 하락\n균형 거래량 변화: 감소\n\n(market 모듈 직접 호출) 가격 20에서 수요량: 90\n\n\n정리:\n패키지는 여러 모듈들을 체계적으로 구성하여 더 크고 복잡한 프로젝트를 관리할 수 있게 해주는 중요한 개념입니다. 비록 Colab 환경에서는 실제 로컬 환경처럼 패키지를 다루기에는 제약이 따르지만, !mkdir, !touch, %%writefile 등을 이용해 그 구조와 사용법을 경험해 볼 수 있습니다. 기능별로 코드를 분리하고(market.py, shifts.py), __init__.py를 통해 디렉토리를 패키지로 인식시키며, import 구문을 통해 필요한 기능을 가져다 쓰는 이 방식은 여러분이 앞으로 더 큰 규모의 파이썬 프로젝트를 접하게 될 때 매우 유용할 것입니다.\n\n정리:\nargparse는 파이썬 스크립트를 명령줄에서 더 유연하게 실행할 수 있게 도와주고, 모듈과 패키지는 코드를 체계적으로 구성하고 재사용성을 높여 더 크고 복잡한 프로젝트를 가능하게 합니다. 노트북 환경을 넘어서 실제 파이썬 프로그램을 개발할 때 매우 중요한 개념들이니, 이런 것이 있다는 것을 기억해두시면 좋겠습니다.",
    "crumbs": [
      "Curriculum",
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>보충 학습: 파이썬 스크립트와 코드 재사용 심화 (Advanced Topic)</span>"
    ]
  },
  {
    "objectID": "week7.html",
    "href": "week7.html",
    "title": "8  7주차: 백문이 불여일견! 데이터 시각화 기초 (Matplotlib)",
    "section": "",
    "text": "8.1 1. 데이터 시각화 시작하기: Matplotlib 소개\n강의 개요:\n지난 6주차에는 파이썬 함수를 활용하여 수요와 공급 모델을 만들고 시장 균형을 분석하는 방법을 배웠습니다. 특히, 계산된 결과를 그래프로 시각화했을 때 모델의 작동 원리와 분석 결과(예: 수요/공급 이동 효과)를 훨씬 더 명확하고 직관적으로 이해할 수 있다는 것을 경험했죠.\n경제학 및 회계 분야에서 데이터 분석 결과를 효과적으로 전달하고 숨겨진 패턴이나 추세를 발견하는 데 데이터 시각화(Data Visualization) 는 필수적인 기술입니다. 아무리 훌륭한 분석을 했더라도 그 결과를 다른 사람이 쉽게 이해할 수 있도록 보여주지 못한다면 그 가치가 반감될 수 있습니다. “백문이 불여일견(百聞不如一見)”이라는 말처럼, 때로는 잘 만들어진 그래프 하나가 수많은 숫자나 긴 설명보다 훨씬 강력한 메시지를 전달합니다.\n이번 주에는 파이썬의 가장 대표적인 시각화 라이브러리인 Matplotlib 를 사용하여 다양한 종류의 그래프를 직접 그려보는 방법을 체계적으로 배우겠습니다. 지난주에 맛보기로 사용했던 선 그래프 외에도 막대 그래프, 산점도 등을 그리는 방법과 그래프에 제목, 축 레이블, 범례 등을 추가하여 더욱 완성도 높은 시각 자료를 만드는 방법을 익힐 것입니다.\n이번 시간 학습 목표:\n데이터 시각화는 왜 중요할까요?\nMatplotlib 이란?\nMatplotlib는 파이썬에서 가장 널리 사용되는 데이터 시각화 라이브러리 중 하나입니다. 마치 그림을 그리는 도화지와 다양한 펜, 물감 같은 도구를 제공한다고 생각할 수 있습니다. 다양한 종류의 그래프를 정교하게 그릴 수 있는 강력한 기능을 제공하며, 다른 데이터 분석 라이브러리(NumPy, Pandas)와도 잘 연동됩니다.\n기본 사용법 (pyplot 모듈)\nMatplotlib의 여러 기능 중 우리는 주로 pyplot 이라는 모듈을 사용할 것입니다. pyplot은 MATLAB과 유사한 인터페이스를 제공하여 비교적 쉽게 그래프를 그릴 수 있게 해줍니다. 관례적으로 plt 라는 별칭(alias)으로 import하여 사용합니다.\nimport matplotlib.pyplot as plt\n기본적인 그래프 그리기 과정:\n★ Colab 환경 한글 폰트 설정 (복습 및 필수) ★\nMatplotlib의 기본 설정에서는 한글이 깨져 보일 수 있습니다. 따라서 그래프에 한글(제목, 축 레이블 등)을 사용하려면 반드시 아래 코드를 실행하여 한글 폰트를 설치하고 설정해주어야 합니다. (Colab 사용 시 필요)\n# Colab 사용 시 한글 폰트 설치 및 설정\n# (이 코드는 Colab 환경에서 실행해야 효과가 있습니다.)\n# 이미 설치 및 설정했다면 다시 실행할 필요는 없을 수 있습니다.\nimport matplotlib.pyplot as plt\nimport platform\n\n# 1. 나눔 폰트 설치 (최초 1회 필요)\n# !sudo apt-get update -qq\n# !sudo apt-get install -y fonts-nanum* -qq\n\n# 2. 폰트 캐시 재생성 (설치 후 필요할 수 있음)\n# import matplotlib.font_manager as fm\n# fm._rebuild() # 폰트 캐시 강제 재생성 (시간 소요)\n\n# 3. 런타임 다시 시작 (Colab 메뉴 &gt; 런타임 &gt; 런타임 다시 시작) - 중요!\n\n# 4. Matplotlib 폰트 설정 적용\ntry:\n    if platform.system() == 'Linux': # Colab 포함\n        plt.rc('font', family='NanumBarunGothic')\n    elif platform.system() == 'Windows':\n        plt.rc('font', family='Malgun Gothic')\n    elif platform.system() == 'Darwin': # macOS\n        plt.rc('font', family='AppleGothic')\nexcept FileNotFoundError:\n    print(\"설치된 한글 폰트를 찾을 수 없습니다. 폰트 이름을 확인하거나 추가 설치가 필요합니다.\")\n\n# 5. 마이너스 기호 깨짐 방지 설정\nplt.rcParams['axes.unicode_minus'] = False\n\n# 설정 확인용 테스트 플롯 (선택 사항)\n# plt.plot([1, 2, 3], [1, 4, 9])\n# plt.title('테스트 한글 제목')\n# plt.xlabel('X축 라벨')\n# plt.show()\n\nprint(\"한글 폰트 설정이 시도되었습니다. 오류 메시지가 없다면 적용되었을 가능성이 높습니다.\")\n\n한글 폰트 설정이 시도되었습니다. 오류 메시지가 없다면 적용되었을 가능성이 높습니다.\n주의: 폰트 설치 후에는 Colab의 “런타임 다시 시작”이 필요할 수 있습니다.",
    "crumbs": [
      "Curriculum",
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>7주차: 백문이 불여일견! 데이터 시각화 기초 (Matplotlib)</span>"
    ]
  },
  {
    "objectID": "week7.html#데이터-시각화-시작하기-matplotlib-소개",
    "href": "week7.html#데이터-시각화-시작하기-matplotlib-소개",
    "title": "8  7주차: 백문이 불여일견! 데이터 시각화 기초 (Matplotlib)",
    "section": "",
    "text": "패턴 및 추세 발견: 숫자로만 봐서는 알기 어려운 데이터 속 패턴, 추세, 이상치(outlier) 등을 시각적으로 빠르게 파악할 수 있습니다.\n관계 이해: 변수들 간의 상관관계나 복잡한 관계를 직관적으로 이해하는 데 도움을 줍니다.\n효과적인 소통: 분석 결과를 다른 사람들에게 쉽고 명확하게 전달하는 강력한 도구입니다. 보고서나 프레젠테이션의 설득력을 높여줍니다.\n\n\n\n\n\n\n\n\n데이터 준비: 그래프로 나타낼 데이터를 준비합니다 (보통 리스트나 NumPy 배열 형태).\n그래프 생성: plt.plot(), plt.bar(), plt.scatter() 등의 함수를 사용하여 원하는 종류의 그래프를 그립니다.\n(선택) 그래프 꾸미기: plt.title(), plt.xlabel(), plt.ylabel(), plt.legend() 등으로 제목, 축 레이블, 범례 등을 추가하고, 색상, 스타일 등을 조절합니다.\n그래프 보여주기: plt.show() 함수를 호출하여 완성된 그래프를 화면에 표시합니다. (Jupyter/Colab 환경에서는 %matplotlib inline 설정이 되어 있으면 plt.show() 없이도 그래프가 표시되는 경우가 많지만, 명시적으로 호출하는 것이 좋습니다.)",
    "crumbs": [
      "Curriculum",
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>7주차: 백문이 불여일견! 데이터 시각화 기초 (Matplotlib)</span>"
    ]
  },
  {
    "objectID": "week7.html#시간의-흐름을-따라서-선-그래프-plt.plot",
    "href": "week7.html#시간의-흐름을-따라서-선-그래프-plt.plot",
    "title": "8  7주차: 백문이 불여일견! 데이터 시각화 기초 (Matplotlib)",
    "section": "8.2 2. 시간의 흐름을 따라서: 선 그래프 (plt.plot())",
    "text": "8.2 2. 시간의 흐름을 따라서: 선 그래프 (plt.plot())\n선 그래프(Line Plot) 는 시간이나 순서에 따라 변화하는 데이터를 표현하는 데 가장 적합한 그래프 유형입니다. 데이터 포인트들을 순서대로 선으로 연결하여 추세나 변화 패턴을 보여줍니다.\n기본 사용법: plt.plot(x축_데이터_리스트, y축_데이터_리스트)\n예제 1: 연도별 가상 GDP 변화\n\nimport matplotlib.pyplot as plt\n\n# 데이터 준비\nyears = [2020, 2021, 2022, 2023, 2024]\ngdp_kr = [1.65, 1.72, 1.80, 1.85, 1.90] # 단위: 조 달러 (가상)\n\n# 선 그래프 그리기\nplt.plot(years, gdp_kr)\n\n# 그래프 보여주기\nplt.show()\n\n\n\n\n\n\n\n\n예제 2: 여러 국가 GDP 추세 비교 및 그래프 꾸미기\n\nimport matplotlib.pyplot as plt\n\n# 데이터 준비\nyears = [2020, 2021, 2022, 2023, 2024]\ngdp_kr = [1.65, 1.72, 1.80, 1.85, 1.90] # 한국 GDP (조 달러)\ngdp_jp = [5.0, 5.1, 4.4, 4.2, 4.5] # 일본 GDP (조 달러) - 환율 영향 등으로 변동성 가정\n\n# 그래프 크기 설정\nplt.figure(figsize=(8, 5)) # 가로 8인치, 세로 5인치\n\n# 여러 개 선 그래프 그리기 (각 plot마다 label 지정)\nplt.plot(years, gdp_kr, marker='o', linestyle='-', color='blue', label='한국 GDP')\nplt.plot(years, gdp_jp, marker='s', linestyle='--', color='red', label='일본 GDP') # s: 사각형 마커, --: 점선\n\n# 제목 추가\nplt.title('한국과 일본의 연도별 GDP 변화 (가상)', fontsize=14)\n# 축 레이블 추가\nplt.xlabel('연도', fontsize=12)\nplt.ylabel('GDP (단위: 조 USD)', fontsize=12)\n# 범례(legend) 표시 (plot에서 지정한 label 사용)\nplt.legend()\n# 그리드 표시\nplt.grid(True, axis='y', linestyle=':', alpha=0.7)\n\n# 그래프 보여주기\nplt.show()\n\n\n\n\n\n\n\n\n주요 꾸미기 옵션 (plt.plot 내부):\n\nmarker: 데이터 포인트를 표시할 모양 (‘o’, ‘s’, ‘^’, ‘v’, ’*‘,’.’ 등)\nlinestyle 또는 ls: 선의 스타일 (‘-’, ‘–’, ‘:’, ‘-.’ 등)\ncolor 또는 c: 선의 색상 (‘blue’, ‘red’, ‘green’, ‘black’, ‘skyblue’, ‘crimson’ 등 또는 ‘#FF0000’ 같은 헥사코드)\nlabel: 범례에 표시될 선의 이름 (반드시 plt.legend() 호출 필요)\n\n예제 3: 수요와 공급 곡선 그리기 (복습 및 개선)\n지난주에 그렸던 수요/공급 곡선을 plt.plot과 꾸미기 옵션을 사용하여 다시 그려봅시다.\n\nimport matplotlib.pyplot as plt\nimport numpy as np # NumPy 사용 (데이터 생성 편의)\n\n# 수요/공급 함수 정의 (Week 6 내용 재사용)\ndef quantity_demanded(price, a=100, b=2):\n    q_d = a - b * price\n    return max(0, q_d)\ndef quantity_supplied(price, c=10, d=3):\n    q_s = c + d * price\n    return max(0, q_s)\n\n# 파라미터 및 데이터 생성\na, b = 100, 2\nc, d = 10, 3\np_max_demand = a / b\nprice_range = np.linspace(0, p_max_demand + 5, 50) # 가격 범위 약간 넓게\nqd_values = [quantity_demanded(p, a, b) for p in price_range]\nqs_values = [quantity_supplied(p, c, d) for p in price_range]\n\n# 균형점 (Week 6 계산 결과: P*=18, Q*=64)\np_eq, q_eq = 18, 64\n\n# 그래프 그리기\nplt.figure(figsize=(10, 7))\n\n# 수요 곡선 (파란색, 실선, 동그라미 마커)\nplt.plot(qd_values, price_range, label='수요 곡선 (D)', color='blue', linestyle='-', marker='o', markersize=4)\n# 공급 곡선 (빨간색, 점선, 사각형 마커)\nplt.plot(qs_values, price_range, label='공급 곡선 (S)', color='red', linestyle='--', marker='s', markersize=4)\n# 균형점 (검정색 큰 별표 마커)\nplt.scatter(q_eq, p_eq, color='black', marker='*', s=200, zorder=5, label=f'균형점 E ({q_eq:.0f}, {p_eq:.0f})')\n\n# 그래프 꾸미기\nplt.title('시장 수요와 공급 곡선', fontsize=16)\nplt.xlabel('수량 (Quantity)', fontsize=12)\nplt.ylabel('가격 (Price)', fontsize=12)\nplt.legend(fontsize=11) # 범례\nplt.grid(True, linestyle=':', alpha=0.5)\nplt.xlim(left=0) # X축 범위 0부터 시작\nplt.ylim(bottom=0) # Y축 범위 0부터 시작\n\nplt.show()\n\n\n\n\n\n\n\n\n\n\n[실습 1] 선 그래프 연습\n\n월별 물가 상승률 시각화: 다음은 6개월간의 월별 물가 상승률(전년 동월 대비 %) 데이터입니다. months = [1, 2, 3, 4, 5, 6] inflation_rates = [3.1, 3.5, 3.8, 3.2, 2.9, 2.7] 이 데이터를 사용하여 월별 물가 상승률 추세를 보여주는 선 그래프를 그리세요. x축은 ‘월(Month)’, y축은 ‘물가 상승률(%)’로 레이블을 붙이고, 그래프 제목은 ’월별 물가 상승률 추이’로 하세요. 선 색상은 ’green’, 마커는 ‘x’ 로 지정해보세요.\n두 상품 가격 추이 비교: 두 경쟁 상품 A, B의 5일간 가격 데이터가 다음과 같습니다. days = [1, 2, 3, 4, 5] price_A = [1000, 1050, 1020, 1100, 1080] price_B = [980, 1000, 1010, 1030, 1020] 두 상품의 가격 추이를 하나의 그래프에 선 그래프로 그리세요. 각 선에 ‘상품 A’, ‘상품 B’ 라는 라벨을 붙이고 범례를 표시하세요. 그래프 제목과 축 레이블도 적절하게 추가하세요.\n\n\n\n# 실습 1-1: 월별 물가 상승률\nimport matplotlib.pyplot as plt\n\n# 한글 폰트 설정은 미리 되었다고 가정\nmonths = [1, 2, 3, 4, 5, 6]\ninflation_rates = [3.1, 3.5, 3.8, 3.2, 2.9, 2.7]\n\nplt.figure(figsize=(8, 5))\nplt.plot(months, inflation_rates, color='green', marker='x', linestyle='-')\nplt.title('월별 물가 상승률 추이')\nplt.xlabel('월(Month)')\nplt.ylabel('물가 상승률(%)')\nplt.grid(True, linestyle=':', alpha=0.7)\nplt.show()\n\n\n\n\n\n\n\n\n\n# 실습 1-2: 두 상품 가격 추이 비교\nimport matplotlib.pyplot as plt\n\ndays = [1, 2, 3, 4, 5]\nprice_A = [1000, 1050, 1020, 1100, 1080]\nprice_B = [980, 1000, 1010, 1030, 1020]\n\nplt.figure(figsize=(8, 5))\nplt.plot(days, price_A, marker='o', label='상품 A')\nplt.plot(days, price_B, marker='s', label='상품 B')\nplt.title('상품 A와 B의 가격 추이 비교')\nplt.xlabel('일자 (Day)')\nplt.ylabel('가격 (원)')\nplt.legend()\nplt.grid(True, axis='y', linestyle=':')\nplt.show()",
    "crumbs": [
      "Curriculum",
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>7주차: 백문이 불여일견! 데이터 시각화 기초 (Matplotlib)</span>"
    ]
  },
  {
    "objectID": "week7.html#항목-간-크기-비교-막대-그래프-plt.bar",
    "href": "week7.html#항목-간-크기-비교-막대-그래프-plt.bar",
    "title": "8  7주차: 백문이 불여일견! 데이터 시각화 기초 (Matplotlib)",
    "section": "8.3 3. 항목 간 크기 비교: 막대 그래프 (plt.bar())",
    "text": "8.3 3. 항목 간 크기 비교: 막대 그래프 (plt.bar())\n막대 그래프(Bar Chart) 는 여러 범주형(Categorical) 항목들의 크기(값) 를 비교하는 데 유용합니다. 각 항목을 나타내는 막대의 높이(또는 길이)로 값의 크기를 표현합니다.\n기본 사용법: plt.bar(x축_항목_리스트, y축_값_리스트)\n예제 1: 주요 국가별 GDP 비교\nWeek 2 시각화 맛보기에서 봤던 예제입니다.\n\nimport matplotlib.pyplot as plt\n\n# 한글 폰트 설정은 미리 되었다고 가정\n\n# 데이터 준비\ncountries = ['대한민국', '미국', '중국', '일본', '독일']\ngdp_values_usd = [1.8, 27.0, 19.0, 4.5, 4.2] # 단위: 조 USD\n\n# 막대 그래프 그리기\nplt.figure(figsize=(8, 6))\nplt.bar(countries, gdp_values_usd, color=['skyblue', 'lightcoral', 'orange', 'lightgreen', 'plum'])\n\n# 제목 및 축 레이블\nplt.title('주요 국가별 2024년 추정 GDP 비교', fontsize=15)\nplt.ylabel('GDP (단위: 조 USD)', fontsize=12)\nplt.xlabel('국가', fontsize=12)\n# plt.xticks(rotation=45) # 국가 이름이 길 경우 글자 회전 (선택 사항)\n\nplt.show()\n\n\n\n\n\n\n\n\n예제 2: GDP 구성 요소 시각화 (딕셔너리 활용)\n딕셔너리에 저장된 GDP 구성 요소 데이터를 막대 그래프로 표현해 봅시다.\n\nimport matplotlib.pyplot as plt\n\n# 한글 폰트 설정은 미리 되었다고 가정\n\n# 딕셔너리 데이터\ngdp_components_dict = {\n    '민간 소비(C)': 1000.5,\n    '국내 총투자(I)': 350.2,\n    '정부 지출(G)': 450.0,\n    '순수출(NX)': 50.8\n}\n\n# 딕셔너리에서 key(항목 이름)와 value(값)를 리스트로 분리\ncomponents = list(gdp_components_dict.keys())\nvalues = list(gdp_components_dict.values())\n\n# 막대 그래프 그리기\nplt.figure(figsize=(8, 5))\nplt.bar(components, values, color=['gold', 'lightcoral', 'lightskyblue', 'lightgreen'])\n\nplt.title('가상 국가 GDP 구성 요소', fontsize=15)\nplt.ylabel('금액 (단위: 조 원)', fontsize=12)\n\nplt.show()\n\n\n\n\n\n\n\n\n수평 막대 그래프 (plt.barh()): 항목 이름이 길거나 항목 수가 많을 때는 수평 막대 그래프가 유용할 수 있습니다. plt.barh(y축_항목_리스트, x축_값_리스트) 형태로 사용합니다.\n\n\n[실습 2] 막대 그래프 연습\n\n대륙별 인구 비교: 다음은 대략적인 대륙별 인구 데이터(억 명)입니다. continents = ['Asia', 'Africa', 'Europe', 'North America', 'South America', 'Oceania'] populations_billion = [47.0, 14.0, 7.5, 6.0, 4.3, 0.4] 이 데이터를 사용하여 대륙별 인구를 비교하는 막대 그래프를 그리세요. 그래프 제목과 축 레이블을 추가하세요.\n가상 기업 분기별 영업이익: 어떤 기업의 4분기 영업이익(억 원) 데이터가 딕셔너리로 주어졌습니다. quarterly_profit = {'1분기': 35.2, '2분기': 41.5, '3분기': 28.8, '4분기': 45.0} 이 데이터를 사용하여 분기별 영업이익을 보여주는 막대 그래프를 그리세요.\n\n\n\n# 실습 2-1: 대륙별 인구 비교\nimport matplotlib.pyplot as plt\n\ncontinents = ['Asia', 'Africa', 'Europe', 'North America', 'South America', 'Oceania']\npopulations_billion = [47.0, 14.0, 7.5, 6.0, 4.3, 0.4]\n\nplt.figure(figsize=(10, 6))\nplt.bar(continents, populations_billion, color='skyblue')\nplt.title('대륙별 인구 (추정치)')\nplt.ylabel('인구 (단위: 억 명)')\nplt.xlabel('대륙')\nplt.show()\n\n\n\n\n\n\n\n\n\n# 실습 2-2: 분기별 영업이익\nimport matplotlib.pyplot as plt\n\n\nquarterly_profit = {'1분기': 35.2, '2분기': 41.5, '3분기': 28.8, '4분기': 45.0}\nquarters = list(quarterly_profit.keys())\nprofits = list(quarterly_profit.values())\n\nplt.figure(figsize=(8, 5))\nplt.bar(quarters, profits, color='lightcoral')\nplt.title('분기별 영업이익')\nplt.ylabel('영업이익 (억 원)')\nplt.xlabel('분기')\nplt.grid(True, axis='y', linestyle=':', alpha=0.7)\nplt.show()",
    "crumbs": [
      "Curriculum",
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>7주차: 백문이 불여일견! 데이터 시각화 기초 (Matplotlib)</span>"
    ]
  },
  {
    "objectID": "week7.html#변수-간-관계-살펴보기-산점도-plt.scatter",
    "href": "week7.html#변수-간-관계-살펴보기-산점도-plt.scatter",
    "title": "8  7주차: 백문이 불여일견! 데이터 시각화 기초 (Matplotlib)",
    "section": "8.4 4. 변수 간 관계 살펴보기: 산점도 (plt.scatter())",
    "text": "8.4 4. 변수 간 관계 살펴보기: 산점도 (plt.scatter())\n산점도(Scatter Plot) 는 두 개의 수치형 변수 간의 관계를 파악하는 데 사용됩니다. 각 데이터 포인트를 x축 값과 y축 값에 해당하는 위치에 점으로 찍어서 분포를 보여줍니다. 점들이 특정 패턴(예: 우상향, 우하향)을 보이면 두 변수 간에 상관관계가 있을 가능성을 시사합니다.\n기본 사용법: plt.scatter(x축_데이터_리스트, y축_데이터_리스트)\n예제 1: 공부 시간과 시험 점수 (가상 데이터)\n\nimport matplotlib.pyplot as plt\n\n# 한글 폰트 설정 미리 되었다고 가정\n\n# 데이터 준비 (10명 학생의 공부 시간과 시험 점수)\nstudy_hours = [2, 3, 5, 1, 6, 7, 4, 8, 9, 5.5]\nexam_scores = [65, 70, 75, 60, 85, 90, 72, 92, 95, 80]\n\n# 산점도 그리기\nplt.figure(figsize=(8, 6))\nplt.scatter(study_hours, exam_scores, color='purple', alpha=0.7) # alpha는 투명도\n\n# 제목 및 축 레이블\nplt.title('공부 시간과 시험 점수 간의 관계 (가상)', fontsize=14)\nplt.xlabel('공부 시간 (시간)', fontsize=12)\nplt.ylabel('시험 점수', fontsize=12)\nplt.grid(True, linestyle=':', alpha=0.5)\n\nplt.show()\n\n# 그래프 해석: 공부 시간이 길수록 시험 점수가 대체로 높아지는 양(+)의 관계가 있는 것으로 보입니다.\n\n\n\n\n\n\n\n\n예제 2: 인플레이션율과 실업률 관계 (가상 데이터, 필립스 곡선 개념)\n필립스 곡선은 단기적으로 인플레이션율과 실업률 간의 역(-)의 관계가 있음을 보여주는 개념입니다. (장기적 관계는 논쟁적)\n\nimport matplotlib.pyplot as plt\nimport numpy as np # 데이터 생성을 위해 사용\n\n# 한글 폰트 설정 미리 되었다고 가정\n\n# 가상 데이터 생성 (실제 데이터와는 다를 수 있음)\nnp.random.seed(42) # 결과 재현을 위한 시드 설정\nunemployment_rate = np.linspace(3, 10, 20) # 3% ~ 10% 실업률\n# 실업률이 낮을수록 인플레이션이 높아지는 경향 (역관계) + 약간의 노이즈 추가\ninflation_rate = 10 - unemployment_rate * 0.8 + np.random.randn(20) * 0.5\n\n# 산점도 그리기\nplt.figure(figsize=(8, 6))\nplt.scatter(unemployment_rate, inflation_rate, color='orange')\n\nplt.title('실업률과 인플레이션율 간의 관계 (가상)', fontsize=14)\nplt.xlabel('실업률 (%)', fontsize=12)\nplt.ylabel('인플레이션율 (%)', fontsize=12)\nplt.grid(True, linestyle=':', alpha=0.5)\n\nplt.show()\n\n# 그래프 해석: 대체로 실업률이 낮을수록 인플레이션율이 높고, 실업률이 높을수록 인플레이션율이 낮은 우하향 관계가 관찰됩니다. (단기 필립스 곡선 개념과 유사)\n\n\n\n\n\n\n\n\n산점도 꾸미기 옵션 (plt.scatter 내부):\n\ns: 마커의 크기\nc 또는 color: 마커의 색상 (하나의 색 또는 각 점마다 다른 색 지정 가능)\nmarker: 마커의 모양 (‘o’, ‘s’, ‘^’, ‘x’ 등)\nalpha: 마커의 투명도 (0~1 사이 값, 점이 많을 때 겹침 확인에 유용)",
    "crumbs": [
      "Curriculum",
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>7주차: 백문이 불여일견! 데이터 시각화 기초 (Matplotlib)</span>"
    ]
  },
  {
    "objectID": "week7.html#그래프-완성도-높이기-추가적인-꾸미기-옵션",
    "href": "week7.html#그래프-완성도-높이기-추가적인-꾸미기-옵션",
    "title": "8  7주차: 백문이 불여일견! 데이터 시각화 기초 (Matplotlib)",
    "section": "8.5 5. 그래프 완성도 높이기: 추가적인 꾸미기 옵션",
    "text": "8.5 5. 그래프 완성도 높이기: 추가적인 꾸미기 옵션\n지금까지 배운 plt.title(), plt.xlabel(), plt.ylabel(), plt.legend(), plt.grid(), plt.figure(figsize=...) 외에도 그래프를 더 보기 좋고 정보성 있게 만드는 몇 가지 옵션들이 있습니다.\n\nplt.xticks() / plt.yticks(): 축 눈금의 위치나 표시될 텍스트를 직접 지정할 수 있습니다.\nplt.xlim() / plt.ylim(): 그래프의 x축 또는 y축 표시 범위를 수동으로 설정합니다. (예: plt.ylim(0, 100) 은 y축을 0부터 100까지 표시)\nplt.text(x, y, text): 그래프 상의 특정 (x, y) 위치에 원하는 텍스트를 추가할 수 있습니다.\nplt.axhline(y) / plt.axvline(x): 특정 y값에 수평선 또는 특정 x값에 수직선을 그릴 수 있습니다. (예: 평균값 표시, 특정 기준선 표시 등)\n\n예제: 꾸미기 옵션 종합 적용 (수요/공급 그래프 개선)\n\nimport matplotlib.pyplot as plt\nimport numpy as np\n\n# 수요/공급 함수, 파라미터, 데이터 생성 (이전 예제 재사용)\ndef quantity_demanded(price, a=100, b=2): return max(0, a - b * price)\ndef quantity_supplied(price, c=10, d=3): return max(0, c + d * price)\na, b = 100, 2\nc, d = 10, 3\np_max_demand = a / b\nprice_range = np.linspace(0, p_max_demand + 5, 50)\nqd_values = [quantity_demanded(p, a, b) for p in price_range]\nqs_values = [quantity_supplied(p, c, d) for p in price_range]\np_eq, q_eq = 18, 64\n\n# --- 그래프 그리기 및 꾸미기 ---\nplt.figure(figsize=(12, 8)) # 그래프 크기 키우기\n\n# 수요/공급 곡선 그리기 (선 굵기 'linewidth' 추가)\nplt.plot(qd_values, price_range, label='수요 곡선 (D)', color='blue', linewidth=2)\nplt.plot(qs_values, price_range, label='공급 곡선 (S)', color='red', linewidth=2)\n\n# 균형점 표시 및 텍스트 추가\nplt.scatter(q_eq, p_eq, color='black', marker='o', s=100, zorder=5, label=f'균형점 E ({q_eq:.0f}, {p_eq:.0f})')\nplt.text(q_eq + 2, p_eq + 1, f'Equilibrium (Q={q_eq}, P={p_eq})', fontsize=11) # 균형점 옆에 텍스트\n\n# 균형점 점선 추가\nplt.plot([q_eq, q_eq], [0, p_eq], color='grey', linestyle='--', linewidth=1)\nplt.plot([0, q_eq], [p_eq, p_eq], color='grey', linestyle='--', linewidth=1)\n\n# 제목 및 축 레이블 (폰트 크기 조절)\nplt.title('시장 수요와 공급 (꾸미기 적용)', fontsize=16)\nplt.xlabel('수량 (Quantity)', fontsize=13)\nplt.ylabel('가격 (Price)', fontsize=13)\n\n# 축 범위 설정 (조금 더 여유있게)\nplt.xlim(0, max(max(qd_values), max(qs_values)) * 1.1) # 최대 수량보다 10% 더\nplt.ylim(0, max(price_range) * 1.1) # 최대 가격보다 10% 더\n\n# 축 눈금 설정 (선택 사항)\nplt.xticks(fontsize=11)\nplt.yticks(fontsize=11)\n\n# 범례 표시 및 그리드\nplt.legend(fontsize=12)\nplt.grid(True, linestyle=':', alpha=0.6)\n\nplt.show()\n\n\n\n\n\n\n\n\n\n\n[실습 3] 산점도 및 꾸미기 연습\n\nGDP와 기대수명 관계 시각화 (가상 데이터): 여러 국가의 1인당 GDP(달러)와 기대수명 데이터가 다음과 같이 주어졌습니다. gdp_per_capita = [5000, 10000, 20000, 35000, 50000, 65000] life_expectancy = [65, 70, 75, 78, 80, 82] 두 변수 간의 관계를 보여주는 산점도를 그리세요. x축은 ‘1인당 GDP (USD)’, y축은 ‘기대수명 (세)’로 레이블을 지정하고, 그래프 제목은 ’1인당 GDP와 기대수명 간의 관계’로 하세요. 점 색상은 ’green’, 마커 모양은 ‘^’(삼각형)으로 지정해보세요.\n그래프 꾸미기: 위 1번에서 그린 산점도에 다음 꾸미기 옵션을 추가 적용해보세요.\n\nfigsize를 (9, 6)으로 설정\ngrid 추가\nx축 범위를 0부터 70000까지, y축 범위를 60부터 85까지로 설정 (plt.xlim, plt.ylim)\n\n\n\n\n# 실습 3-1: GDP와 기대수명 산점도\nimport matplotlib.pyplot as plt\n\n\ngdp_per_capita = [5000, 10000, 20000, 35000, 50000, 65000]\nlife_expectancy = [65, 70, 75, 78, 80, 82]\n\nplt.scatter(gdp_per_capita, life_expectancy, color='green', marker='^')\nplt.title('1인당 GDP와 기대수명 간의 관계 (가상)')\nplt.xlabel('1인당 GDP (USD)')\nplt.ylabel('기대수명 (세)')\nplt.show()\n\n\n\n\n\n\n\n\n\n# 실습 3-2: 산점도 꾸미기 추가\n\ngdp_per_capita = [5000, 10000, 20000, 35000, 50000, 65000]\nlife_expectancy = [65, 70, 75, 78, 80, 82]\n\nplt.figure(figsize=(9, 6)) # 그래프 크기 설정\nplt.scatter(gdp_per_capita, life_expectancy, color='green', marker='^')\nplt.title('1인당 GDP와 기대수명 간의 관계 (가상)', fontsize=15)\nplt.xlabel('1인당 GDP (USD)', fontsize=12)\nplt.ylabel('기대수명 (세)', fontsize=12)\nplt.grid(True, linestyle=':', alpha=0.6) # 그리드 추가\nplt.xlim(0, 70000) # x축 범위 설정\nplt.ylim(60, 85) # y축 범위 설정\nplt.show()",
    "crumbs": [
      "Curriculum",
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>7주차: 백문이 불여일견! 데이터 시각화 기초 (Matplotlib)</span>"
    ]
  },
  {
    "objectID": "week7.html#보충-학습-matplotlib-그래프-해부하기-anatomy-of-a-figure",
    "href": "week7.html#보충-학습-matplotlib-그래프-해부하기-anatomy-of-a-figure",
    "title": "8  7주차: 백문이 불여일견! 데이터 시각화 기초 (Matplotlib)",
    "section": "8.6 보충 학습: Matplotlib 그래프 해부하기 (Anatomy of a Figure)",
    "text": "8.6 보충 학습: Matplotlib 그래프 해부하기 (Anatomy of a Figure)\n우리가 plt.plot(), plt.bar(), plt.title() 등 다양한 pyplot 함수를 사용하여 그래프를 그리고 꾸며보았습니다. Matplotlib으로 더 정교하고 복잡한 그래프를 만들거나, 공식 문서나 다른 자료들을 참고하여 고급 기능을 사용하려면 그래프가 어떤 요소들로 구성되어 있는지 그 구조(Anatomy) 를 이해하는 것이 큰 도움이 됩니다.\nMatplotlib 문서에서는 종종 “Anatomy of a Figure” 라는 그림을 통해 그래프의 각 부분을 설명합니다. 마치 우리가 인체의 각 부위 명칭을 알면 의학 정보를 더 잘 이해할 수 있듯이, 그래프의 구성 요소 명칭과 역할을 알면 Matplotlib의 기능을 더 깊이 있게 활용할 수 있습니다.\n여기서는 주요 구성 요소들을 살펴보고, 우리가 배운 pyplot 함수들과 어떻게 연결되는지 알아보겠습니다. (실제 “Anatomy of a Figure” 그림은 Matplotlib 공식 홈페이지 등에서 검색해보시면 쉽게 찾을 수 있습니다.)\n주요 구성 요소:\n\nFigure (피겨):\n\n그래프가 그려지는 전체 캔버스 또는 창(window) 에 해당합니다. 비유하자면, 그림을 그리는 도화지 전체나 액자를 포함한 그림 전체라고 할 수 있습니다.\n하나의 Figure 안에는 하나 또는 여러 개의 Axes(서브플롯) 가 포함될 수 있습니다.\n우리가 plt.figure(figsize=(...)) 함수를 사용하여 크기를 조절했던 것이 바로 이 Figure 객체의 크기입니다.\n\nAxes (액시즈, 복수형):\n\n실제 데이터가 그려지는 영역, 즉 우리가 흔히 ’그래프’라고 부르는 부분입니다. x축, y축, 그리고 그려지는 데이터(선, 막대, 점 등)를 포함하는 하나의 플롯(plot) 입니다.\n비유하자면, Figure라는 도화지 위에 실제 그림이 그려지는 사각형 영역입니다.\n하나의 Figure 안에 여러 개의 Axes를 배열하여 다양한 그래프를 한 번에 보여줄 수도 있습니다 (예: plt.subplot() 함수 - 이번 과정에서는 자세히 다루지 않음).\n우리가 사용한 대부분의 pyplot 함수들 (plt.plot, plt.title, plt.xlabel 등)은 내부적으로 현재 활성화된 하나의 Axes 에 대해 작동합니다.\n\nAxis (액시스, 단수형):\n\n그래프의 축 그 자체를 의미합니다. 보통 x축(가로축)과 y축(세로축)이 있습니다.\n이 축은 데이터의 범위를 나타내는 눈금(Ticks)과 그 값(Tick Labels), 그리고 축의 이름(Axis Label)을 포함합니다.\nplt.xlim(), plt.ylim(): 축의 데이터 범위를 설정합니다.\nplt.xlabel(), plt.ylabel(): 각 축의 이름(Label) 을 설정합니다.\nplt.xticks(), plt.yticks(): 축에 표시될 눈금(Tick) 의 위치나 눈금에 붙는 텍스트(Tick Label) 를 설정합니다.\n\nTitle (타이틀):\n\n해당 Axes(그래프 영역)의 제목입니다.\nplt.title() 함수를 사용하여 설정합니다.\n\nLegend (레전드, 범례):\n\n하나의 Axes 안에 여러 개의 데이터 계열(예: 여러 개의 선 그래프)이 그려질 때, 각 계열이 무엇을 의미하는지 설명하는 안내 상자입니다.\nplt.plot() 등에서 label='...' 옵션으로 각 데이터 계열의 이름을 지정한 후, plt.legend() 함수를 호출하여 표시합니다.\n\nGrid (그리드, 격자):\n\n데이터 값을 더 쉽게 읽을 수 있도록 Axes 영역 내에 그려지는 격자선입니다.\nplt.grid(True) 함수를 사용하여 표시합니다.\n\nSpines (스파인, 축 선):\n\nAxes 영역의 테두리를 그리는 선입니다. 보통 상하좌우 4개의 축 선이 있습니다. (기본적으로 표시됨)\n\nTicks (틱, 눈금) 및 Tick Labels (틱 라벨, 눈금 레이블):\n\nAxis(축) 위에 데이터의 위치를 나타내기 위해 표시되는 작은 선(Tick) 과 그 선 옆에 붙는 숫자 또는 글자(Tick Label) 입니다.\nplt.xticks(), plt.yticks() 함수로 위치나 내용을 조절할 수 있습니다.\n\n(참고) Artist (아티스트):\n\nMatplotlib에서 Figure 위에 그려지는 모든 요소들(텍스트, 선, 도형, 축 등)을 통칭하여 Artist라고 부릅니다. 우리가 pyplot 함수를 호출하면 내부적으로 이런 Artist 객체들이 생성되고 수정되어 화면에 그려지는 것입니다.\n\n\n시각적 예시: 주요 요소 레이블링\n아래 코드는 간단한 그래프에 plt.text() 함수를 사용하여 각 구성 요소의 명칭을 표시하는 예시입니다. (텍스트 위치는 대략적으로 잡았습니다.)\n\nimport matplotlib.pyplot as plt\nimport numpy as np\n\n\n# 1. Figure 객체 생성 및 크기 설정\nfig = plt.figure(figsize=(10, 7))\nplt.text(0.5, 1.02, 'Figure 영역 (전체 캔버스)', ha='center', va='bottom', fontsize=12, color='gray')\n\n# 2. Axes 객체 (pyplot 함수 사용 시 암묵적으로 생성됨)\n#    간단한 데이터 및 플롯 생성\nx = np.linspace(0, 10, 100)\ny = np.sin(x)\nplt.plot(x, y, label='sin(x) 곡선')\n# Axes 영역을 가리키는 텍스트 추가 (대략적인 위치)\nplt.text(5, 0.8, 'Axes 영역 (실제 플롯)', ha='center', fontsize=12, color='darkblue')\n\n# 3. Title 설정\nplt.title('Matplotlib 그래프 구성 요소 예시', fontsize=16)\nplt.text(5, 1.1, '&lt;- Title', ha='center', va='center', fontsize=11, color='green')\n\n# 4. Axis Labels 설정\nplt.xlabel('X 축 (시간 또는 다른 변수)', fontsize=12)\nplt.ylabel('Y 축 (값)', fontsize=12)\nplt.text(9.5, -0.2, '&lt;- X축 Label', ha='right', va='center', fontsize=11, color='green')\nplt.text(-1.5, 0, '&lt;- Y축 Label', rotation=90, ha='center', va='center', fontsize=11, color='green')\n\n\n# 5. Legend 설정\nplt.legend(loc='lower left') # 범례 위치 지정\nplt.text(1, -0.7, '&lt;- Legend (범례)', ha='left', va='center', fontsize=11, color='green')\n\n# 6. Grid 설정\nplt.grid(True, linestyle=':')\nplt.text(2, 0.2, 'Grid (격자)', ha='center', va='center', fontsize=11, color='grey')\n\n# 7. Ticks 와 Tick Labels (자동 생성됨, 위치 표시)\nplt.text(5, -1.2, 'X축 Ticks & Tick Labels', ha='center', va='center', fontsize=11, color='purple')\nplt.text(-0.8, 0.5, 'Y축 Ticks\\n& Tick Labels', ha='center', va='center', fontsize=11, color='purple', rotation=90)\n\n# Y축 범위 약간 조정 (텍스트 보이게)\nplt.ylim(-1.3, 1.3)\nplt.xlim(-1, 11)\n\n# 8. Spines (테두리 선, 기본 표시됨)\nplt.text(10.5, 0, 'Spine (축 테두리선)', rotation=-90, ha='center', va='center', fontsize=11, color='brown')\n\n\nplt.show()",
    "crumbs": [
      "Curriculum",
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>7주차: 백문이 불여일견! 데이터 시각화 기초 (Matplotlib)</span>"
    ]
  },
  {
    "objectID": "week7.html#마무리-및-다음-시간-예고",
    "href": "week7.html#마무리-및-다음-시간-예고",
    "title": "8  7주차: 백문이 불여일견! 데이터 시각화 기초 (Matplotlib)",
    "section": "8.7 6. 마무리 및 다음 시간 예고",
    "text": "8.7 6. 마무리 및 다음 시간 예고\n오늘은 파이썬의 대표적인 시각화 라이브러리인 Matplotlib 를 사용하여 데이터를 시각화하는 기초적인 방법을 배웠습니다. 시각화의 중요성을 다시 한번 확인하고, 선 그래프(plt.plot), 막대 그래프(plt.bar), 산점도(plt.scatter) 등 기본적인 그래프 유형을 그리는 방법을 익혔습니다. 또한, 그래프에 제목, 축 레이블, 범례 등을 추가하고 색상, 스타일, 크기, 축 범위 등을 조절하여 그래프의 완성도를 높이는 꾸미기 방법까지 살펴보았습니다. (Colab에서 한글 폰트 설정의 중요성도 잊지 마세요!)\n데이터를 시각화하는 능력은 경제 및 회계 데이터를 분석하고 그 결과를 효과적으로 전달하는 데 필수적입니다. 오늘 배운 내용들을 바탕으로 앞으로 다양한 데이터를 직접 그래프로 그려보면서 연습하시기 바랍니다.\n다음 시간에는 (마지막 8주차):\n어느덧 마지막 주차네요! 8주차에는 지금까지 배운 파이썬의 모든 개념(변수, 자료형, 자료구조, 조건문, 반복문, 함수, 기본 시각화)을 총정리하고, 이를 종합적으로 활용하는 시간을 가질 예정입니다. 간단한 미니 프로젝트나 케이스 스터디를 통해 실제 경제/금융 데이터를 (아주 간단한 형태로) 가져와서 처리하고, 분석하며, 시각화하는 전체 과정을 경험해 볼 수 있도록 구성할 예정입니다. 또는, 수치 계산에 특화된 NumPy 라이브러리의 기초를 간단히 소개하며 앞으로의 학습 방향을 제시할 수도 있습니다. 마지막 시간까지 유종의 미를 거둘 수 있도록 함께 노력해 봅시다!",
    "crumbs": [
      "Curriculum",
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>7주차: 백문이 불여일견! 데이터 시각화 기초 (Matplotlib)</span>"
    ]
  },
  {
    "objectID": "week7.html#일곱-번째-주차-과제",
    "href": "week7.html#일곱-번째-주차-과제",
    "title": "8  7주차: 백문이 불여일견! 데이터 시각화 기초 (Matplotlib)",
    "section": "8.8 일곱 번째 주차 과제",
    "text": "8.8 일곱 번째 주차 과제\n오늘 배운 Matplotlib 시각화 기능을 연습하기 위해 다음 과제를 Colab에서 새 노트(Week7_Assignment.ipynb 등)에 풀어보세요.\n\n연도별 수출입액 시각화: 어떤 국가의 5년간 수출액과 수입액 데이터(단위: 억 달러)가 다음과 같습니다. years = [2020, 2021, 2022, 2023, 2024] exports = [510, 620, 680, 650, 700] imports = [480, 580, 650, 630, 680]\n\n수출액과 수입액 추이를 하나의 선 그래프에 함께 그리세요. 각 선에 ‘수출액’, ‘수입액’ 라벨을 붙이고 범례를 표시하세요.\n그래프 제목은 ‘연도별 수출입액 추이’, x축은 ‘연도’, y축은 ‘금액 (억 달러)’ 로 지정하세요.\n그리드를 추가하고, 각 데이터 포인트를 마커(‘o’ 또는 다른 모양)로 표시하세요.\n\n산업별 고용자 수 비교: 특정 지역의 주요 산업별 고용자 수(단위: 만 명) 데이터가 다음과 같습니다. industries = ['제조업', '서비스업', '건설업', '농업', 'IT'] employees = [55.8, 120.5, 35.2, 15.0, 45.5]\n\n산업별 고용자 수를 비교하는 막대 그래프를 그리세요.\n그래프 제목과 축 레이블을 적절하게 추가하세요.\n(선택) 각 막대의 색상을 다르게 지정해보세요.\n\n광고비와 매출액 관계 시각화: 어떤 기업의 월별 광고비와 매출액 데이터(단위: 백만원)가 다음과 같습니다. advertising_cost = [10, 15, 12, 20, 18, 25, 22] sales_revenue = [100, 140, 110, 180, 160, 210, 190]\n\n광고비와 매출액 간의 관계를 보여주는 산점도를 그리세요.\nx축은 ‘광고비 (백만원)’, y축은 ’매출액 (백만원)’으로 레이블을 지정하고, 그래프 제목을 추가하세요.\n(선택) 점의 크기(s)나 투명도(alpha)를 조절해보세요.",
    "crumbs": [
      "Curriculum",
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>7주차: 백문이 불여일견! 데이터 시각화 기초 (Matplotlib)</span>"
    ]
  },
  {
    "objectID": "week8.html",
    "href": "week8.html",
    "title": "9  8주차: 파이썬으로 경제 분석하기 (종합 응용 및 마무리)",
    "section": "",
    "text": "9.1 1. 종합 분석 시작: 시나리오 및 데이터 준비\n강의 개요:\n여러분, 드디어 8주간의 파이썬 여정 마지막 주차입니다! 그동안 정말 수고 많으셨습니다. 우리는 파이썬의 기초 문법부터 시작해서 변수, 자료형, 리스트와 딕셔너리 같은 데이터 구조, 조건문과 반복문을 이용한 제어 흐름, 함수를 통한 코드 재사용, 그리고 Matplotlib을 이용한 기본적인 데이터 시각화까지 숨 가쁘게 달려왔습니다.\n이번 마지막 8주차에는 새로운 내용을 배우기보다는, 우리가 지난 7주간 배운 모든 파이썬 기술들을 종합적으로 활용하여 간단한 경제 분석 케이스 스터디를 진행해보려고 합니다. 가상의 국가 데이터를 가지고 GDP, 1인당 GDP, 경제 성장률, 물가 상승률 등을 계산하고, 국가 간 비교 분석을 수행하며, 그 결과를 시각화하는 전체 과정을 경험해 볼 것입니다.\n이를 통해 여러분은 파이썬이 실제 경제 데이터를 분석하고 인사이트를 도출하는 데 얼마나 유용한 도구인지 다시 한번 체감하고, 앞으로 파이썬을 활용한 경제 분석 능력을 키워나가는 데 자신감을 얻을 수 있을 것입니다.\n이번 시간 학습 목표:\n시나리오:\n우리는 3개 가상 국가(국가 A, 국가 B, 국가 C)의 최근 4년간 주요 거시경제 지표 데이터를 확보했습니다. 이 데이터를 바탕으로 각 국가의 경제 성과를 비교 분석하고 시각화하여 간단한 보고를 하려고 합니다.\n분석 대상 지표:\n데이터:\n(실제 분석에서는 보통 CSV 파일 등 외부 데이터를 읽어오지만, 이번 시간에는 배운 내용을 복습하기 위해 파이썬 리스트에 직접 데이터를 입력하여 사용합니다.)\n# --- 데이터 준비 ---\n\n# 연도 리스트\nyears = [2021, 2022, 2023, 2024]\n\n# 국가 A 데이터\ncountry_A = \"국가 A\"\ngdp_A = [500, 520, 545, 570] # 단위: 십억 달러\npop_A = [50, 51, 52, 53]     # 단위: 백만 명\ninf_A = [2.5, 3.1, 2.8, 2.2]     # 단위: %\n\n# 국가 B 데이터\ncountry_B = \"국가 B\"\ngdp_B = [1200, 1250, 1310, 1380] # 단위: 십억 달러\npop_B = [80, 81, 82, 83]      # 단위: 백만 명\ninf_B = [1.5, 2.2, 1.9, 1.7]      # 단위: %\n\n# 국가 C 데이터\ncountry_C = \"국가 C\"\ngdp_C = [80, 85, 92, 88]     # 단위: 십억 달러 (성장 정체/후퇴 가정)\npop_C = [20, 20.5, 21, 21.2]   # 단위: 백만 명\ninf_C = [4.5, 5.5, 4.8, 6.0]     # 단위: % (높은 물가 상승률 가정)\n\n# 데이터 확인 (선택 사항)\nprint(\"연도:\", years)\nprint(f\"{country_A} GDP:\", gdp_A)\nprint(f\"{country_B} 인구:\", pop_B)\nprint(f\"{country_C} 물가상승률:\", inf_C)\n\n연도: [2021, 2022, 2023, 2024]\n국가 A GDP: [500, 520, 545, 570]\n국가 B 인구: [80, 81, 82, 83]\n국가 C 물가상승률: [4.5, 5.5, 4.8, 6.0]",
    "crumbs": [
      "Curriculum",
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>8주차: 파이썬으로 경제 분석하기 (종합 응용 및 마무리)</span>"
    ]
  },
  {
    "objectID": "week8.html#종합-분석-시작-시나리오-및-데이터-준비",
    "href": "week8.html#종합-분석-시작-시나리오-및-데이터-준비",
    "title": "9  8주차: 파이썬으로 경제 분석하기 (종합 응용 및 마무리)",
    "section": "",
    "text": "연도 (Year)\n명목 GDP (Nominal GDP, 단위: 십억 달러)\n인구 (Population, 단위: 백만 명)\n물가 상승률 (Inflation Rate, 단위: %)",
    "crumbs": [
      "Curriculum",
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>8주차: 파이썬으로 경제 분석하기 (종합 응용 및 마무리)</span>"
    ]
  },
  {
    "objectID": "week8.html#데이터-탐색-및-주요-지표-계산",
    "href": "week8.html#데이터-탐색-및-주요-지표-계산",
    "title": "9  8주차: 파이썬으로 경제 분석하기 (종합 응용 및 마무리)",
    "section": "9.2 2. 데이터 탐색 및 주요 지표 계산",
    "text": "9.2 2. 데이터 탐색 및 주요 지표 계산\n이제 준비된 데이터를 바탕으로 주요 경제 지표들을 계산해 봅시다. 계산 로직을 함수로 만들어 재사용성을 높이는 것이 좋습니다.\n필요 함수 정의:\n\ndef calculate_gdp_per_capita(total_gdp_billion, population_million):\n  \"\"\"총 GDP(십억 달러)와 인구(백만 명)를 받아 1인당 GDP(달러)를 계산합니다.\"\"\"\n  if population_million &lt;= 0:\n    return None\n  # (십억 달러 * 10억) / (백만 명 * 1백만) = (십억 / 백만) * 달러 / 명 = 1000 * 달러 / 명\n  # 또는 (total_gdp_billion * 1,000,000,000) / (population_million * 1,000,000)\n  gdp_pc = (total_gdp_billion * 1000) / population_million\n  return gdp_pc\n\ndef calculate_gdp_growth_rate(gdp_prev, gdp_curr):\n  \"\"\"이전 연도 GDP와 현재 연도 GDP를 받아 연간 GDP 성장률(%)을 계산합니다.\"\"\"\n  if gdp_prev &lt;= 0: # 이전 GDP가 0 이하면 성장률 계산 불가 (또는 매우 큼)\n      return None\n  growth_rate = ((gdp_curr - gdp_prev) / gdp_prev) * 100\n  return growth_rate\n\n지표 계산 (반복문 활용):\n\n# 각 국가별 연도별 1인당 GDP 계산\ngdp_pc_A = []\nfor i in range(len(years)): # len(years)는 4, i는 0, 1, 2, 3\n    gdp_pc = calculate_gdp_per_capita(gdp_A[i], pop_A[i])\n    gdp_pc_A.append(gdp_pc)\n\ngdp_pc_B = []\nfor i in range(len(years)):\n    gdp_pc = calculate_gdp_per_capita(gdp_B[i], pop_B[i])\n    gdp_pc_B.append(gdp_pc)\n\ngdp_pc_C = []\nfor i in range(len(years)):\n    gdp_pc = calculate_gdp_per_capita(gdp_C[i], pop_C[i])\n    gdp_pc_C.append(gdp_pc)\n\nprint(\"--- 연도별 1인당 GDP (달러) ---\")\nprint(f\"{country_A}: {[f'{pc:.0f}' for pc in gdp_pc_A]}\") # 리스트 컴프리헨션으로 보기 좋게 출력\nprint(f\"{country_B}: {[f'{pc:.0f}' for pc in gdp_pc_B]}\")\nprint(f\"{country_C}: {[f'{pc:.0f}' for pc in gdp_pc_C]}\")\n\n\n# 각 국가별 연간 GDP 성장률 계산 및 평균 계산\ngdp_growth_A = []\nfor i in range(1, len(years)): # 1, 2, 3 (두 번째 해부터 시작)\n    growth = calculate_gdp_growth_rate(gdp_A[i-1], gdp_A[i])\n    gdp_growth_A.append(growth)\navg_growth_A = sum(gdp_growth_A) / len(gdp_growth_A) if gdp_growth_A else 0\n\ngdp_growth_B = []\nfor i in range(1, len(years)):\n    growth = calculate_gdp_growth_rate(gdp_B[i-1], gdp_B[i])\n    gdp_growth_B.append(growth)\navg_growth_B = sum(gdp_growth_B) / len(gdp_growth_B) if gdp_growth_B else 0\n\ngdp_growth_C = []\nfor i in range(1, len(years)):\n    growth = calculate_gdp_growth_rate(gdp_C[i-1], gdp_C[i])\n    gdp_growth_C.append(growth)\navg_growth_C = sum(gdp_growth_C) / len(gdp_growth_C) if gdp_growth_C else 0\n\n\nprint(\"\\n--- 연간 GDP 성장률 (%) ---\")\nprint(f\"{country_A}: {[f'{g:.2f}' for g in gdp_growth_A]}\")\nprint(f\"{country_B}: {[f'{g:.2f}' for g in gdp_growth_B]}\")\nprint(f\"{country_C}: {[f'{g:.2f}' for g in gdp_growth_C]}\") # 2024년에 마이너스 성장 포함\n\nprint(\"\\n--- 기간 내 평균 GDP 성장률 (%) ---\")\nprint(f\"{country_A}: {avg_growth_A:.2f}%\")\nprint(f\"{country_B}: {avg_growth_B:.2f}%\")\nprint(f\"{country_C}: {avg_growth_C:.2f}%\")\n\n\n# 물가 안정 목표 초과 연도 카운트 (예: 목표치 2.0%)\ninflation_target = 2.0\nhigh_inflation_years_A = 0\nfor rate in inf_A:\n    if rate &gt; inflation_target:\n        high_inflation_years_A += 1\n\nhigh_inflation_years_B = 0\nfor rate in inf_B:\n    if rate &gt; inflation_target:\n        high_inflation_years_B += 1\n\nhigh_inflation_years_C = 0\nfor rate in inf_C:\n    if rate &gt; inflation_target:\n        high_inflation_years_C += 1\n\nprint(f\"\\n--- 물가 안정 목표({inflation_target}%) 초과 연도 수 ---\")\nprint(f\"{country_A}: {high_inflation_years_A} 년\")\nprint(f\"{country_B}: {high_inflation_years_B} 년\")\nprint(f\"{country_C}: {high_inflation_years_C} 년\")\n\n--- 연도별 1인당 GDP (달러) ---\n국가 A: ['10000', '10196', '10481', '10755']\n국가 B: ['15000', '15432', '15976', '16627']\n국가 C: ['4000', '4146', '4381', '4151']\n\n--- 연간 GDP 성장률 (%) ---\n국가 A: ['4.00', '4.81', '4.59']\n국가 B: ['4.17', '4.80', '5.34']\n국가 C: ['6.25', '8.24', '-4.35']\n\n--- 기간 내 평균 GDP 성장률 (%) ---\n국가 A: 4.46%\n국가 B: 4.77%\n국가 C: 3.38%\n\n--- 물가 안정 목표(2.0%) 초과 연도 수 ---\n국가 A: 4 년\n국가 B: 1 년\n국가 C: 4 년",
    "crumbs": [
      "Curriculum",
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>8주차: 파이썬으로 경제 분석하기 (종합 응용 및 마무리)</span>"
    ]
  },
  {
    "objectID": "week8.html#국가-간-비교-분석-조건문-활용",
    "href": "week8.html#국가-간-비교-분석-조건문-활용",
    "title": "9  8주차: 파이썬으로 경제 분석하기 (종합 응용 및 마무리)",
    "section": "9.3 3. 국가 간 비교 분석 (조건문 활용)",
    "text": "9.3 3. 국가 간 비교 분석 (조건문 활용)\n계산된 지표들을 바탕으로 국가 간 경제 성과를 비교해 봅시다.\n\nprint(\"\\n--- 국가 간 비교 분석 ---\")\n\n# 1. 평균 GDP 성장률 비교\nprint(\"\\n[평균 GDP 성장률 비교]\")\nif avg_growth_A &gt; avg_growth_B and avg_growth_A &gt; avg_growth_C:\n    print(f\"{country_A}가 평균 성장률이 가장 높습니다 ({avg_growth_A:.2f}%).\")\nelif avg_growth_B &gt; avg_growth_A and avg_growth_B &gt; avg_growth_C:\n    print(f\"{country_B}가 평균 성장률이 가장 높습니다 ({avg_growth_B:.2f}%).\")\nelif avg_growth_C &gt; avg_growth_A and avg_growth_C &gt; avg_growth_B:\n     print(f\"{country_C}가 평균 성장률이 가장 높습니다 ({avg_growth_C:.2f}%).\")\nelse:\n    # 두 국가 이상이 동일하게 가장 높거나, 데이터 부족 등 예외 처리\n    print(\"평균 성장률이 가장 높은 국가를 특정하기 어렵거나 여러 국가가 동일합니다.\")\n    # 좀 더 정교하게 하려면 max 값을 찾고, 해당 값을 가진 모든 국가를 찾는 로직 필요\n\n# 2. 최근 연도(2024년) 1인당 GDP 비교 (gdp_pc_ 리스트의 마지막 값 사용)\nprint(\"\\n[2024년 1인당 GDP 비교]\")\ngdp_pc_last_A = gdp_pc_A[-1] # 리스트의 마지막 요소\ngdp_pc_last_B = gdp_pc_B[-1]\ngdp_pc_last_C = gdp_pc_C[-1]\n\n# 간단 비교 예시 (A와 B만 비교)\nif gdp_pc_last_A &gt; gdp_pc_last_B:\n    print(f\"2024년 1인당 GDP는 {country_A}(${gdp_pc_last_A:.0f})가 {country_B}(${gdp_pc_last_B:.0f})보다 높습니다.\")\nelse:\n    print(f\"2024년 1인당 GDP는 {country_B}(${gdp_pc_last_B:.0f})가 {country_A}(${gdp_pc_last_A:.0f})보다 높거나 같습니다.\")\n# (3개국 비교 로직은 더 복잡해짐)\n\n# 3. 물가 안정성 비교\nprint(\"\\n[물가 안정성 비교 (목표 초과 연도 수 기준)]\")\nif high_inflation_years_C &gt; high_inflation_years_A and high_inflation_years_C &gt; high_inflation_years_B:\n    print(f\"{country_C}가 물가 불안정 기간이 가장 길었습니다 ({high_inflation_years_C}년).\")\nelif high_inflation_years_B &gt; high_inflation_years_A and high_inflation_years_B &gt; high_inflation_years_C:\n     print(f\"{country_B}가 물가 불안정 기간이 가장 길었습니다 ({high_inflation_years_B}년).\")\nelif high_inflation_years_A &gt; high_inflation_years_B and high_inflation_years_A &gt; high_inflation_years_C:\n     print(f\"{country_A}가 물가 불안정 기간이 가장 길었습니다 ({high_inflation_years_A}년).\")\nelse:\n     print(\"물가 불안정 기간이 가장 긴 국가를 특정하기 어렵거나 여러 국가가 동일합니다.\")\n\n# 간단 요약\nprint(\"\\n[종합 의견 (예시)]\")\nprint(f\"- {country_B}는 꾸준한 성장과 비교적 안정적인 물가를 보였습니다.\")\nprint(f\"- {country_A}는 양호한 성장을 보였으나, 물가 관리에 다소 어려움이 있었습니다.\")\nprint(f\"- {country_C}는 성장 정체와 높은 물가 상승률을 동시에 겪는 어려움이 있었습니다.\")\n\n\n--- 국가 간 비교 분석 ---\n\n[평균 GDP 성장률 비교]\n국가 B가 평균 성장률이 가장 높습니다 (4.77%).\n\n[2024년 1인당 GDP 비교]\n2024년 1인당 GDP는 국가 B($16627)가 국가 A($10755)보다 높거나 같습니다.\n\n[물가 안정성 비교 (목표 초과 연도 수 기준)]\n물가 불안정 기간이 가장 긴 국가를 특정하기 어렵거나 여러 국가가 동일합니다.\n\n[종합 의견 (예시)]\n- 국가 B는 꾸준한 성장과 비교적 안정적인 물가를 보였습니다.\n- 국가 A는 양호한 성장을 보였으나, 물가 관리에 다소 어려움이 있었습니다.\n- 국가 C는 성장 정체와 높은 물가 상승률을 동시에 겪는 어려움이 있었습니다.",
    "crumbs": [
      "Curriculum",
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>8주차: 파이썬으로 경제 분석하기 (종합 응용 및 마무리)</span>"
    ]
  },
  {
    "objectID": "week8.html#분석-결과-시각화-matplotlib-활용",
    "href": "week8.html#분석-결과-시각화-matplotlib-활용",
    "title": "9  8주차: 파이썬으로 경제 분석하기 (종합 응용 및 마무리)",
    "section": "9.4 4. 분석 결과 시각화 (Matplotlib 활용)",
    "text": "9.4 4. 분석 결과 시각화 (Matplotlib 활용)\n계산하고 분석한 결과를 그래프로 시각화하여 추세와 비교를 더 명확하게 전달해 봅시다.\n\nimport matplotlib.pyplot as plt\nimport platform\n\n# 한글 폰트 설정 (이전 셀들에서 실행/설정되었다고 가정)\ntry:\n    if platform.system() == 'Linux': plt.rc('font', family='NanumBarunGothic')\n    elif platform.system() == 'Windows': plt.rc('font', family='Malgun Gothic')\n    elif platform.system() == 'Darwin': plt.rc('font', family='AppleGothic')\nexcept NameError: pass\nexcept FileNotFoundError: print(\"한글 폰트를 찾을 수 없습니다.\")\nplt.rcParams['axes.unicode_minus'] = False\n\n\n# --- 시각화 1: 국가별 1인당 GDP 추이 (선 그래프) ---\nplt.figure(figsize=(10, 6))\n\nplt.plot(years, gdp_pc_A, marker='o', label=country_A)\nplt.plot(years, gdp_pc_B, marker='s', label=country_B)\nplt.plot(years, gdp_pc_C, marker='^', label=country_C)\n\nplt.title('국가별 1인당 GDP 추이', fontsize=15)\nplt.xlabel('연도', fontsize=12)\nplt.ylabel('1인당 GDP (단위: 달러)', fontsize=12)\nplt.legend()\nplt.grid(True, linestyle=':', alpha=0.7)\nplt.xticks(years) # 연도 눈금 표시\n\nplt.show()\n\n\n# --- 시각화 2: 국가별 평균 GDP 성장률 비교 (막대 그래프) ---\ncountries = [country_A, country_B, country_C]\navg_growths = [avg_growth_A, avg_growth_B, avg_growth_C]\n\nplt.figure(figsize=(8, 6))\nbars = plt.bar(countries, avg_growths, color=['skyblue', 'lightcoral', 'lightgreen'])\n# 막대 위에 값 표시 (선택 사항)\nfor bar in bars:\n    yval = bar.get_height()\n    plt.text(bar.get_x() + bar.get_width()/2.0, yval, f'{yval:.2f}%', va='bottom' if yval &gt;=0 else 'top', ha='center')\n\n\nplt.title('국가별 평균 GDP 성장률 비교', fontsize=15)\nplt.ylabel('평균 성장률 (%)', fontsize=12)\n# plt.xlabel('국가') # x축 레이블은 국가 이름으로 충분하면 생략 가능\nplt.axhline(0, color='grey', linewidth=0.8) # 성장률 0 기준선 추가\n\nplt.show()\n\n# --- 시각화 3: 국가별 물가 상승률 추이 (선 그래프) ---\nplt.figure(figsize=(10, 6))\n\nplt.plot(years, inf_A, marker='o', label=country_A)\nplt.plot(years, inf_B, marker='s', label=country_B)\nplt.plot(years, inf_C, marker='^', label=country_C)\n# 물가 안정 목표선 추가\nplt.axhline(inflation_target, color='red', linestyle='--', linewidth=1, label=f'안정 목표 ({inflation_target}%)')\n\nplt.title('국가별 물가 상승률 추이', fontsize=15)\nplt.xlabel('연도', fontsize=12)\nplt.ylabel('물가 상승률 (%)', fontsize=12)\nplt.legend()\nplt.grid(True, linestyle=':', alpha=0.7)\nplt.xticks(years)\n\nplt.show()\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  Cell In[6], line 1\n    시각화 결과를 통해 우리는 각 국가의 1인당 GDP가 어떻게 변화했는지, 평균 성장률은 어느 국가가 높았는지, 물가 안정 목표는 잘 관리되었는지 등을 한눈에 파악할 수 있습니다. 예를 들어, 국가 B는 1인당 GDP가 가장 높고 꾸준히 증가하며 평균 성장률도 양호하고 물가도 안정적인 반면, 국가 C는 1인당 GDP 증가가 미미하고 평균 성장률이 낮으며 물가 상승률이 높은 어려움을 겪고 있음을 그래프를 통해 쉽게 알 수 있습니다.\n                         ^\nSyntaxError: invalid decimal literal\n\n\n\n\n시각화 결과를 통해 우리는 각 국가의 1인당 GDP가 어떻게 변화했는지, 평균 성장률은 어느 국가가 높았는지, 물가 안정 목표는 잘 관리되었는지 등을 한눈에 파악할 수 있습니다. 예를 들어, 국가 B는 1인당 GDP가 가장 높고 꾸준히 증가하며 평균 성장률도 양호하고 물가도 안정적인 반면, 국가 C는 1인당 GDP 증가가 미미하고 평균 성장률이 낮으며 물가 상승률이 높은 어려움을 겪고 있음을 그래프를 통해 쉽게 알 수 있습니다.",
    "crumbs": [
      "Curriculum",
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>8주차: 파이썬으로 경제 분석하기 (종합 응용 및 마무리)</span>"
    ]
  },
  {
    "objectID": "week8.html#과정-마무리-및-앞으로의-학습-방향",
    "href": "week8.html#과정-마무리-및-앞으로의-학습-방향",
    "title": "9  8주차: 파이썬으로 경제 분석하기 (종합 응용 및 마무리)",
    "section": "9.5 5. 과정 마무리 및 앞으로의 학습 방향",
    "text": "9.5 5. 과정 마무리 및 앞으로의 학습 방향\n여러분, 8주간의 ‘경제학도를 위한 파이썬 기초’ 수업에 참여하시느라 정말 수고 많으셨습니다! 오늘 우리는 지난 7주간 배운 파이썬의 핵심 요소들 – 변수, 자료형, 리스트, 딕셔너리, 조건문, 반복문, 함수, 그리고 기초적인 시각화 – 을 모두 활용하여 간단하지만 의미 있는 경제 데이터 분석 케이스 스터디를 수행했습니다.\n이 과정을 통해 여러분은 다음과 같은 파이썬의 힘을 경험하셨기를 바랍니다.\n\n데이터의 구조화: 리스트와 딕셔너리를 이용해 여러 데이터를 체계적으로 관리할 수 있습니다.\n계산 자동화: 함수와 반복문을 이용해 복잡하거나 반복적인 계산(1인당 GDP, 성장률 등)을 효율적으로 수행할 수 있습니다.\n논리적 분석: 조건문을 이용해 데이터에 기반한 판단(국가 간 비교, 목표 달성 여부 등)을 내릴 수 있습니다.\n효과적인 시각화: Matplotlib을 이용해 분석 결과를 명확하고 직관적인 그래프로 표현하여 인사이트를 얻고 소통할 수 있습니다.\n\n이 수업은 끝났지만, 여러분의 파이썬 여정은 이제 시작입니다!\n오늘 우리가 다룬 내용은 파이썬의 방대한 능력 중 아주 일부에 불과합니다. 경제/금융 데이터 분석 분야에서 파이썬을 더욱 강력하게 활용하기 위해 다음과 같은 주제들을 앞으로 더 학습해 보시기를 적극 추천합니다.\n\nPandas 라이브러리: 파이썬 데이터 분석의 핵심입니다. 엑셀의 스프레드시트와 유사한 형태(DataFrame)로 데이터를 다루며, 데이터 로딩(CSV, Excel 파일 등), 정제, 필터링, 그룹화, 집계 등 훨씬 강력하고 편리한 데이터 처리 기능을 제공합니다. (가장 먼저 학습 추천!)\nNumPy 라이브러리: 고성능 수치 계산에 특화된 라이브러리입니다. 다차원 배열(행렬 등) 연산을 매우 빠르게 처리하며, Pandas를 비롯한 다른 과학 계산 라이브러리의 기반이 됩니다. 계량경제학이나 통계 모델링에 필수적입니다.\nMatplotlib 심화 및 Seaborn: 오늘 배운 Matplotlib의 더 다양한 그래프 종류와 고급 꾸미기 옵션을 익히고, Matplotlib 기반으로 더 아름답고 통계적인 그래프를 쉽게 그릴 수 있게 해주는 Seaborn 라이브러리를 배우면 시각화 능력이 크게 향상됩니다.\nStatsmodels / Scikit-learn: 통계 분석 및 계량경제 모델링(회귀분석, 시계열 분석 등)을 위한 Statsmodels, 머신러닝 모델 구축 및 평가를 위한 Scikit-learn 등 전문적인 분석 라이브러리들을 학습하면 실제 연구나 실무에 파이썬을 적용할 수 있습니다.\n\n이러한 도구들을 익히고, 실제 경제 데이터(한국은행 ECOS, 통계청 KOSIS, World Bank Data 등)를 가져와 직접 분석하고 시각화하는 개인적인 프로젝트를 진행해 보는 것이 최고의 학습 방법입니다. Kaggle과 같은 데이터 분석 플랫폼에서 다른 사람들의 코드를 보고 배우는 것도 좋습니다.\n다시 한번 8주간 열정적으로 참여해주신 여러분께 감사드리며, 파이썬이라는 강력한 도구를 통해 경제학적 통찰력을 더욱 키워나가시기를 응원하겠습니다! 궁금한 점이 있다면 언제든지 질문해주세요.",
    "crumbs": [
      "Curriculum",
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>8주차: 파이썬으로 경제 분석하기 (종합 응용 및 마무리)</span>"
    ]
  },
  {
    "objectID": "week8.html#선택-여덟-번째-주차-과제",
    "href": "week8.html#선택-여덟-번째-주차-과제",
    "title": "9  8주차: 파이썬으로 경제 분석하기 (종합 응용 및 마무리)",
    "section": "9.6 (선택) 여덟 번째 주차 과제",
    "text": "9.6 (선택) 여덟 번째 주차 과제\n그동안 배운 내용을 최종적으로 점검하고 응용력을 키우기 위한 선택적 과제입니다.\n\n케이스 스터디 확장:\n\n오늘 진행한 케이스 스터디에서 사용된 3개 국가 데이터에 대해, 평균 물가 상승률을 계산하고 비교하는 분석을 추가해보세요.\n1인당 GDP와 평균 GDP 성장률을 각각 x축과 y축으로 하는 산점도를 그려서, 국가들이 어떤 그룹(예: 고성장-고소득, 저성장-고소득 등)에 위치하는지 시각적으로 표현해보세요.\n\n개인 프로젝트 아이디어 구상:\n\n여러분이 관심 있는 경제/금융/사회 현상(예: 특정 산업 동향, 환율 변동 요인, 부동산 가격 변화, 주식 시장 분석 등)을 하나 선정하고, 이 현상을 분석하기 위해 어떤 데이터가 필요하며 파이썬(지금까지 배운 내용 또는 앞으로 배울 내용 포함)을 어떻게 활용할 수 있을지 간단한 분석 계획을 세워보세요. (예: 어떤 데이터를 수집 -&gt; 어떤 지표 계산 -&gt; 어떤 조건으로 분석 -&gt; 어떤 그래프로 시각화)\n\n\n(이번 주차는 과제 제출보다는, 자율적으로 복습하고 응용해보는 것을 권장합니다.)",
    "crumbs": [
      "Curriculum",
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>8주차: 파이썬으로 경제 분석하기 (종합 응용 및 마무리)</span>"
    ]
  }
]